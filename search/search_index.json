{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Structures and Algorithms Simplified Getting Started This website contains important content on data structures, algorithms and competitive coding questions. This can be used to revise important DSA concepts quickly. This does not contain detailed information about respective topic.","title":"Preface"},{"location":"#data-structures-and-algorithms-simplified","text":"","title":"Data Structures and Algorithms Simplified"},{"location":"#getting-started","text":"This website contains important content on data structures, algorithms and competitive coding questions. This can be used to revise important DSA concepts quickly. This does not contain detailed information about respective topic.","title":"Getting Started"},{"location":"debugEnhancement/","text":"#define Test #ifdef Test #define debug(x) cout << #x<<\" \"; _print(x); cout << endl; #else #define debug(x); #endif typedef long long ll ; typedef unsigned long long ull ; typedef long double lld ; void _print ( ll t ) { cout << t ;} void _print ( int t ) { cout << t ;} void _print ( string t ) { cout << t ;} void _print ( char t ) { cout << t ;} void _print ( lld t ) { cout << t ;} void _print ( double t ) { cout << t ;} void _print ( ull t ) { cout << t ;} template < class T , class V > void _print ( pair < T , V > p ); template < class T > void _print ( vector < T > v ); template < class T > void _print ( set < T > v ); template < class T , class V > void _print ( map < T , V > v ); template < class T > void _print ( multiset < T > v ); template < class T , class V > void _print ( pair < T , V > p ) { cout << \"{\" ; _print ( p . ff ); cout << \",\" ; _print ( p . ss ); cout << \"}\" ;} template < class T > void _print ( vector < T > v ) { cout << \"[ \" ; for ( T i : v ) { _print ( i ); cout << \" \" ;} cout << \"]\" ;} template < class T > void _print ( set < T > v ) { cout << \"[ \" ; for ( T i : v ) { _print ( i ); cout << \" \" ;} cout << \"]\" ;} template < class T > void _print ( multiset < T > v ) { cout << \"[ \" ; for ( T i : v ) { _print ( i ); cout << \" \" ;} cout << \"]\" ;} template < class T , class V > void _print ( map < T , V > v ) { cout << \"[ \" ; for ( auto i : v ) { _print ( i ); cout << \" \" ;} cout << \"]\" ;} Hashtable Implementation hashTable_t * hash_newTable ( int len , int ( * hash )( key_t , hashTable_t * htable ), int ( * compare )( key_t , void * )) {","title":"BoilerplateCode"},{"location":"debugEnhancement/#hashtable-implementation","text":"hashTable_t * hash_newTable ( int len , int ( * hash )( key_t , hashTable_t * htable ), int ( * compare )( key_t , void * )) {","title":"Hashtable Implementation"},{"location":"Algorithms/Resources/algo_resources/","text":"cp-algorithms Leetcode C++ solutions (Not necessarily best answers though)","title":"Resources"},{"location":"Algorithms/Resources/algo_resources/#cp-algorithms","text":"","title":"cp-algorithms"},{"location":"Algorithms/Resources/algo_resources/#leetcode-c-solutions-not-necessarily-best-answers-though","text":"","title":"Leetcode C++ solutions (Not necessarily best answers though)"},{"location":"Algorithms/basic/sorting/","text":"Sorting Algorithms Insertion Sort INSERTION - SORT ( A ) for j = 2 to A . length key = A [ j ] //Insert A[j] into the sorted sequence A[1...j-1] i = j - 1 while i > 0 and A [ i ] > key A [ i + 1 ] = A [ i ] i = i - 1 A [ i + 1 ] = key Worst case running time is a quadratic function. Running time: $\\Theta(n^2)$. Bubble Sort void bubbleSort ( int arr [], int n ) { int i , j ; for ( i = 0 ; i < n -1 ; i ++ ) // Last i elements are already in place for ( j = 0 ; j < n - i -1 ; j ++ ) if ( arr [ j ] > arr [ j + 1 ]) swap ( & arr [ j ], & arr [ j + 1 ]); } Selection Sort The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array. 1) The subarray which is already sorted. 2) Remaining subarray which is unsorted. In every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray. void selectionSort ( int arr [], int n ) { int i , j , min_idx ; // One by one move boundary of unsorted subarray for ( i = 0 ; i < n -1 ; i ++ ) { // Find the minimum element in unsorted array min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ]) min_idx = j ; // Swap the found minimum element with the first element swap ( & arr [ min_idx ], & arr [ i ]); } } Quick Sort Difference between normal quick sort and randomized quick sort is that there will be a random number in low-high range and instead of directly using high as pivot index, we will first swap elements and random and high index and then use high as pivot index. start as pivot : https://www.youtube.com/watch?v=cnzIChso3cc #include <iostream> #include <cstdlib> using namespace std ; // Swapping two values. void swap ( int * a , int * b ) { int temp ; temp = * a ; * a = * b ; * b = temp ; } // Partitioning the array on the basis of values at high as pivot value. int Partition ( int a [], int low , int high ) { int pivot , i , j ; i = low ; j = low ; pivot = high ; // Getting index of pivot. for (; j < high ; j ++ ) { if ( a [ j ] < a [ pivot ]) { swap ( & a [ j ], & a [ i ]); i ++ ; } } // Swapping value at high and at the index obtained. swap ( & a [ pivot ], & a [ i ]); return i ; } // Random selection of pivot. int RandomPivotPartition ( int a [], int low , int high ) { int pvt , n , temp ; n = rand (); // Randomizing the pivot value in the given subpart of array. pvt = low + n % ( high - low + 1 ); // Swapping pvt value from high, so pvt value will be taken as pivot while partitioning. swap ( & a [ high ], & a [ pvt ]); return Partition ( a , low , high ); } // Implementing QuickSort algorithm. int QuickSort ( int a [], int low , int high ) { int pindex ; if ( low < high ) { // Partitioning array using randomized pivot. pindex = RandomPivotPartition ( a , low , high ); // Recursively implementing QuickSort. QuickSort ( a , low , pindex -1 ); QuickSort ( a , pindex + 1 , high ); } return 0 ; } Merge Sort void merge ( int A [ ] , int start , int mid , int end ) { //stores the starting position of both parts in temporary variables. int p = start , q = mid + 1 ; int Arr [ end - start + 1 ] , k = 0 ; //Arr is temporary array for ( int i = start ; i <= end ; i ++ ) { //copying remaining elements if ( p > mid ) //checks if first part comes to an end or not . Arr [ k ++ ] = A [ q ++ ] ; else if ( q > end ) //checks if second part comes to an end or not Arr [ k ++ ] = A [ p ++ ]; //actual merging else if ( A [ p ] < A [ q ]) //checks which part has smaller element. Arr [ k ++ ] = A [ p ++ ]; else Arr [ k ++ ] = A [ q ++ ]; } for ( int p = 0 ; p < k ; p ++ ) { /* Now the real array has elements in sorted manner including both parts.*/ A [ start ++ ] = Arr [ p ] ; } } void merge_sort ( int A [ ] , int start , int end ) { if ( start < end ) { int mid = ( start + end ) / 2 ; // defines the current array in 2 parts . merge_sort ( A , start , mid ) ; // sort the 1st part of array . merge_sort ( A , mid + 1 , end ) ; // sort the 2nd part of array. // merge the both parts by comparing elements of both the parts. merge ( A , start , mid , end ); } } Heap Sort Watch this : https://www.youtube.com/watch?v=MtQL_ll5KhQ left = 2 * i + 1 right = 2 * i + 2 1. make input as max heap 2. Start taking out max i.e. arr[0] by swapping with last element of unsorted part 3. max heapify for arr[0] // C++ program for implementation of Heap Sort #include <iostream> using namespace std ; // To heapify a subtree rooted with node i which is // an index in arr[]. n is size of heap void heapify ( int arr [], int n , int i ) { int largest = i ; // Initialize largest as root int l = 2 * i + 1 ; // left = 2*i + 1 int r = 2 * i + 2 ; // right = 2*i + 2 // If left child is larger than root if ( l < n && arr [ l ] > arr [ largest ]) largest = l ; // If right child is larger than largest so far if ( r < n && arr [ r ] > arr [ largest ]) largest = r ; // If largest is not root if ( largest != i ) { swap ( arr [ i ], arr [ largest ]); // Recursively heapify the affected sub-tree heapify ( arr , n , largest ); } } // main function to do heap sort void heapSort ( int arr [], int n ) { // Build heap (rearrange array) for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ); // One by one extract an element from heap for ( int i = n - 1 ; i > 0 ; i -- ) { // Move current root to end swap ( arr [ 0 ], arr [ i ]); // call max heapify on the reduced heap heapify ( arr , i , 0 ); } } /* A utility function to print array of size n */ void printArray ( int arr [], int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << \" \" ; cout << \" \\n \" ; } Couting Sort Radix Sort","title":"Sorting"},{"location":"Algorithms/basic/sorting/#sorting-algorithms","text":"","title":"Sorting Algorithms"},{"location":"Algorithms/basic/sorting/#insertion-sort","text":"INSERTION - SORT ( A ) for j = 2 to A . length key = A [ j ] //Insert A[j] into the sorted sequence A[1...j-1] i = j - 1 while i > 0 and A [ i ] > key A [ i + 1 ] = A [ i ] i = i - 1 A [ i + 1 ] = key Worst case running time is a quadratic function. Running time: $\\Theta(n^2)$.","title":"Insertion Sort"},{"location":"Algorithms/basic/sorting/#bubble-sort","text":"void bubbleSort ( int arr [], int n ) { int i , j ; for ( i = 0 ; i < n -1 ; i ++ ) // Last i elements are already in place for ( j = 0 ; j < n - i -1 ; j ++ ) if ( arr [ j ] > arr [ j + 1 ]) swap ( & arr [ j ], & arr [ j + 1 ]); }","title":"Bubble Sort"},{"location":"Algorithms/basic/sorting/#selection-sort","text":"The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array. 1) The subarray which is already sorted. 2) Remaining subarray which is unsorted. In every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray. void selectionSort ( int arr [], int n ) { int i , j , min_idx ; // One by one move boundary of unsorted subarray for ( i = 0 ; i < n -1 ; i ++ ) { // Find the minimum element in unsorted array min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ]) min_idx = j ; // Swap the found minimum element with the first element swap ( & arr [ min_idx ], & arr [ i ]); } }","title":"Selection Sort"},{"location":"Algorithms/basic/sorting/#quick-sort","text":"Difference between normal quick sort and randomized quick sort is that there will be a random number in low-high range and instead of directly using high as pivot index, we will first swap elements and random and high index and then use high as pivot index. start as pivot : https://www.youtube.com/watch?v=cnzIChso3cc #include <iostream> #include <cstdlib> using namespace std ; // Swapping two values. void swap ( int * a , int * b ) { int temp ; temp = * a ; * a = * b ; * b = temp ; } // Partitioning the array on the basis of values at high as pivot value. int Partition ( int a [], int low , int high ) { int pivot , i , j ; i = low ; j = low ; pivot = high ; // Getting index of pivot. for (; j < high ; j ++ ) { if ( a [ j ] < a [ pivot ]) { swap ( & a [ j ], & a [ i ]); i ++ ; } } // Swapping value at high and at the index obtained. swap ( & a [ pivot ], & a [ i ]); return i ; } // Random selection of pivot. int RandomPivotPartition ( int a [], int low , int high ) { int pvt , n , temp ; n = rand (); // Randomizing the pivot value in the given subpart of array. pvt = low + n % ( high - low + 1 ); // Swapping pvt value from high, so pvt value will be taken as pivot while partitioning. swap ( & a [ high ], & a [ pvt ]); return Partition ( a , low , high ); } // Implementing QuickSort algorithm. int QuickSort ( int a [], int low , int high ) { int pindex ; if ( low < high ) { // Partitioning array using randomized pivot. pindex = RandomPivotPartition ( a , low , high ); // Recursively implementing QuickSort. QuickSort ( a , low , pindex -1 ); QuickSort ( a , pindex + 1 , high ); } return 0 ; }","title":"Quick Sort"},{"location":"Algorithms/basic/sorting/#merge-sort","text":"void merge ( int A [ ] , int start , int mid , int end ) { //stores the starting position of both parts in temporary variables. int p = start , q = mid + 1 ; int Arr [ end - start + 1 ] , k = 0 ; //Arr is temporary array for ( int i = start ; i <= end ; i ++ ) { //copying remaining elements if ( p > mid ) //checks if first part comes to an end or not . Arr [ k ++ ] = A [ q ++ ] ; else if ( q > end ) //checks if second part comes to an end or not Arr [ k ++ ] = A [ p ++ ]; //actual merging else if ( A [ p ] < A [ q ]) //checks which part has smaller element. Arr [ k ++ ] = A [ p ++ ]; else Arr [ k ++ ] = A [ q ++ ]; } for ( int p = 0 ; p < k ; p ++ ) { /* Now the real array has elements in sorted manner including both parts.*/ A [ start ++ ] = Arr [ p ] ; } } void merge_sort ( int A [ ] , int start , int end ) { if ( start < end ) { int mid = ( start + end ) / 2 ; // defines the current array in 2 parts . merge_sort ( A , start , mid ) ; // sort the 1st part of array . merge_sort ( A , mid + 1 , end ) ; // sort the 2nd part of array. // merge the both parts by comparing elements of both the parts. merge ( A , start , mid , end ); } }","title":"Merge Sort"},{"location":"Algorithms/basic/sorting/#heap-sort","text":"Watch this : https://www.youtube.com/watch?v=MtQL_ll5KhQ left = 2 * i + 1 right = 2 * i + 2 1. make input as max heap 2. Start taking out max i.e. arr[0] by swapping with last element of unsorted part 3. max heapify for arr[0] // C++ program for implementation of Heap Sort #include <iostream> using namespace std ; // To heapify a subtree rooted with node i which is // an index in arr[]. n is size of heap void heapify ( int arr [], int n , int i ) { int largest = i ; // Initialize largest as root int l = 2 * i + 1 ; // left = 2*i + 1 int r = 2 * i + 2 ; // right = 2*i + 2 // If left child is larger than root if ( l < n && arr [ l ] > arr [ largest ]) largest = l ; // If right child is larger than largest so far if ( r < n && arr [ r ] > arr [ largest ]) largest = r ; // If largest is not root if ( largest != i ) { swap ( arr [ i ], arr [ largest ]); // Recursively heapify the affected sub-tree heapify ( arr , n , largest ); } } // main function to do heap sort void heapSort ( int arr [], int n ) { // Build heap (rearrange array) for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ); // One by one extract an element from heap for ( int i = n - 1 ; i > 0 ; i -- ) { // Move current root to end swap ( arr [ 0 ], arr [ i ]); // call max heapify on the reduced heap heapify ( arr , i , 0 ); } } /* A utility function to print array of size n */ void printArray ( int arr [], int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << \" \" ; cout << \" \\n \" ; }","title":"Heap Sort"},{"location":"Algorithms/basic/sorting/#couting-sort","text":"","title":"Couting Sort"},{"location":"Algorithms/basic/sorting/#radix-sort","text":"","title":"Radix Sort"},{"location":"CompCoding/Hard/dp/","text":"62. Unique Paths (Simple DP) There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. class Solution { public : int uniquePaths ( int m , int n ) { vector < vector < long long int >> matrix ( m , vector < long long int > ( n , 1 )); for ( int row = m -2 ; row >= 0 ; row -- ) { for ( int col = n -2 ; col >= 0 ; col -- ) { matrix [ row ][ col ] = matrix [ row ][ col + 1 ] + matrix [ row + 1 ][ col ]; } } return matrix [ 0 ][ 0 ]; } }; 0-1 Knapsack Problem Statement: Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. In other words, given two integer arrays val[0..n-1] and wt[0..n-1] which represent values and weights associated with n items respectively. Also given an integer W which represents knapsack capacity, find out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to W. You cannot break an item, either pick the complete item or don\u2019t pick it (0-1 property). Solution: Optimal Sub-structure: To consider all subsets of items, there can be two cases for every item. Case 1: The item is included in the optimal subset. Case 2: The item is not included in the optimal set. Therefore, the maximum value that can be obtained from \u2018n\u2019 items is the max of the following two values. 1. Maximum value obtained by n-1 items and W weight (excluding nth item). 2. Value of nth item plus maximum value obtained by n-1 items and W minus the weight of the nth item (including nth item). #include <bits/stdc++.h> using namespace std ; int knapSack ( int W , int wt [], int val [], int n ) { // making and initializing dp array int dp [ W + 1 ]; memset ( dp , 0 , sizeof ( dp )); for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int w = W ; w >= 0 ; w -- ) { if ( wt [ i - 1 ] <= w ) // finding the maximum value dp [ w ] = max ( dp [ w ], dp [ w - wt [ i - 1 ]] + val [ i - 1 ]); } } return dp [ W ]; // returning the maximum value of knapsack } int main () { int val [] = { 60 , 100 , 120 }; int wt [] = { 10 , 20 , 30 }; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ]); cout << knapSack ( W , wt , val , n ); return 0 ; } Subset Sum Problem Problem: Given a set of non-negative integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum. Solution: Similar to knapsack. Create a DP array of sum and elements. Return true if 1. Subset sum is possible without current element or 2. [Subset sum - current element] is possible with n-1 elements. DP[ind][sum]; DP[i][j] = DP[i-1][sum] if( sum-input[i] >= 0 ) DP[i][j] = DP[i][j] || DP[i-1][sum-input[i]] //Bottom up DP solution Equal sum partition Use above subset sum problem and find if there exists any subset with target sum = Total sum / 2 Count of subsets with Sum In subset sum problem, instead of keeping bool, keep count of subsets with given sum and replace or with +. Minimum subset sum difference Min subset sum difference could be 0 i.e. similar to equal sum partition. In equal sum partition, we were returning true or false from last block i.e. dp[i][j] where i=size of input, j=target sum Here, we will return maximum sum (i.e. i) for which dp[i][sum] (last column) is true. Count subsets with given sum difference Here we need to count subsets with sum = ( Total sum - diff ) / 2 How to come up with above formula? Lets say we partition set with 1 subset sum=X and other subset sum =Y X+Y=TotalSum -> Y = TotalSum-X or X = TotalSum-Y | X-Y | = diff X = diff + Y X = diff + TotalSum - X TotalSum - Y = diff + Y 2 * X = diff + TotalSum TotalSum - diff = 2 * Y X = (diff + TotalSum) / 2 Y = ( TotalSum - diff) / 2 You can use any of the formula. Target Sum Problem You are given an array of positive integers. You need to find number of ways by which you can make total sum of that array as given number. You are allowed to assign + or - sign to each element. This is same as Count subsets with given sum difference. But it is difficult to identify. Unbounded Knapsack Same item can be taken multiple times. DP [ i ] [ j ] = max ( DP[ i-1 ] [ j ] , DP [ i ] [ j - weight [ i ] ] ); Rod Cutting Problem There are 2^length-1 options to cut rod. We can either cut or not cut between i , i + 1 for i=1,7 in following case. So 2^7 options. There is an optimal substructure property. If we know answer for length smaller than n then we can use that value in calculation for length n. 1 2 3 4 5 6 7 8 cutRod(n) = max(price[i] + cutRod(n-i-1)) for all i in {0, 1 .. n-1} Coin Change (Combination Sum) Given the target value N and array of allowed numbers, count number of way to write N as sum of those numbers. Here only sum matters. How we are using those coins does not matter. 1+1+2 here we have already used 1s and then used 2 2+1+1 here we have used 2 first and then used 1 which is also allowed. E.g. nums = [1,2,3] N=4 1+1+1+1, 1+1+2, 1+2+1, 1+3, 2+1+1, 2+2, 3+1 -> total 7 Note that 1+1+2 and 1+2+1 are counted as different way. //top down dp [ 0 ] = 1 ; for i in 1. . N : for x in nums : dp [ i ] += dp [ i - x ] //bottom up dp [ 0 ] = 1 ; for i in 1. . N : for x in nums : dp [ i + x ] += dp [ i ] Coin Change (min) You are given denominations of coins and the target amount N. What is the minimum possible number of coins used. E.g.1: nums=[1,2,5] N=11 5+5+1 -> 3 coins E.g.2: nums=[1,3,4] N=6 3+3 -> 2 coins dp [ 0 ] = 0 ; dp [ 1. . N ] = INF for i in 1. . N : for x in nums : dp [ i ] = min ( dp [ i ], dp [ i - x ] + 1 ) Coin change (ways) You are given denomination of coins and the target amount N. What is the number of ways to make up amount N ? E.g. nums=[1,2,5] N=5 5, 1+2+2, 1+1+1+2, 1+1+1+1+1 -> 4 Ways Note that order does not matter here. Here not only sum matters, here sum,coins used till now both matters. This is unbounded knapsack. Here last used coin matters. Since you want to avoid counting 1+2+2 and 2+1+2 differently. You can consider only ascending order ways. Think of it this way: Currently we have 1,2,5 coins. Let's first find no of ways using only 1, then find no of ways using 1,2, etc. dp[amount][coin_i] = dp[ amount-value[coin_i] ][coin_i] + dp[amount][coin_i-1] include coin_i don't include coin_i, so same amount using coin_i-1 coins Form a 2d dp table. Longest Common Subsequence C(i,j) = LCS[ text1(1..i), text2(1..j) ] LCS(text1,text2) = C(m,n) m=length of text1, n=length of text2 C(i,j) = if text1[i] == text2[j] -> C(i-1,j-1) = else max( C(i-1,j), C(i,j-1) ) int longestCommonSubsequence ( string text1 , string text2 ) { short dp [ 1001 ][ 1001 ]; for ( int i = 0 ; i <= text1 . size (); i ++ ) { dp [ i ][ 0 ] = 0 ; } for ( int j = 0 ; j <= text1 . size (); j ++ ) { dp [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i <= text1 . size (); i ++ ) { for ( int j = 1 ; j <= text2 . size (); j ++ ) { //LCS[x,y] = 1 + LCS(x-1,y-1) if equal // else max(LCS(x-1,y), LCS(x,y-1)) dp [ i ][ j ] = text1 [ i -1 ] == text2 [ j -1 ] ? 1 + dp [ i -1 ][ j -1 ] : max ( dp [ i -1 ][ j ], dp [ i ][ j -1 ]); } } return dp [ text1 . size ()][ text2 . size ()]; } //Function to print lcs // Recursive function to find the longest common subsequence of // string `X[0\u2026m-1]` and `Y[0\u2026n-1]` string LCS ( string X , string Y , int m , int n , auto & dp ) { // return an empty string if the end of either sequence is reached if ( m == 0 || n == 0 ) { return string ( \"\" ); } // if the last character of `X` and `Y` matches if ( X [ m - 1 ] == Y [ n - 1 ]) { // append current character (`X[m-1]` or `Y[n-1]`) to LCS of // substring `X[0\u2026m-2]` and `Y[0\u2026n-2]` return LCS ( X , Y , m - 1 , n - 1 , dp ) + X [ m - 1 ]; } // otherwise, if the last character of `X` and `Y` are different // if a top cell of the current cell has more value than the left // cell, then drop the current character of string `X` and find LCS // of substring `X[0\u2026m-2]`, `Y[0\u2026n-1]` if ( dp [ m - 1 ][ n ] > dp [ m ][ n - 1 ]) { return LCS ( X , Y , m - 1 , n , dp ); } else { // if a left cell of the current cell has more value than the top // cell, then drop the current character of string `Y` and find LCS // of substring `X[0\u2026m-1]`, `Y[0\u2026n-2]` return LCS ( X , Y , m , n - 1 , dp ); } } Longest Common Substring dp[i][j] represents longest common substring ending at str1[i], str2[j] int LCStr ( string str1 , string str2 , int N , int M ) { int dp [ N + 1 ][ M + 1 ]; int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { if ( i == 0 || j == 0 ){ dp [ i ][ j ] = 0 ; } else if ( str1 [ i - 1 ] == str2 [ j - 1 ]) { dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 ; ans = max ( ans , dp [ i ][ j ]); } else dp [ i ][ j ] = 0 ; } } return ans ; } Shortest supersequence Subsequence: Here x is a subsequence of y. Order matters but need not be contiguous. x : a b c d y : a x y b z p c q r d Substring: Here x is substring of y. Complete string shouuld be part of parent string. x : a b c d y : p q r a b c d s t Minimum length string containing both strings X and Y as subsequence. Shortest supersequence length = x.size() + y.size() - 2 * LCS(x,y) Minuimum number of insertions and deletions to convert string a to string b ans = b.size() - LCS(a,b) Longest palindromic subsequence xr = reverse(x.begin(), x.end()); LPS = LCS(x, xr); Minimum number of deletions to make it palindrome ans = x.size() - LPS Longest Repeating Subsequence A A B E B C D D A B D LCS but with additional condition int longestCommonSubsequence(string text1) { string text2 = text1; short dp[1001][1001]; for(int i=0; i<= text1.size(); i++) { dp[i][0] = 0; } for(int j=0; j<= text1.size(); j++) { dp[0][j] = 0; } for(int i=1; i<=text1.size(); i++) { for(int j=1; j<=text2.size(); j++) { //LCS[x,y] = 1 + LCS(x-1,y-1) if equal // else max(LCS(x-1,y), LCS(x,y-1)) //(i!=j) condition to make sure that same position characters are not matched dp[i][j] = text1[i-1] == text2[j-1] && (i!=j) ? 1+dp[i-1][j-1] : max(dp[i-1][j],dp[i][j-1]); } } return dp[text1.size()][text2.size()]; } Minimum number of insertions to make it palindrome x = a b a c d xr = d c a b a LCS = a b a Minimum number of insertions = x.size()-LCS MCM DP[i][j] = min ( DP[i][k] + DP[k+1][j] + ( (i-1) k j ) ) for k in range (i,j-1) Time Complexity = O ( n ^ 3 ) //Bottom up // Function to find the most efficient way to multiply // a given sequence of matrices int matrixChainMultiplication ( vector < int > const & dims ) { int n = dims . size (); // c[i, j] = Minimum number of scalar multiplications (i.e., cost) // needed to compute matrix `M[i] M[i+1] \u2026 M[j] = M[i\u2026j]` // The cost is zero when multiplying one matrix int c [ n + 1 ][ n + 1 ]; for ( int i = 1 ; i <= n ; i ++ ) { c [ i ][ i ] = 0 ; } for ( int len = 2 ; len <= n ; len ++ ) // subsequence lengths { for ( int i = 1 ; i <= n - len + 1 ; i ++ ) { int j = i + len - 1 ; c [ i ][ j ] = INT_MAX ; for ( int k = i ; j < n && k <= j - 1 ; k ++ ) { int cost = c [ i ][ k ] + c [ k + 1 ][ j ] + dims [ i - 1 ] * dims [ k ] * dims [ j ]; if ( cost < c [ i ][ j ]) { c [ i ][ j ] = cost ; } } } } return c [ 1 ][ n - 1 ]; } Longest Increasing Subsequence Palindromic partition Boolean paranthesization (very difficult) https://leetcode.com/discuss/general-discussion/1279635/boolean-parenthesization-easy-c Egg dropping Scrambled String Burst Balloon Buy Sell stock with max K transactions https://www.youtube.com/watch?v=oDhu5uGq_ic&t=935s","title":"Dynamic Programming"},{"location":"CompCoding/Hard/dp/#62-unique-paths-simple-dp","text":"There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. class Solution { public : int uniquePaths ( int m , int n ) { vector < vector < long long int >> matrix ( m , vector < long long int > ( n , 1 )); for ( int row = m -2 ; row >= 0 ; row -- ) { for ( int col = n -2 ; col >= 0 ; col -- ) { matrix [ row ][ col ] = matrix [ row ][ col + 1 ] + matrix [ row + 1 ][ col ]; } } return matrix [ 0 ][ 0 ]; } };","title":"62. Unique Paths (Simple DP)"},{"location":"CompCoding/Hard/dp/#0-1-knapsack","text":"Problem Statement: Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. In other words, given two integer arrays val[0..n-1] and wt[0..n-1] which represent values and weights associated with n items respectively. Also given an integer W which represents knapsack capacity, find out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to W. You cannot break an item, either pick the complete item or don\u2019t pick it (0-1 property). Solution: Optimal Sub-structure: To consider all subsets of items, there can be two cases for every item. Case 1: The item is included in the optimal subset. Case 2: The item is not included in the optimal set. Therefore, the maximum value that can be obtained from \u2018n\u2019 items is the max of the following two values. 1. Maximum value obtained by n-1 items and W weight (excluding nth item). 2. Value of nth item plus maximum value obtained by n-1 items and W minus the weight of the nth item (including nth item). #include <bits/stdc++.h> using namespace std ; int knapSack ( int W , int wt [], int val [], int n ) { // making and initializing dp array int dp [ W + 1 ]; memset ( dp , 0 , sizeof ( dp )); for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int w = W ; w >= 0 ; w -- ) { if ( wt [ i - 1 ] <= w ) // finding the maximum value dp [ w ] = max ( dp [ w ], dp [ w - wt [ i - 1 ]] + val [ i - 1 ]); } } return dp [ W ]; // returning the maximum value of knapsack } int main () { int val [] = { 60 , 100 , 120 }; int wt [] = { 10 , 20 , 30 }; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ]); cout << knapSack ( W , wt , val , n ); return 0 ; }","title":"0-1 Knapsack"},{"location":"CompCoding/Hard/dp/#subset-sum-problem","text":"Problem: Given a set of non-negative integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum. Solution: Similar to knapsack. Create a DP array of sum and elements. Return true if 1. Subset sum is possible without current element or 2. [Subset sum - current element] is possible with n-1 elements. DP[ind][sum]; DP[i][j] = DP[i-1][sum] if( sum-input[i] >= 0 ) DP[i][j] = DP[i][j] || DP[i-1][sum-input[i]] //Bottom up DP solution","title":"Subset Sum Problem"},{"location":"CompCoding/Hard/dp/#equal-sum-partition","text":"Use above subset sum problem and find if there exists any subset with target sum = Total sum / 2","title":"Equal sum partition"},{"location":"CompCoding/Hard/dp/#count-of-subsets-with-sum","text":"In subset sum problem, instead of keeping bool, keep count of subsets with given sum and replace or with +.","title":"Count of subsets with Sum"},{"location":"CompCoding/Hard/dp/#minimum-subset-sum-difference","text":"Min subset sum difference could be 0 i.e. similar to equal sum partition. In equal sum partition, we were returning true or false from last block i.e. dp[i][j] where i=size of input, j=target sum Here, we will return maximum sum (i.e. i) for which dp[i][sum] (last column) is true.","title":"Minimum subset sum difference"},{"location":"CompCoding/Hard/dp/#count-subsets-with-given-sum-difference","text":"Here we need to count subsets with sum = ( Total sum - diff ) / 2 How to come up with above formula? Lets say we partition set with 1 subset sum=X and other subset sum =Y X+Y=TotalSum -> Y = TotalSum-X or X = TotalSum-Y | X-Y | = diff X = diff + Y X = diff + TotalSum - X TotalSum - Y = diff + Y 2 * X = diff + TotalSum TotalSum - diff = 2 * Y X = (diff + TotalSum) / 2 Y = ( TotalSum - diff) / 2 You can use any of the formula.","title":"Count subsets with given sum difference"},{"location":"CompCoding/Hard/dp/#target-sum-problem","text":"You are given an array of positive integers. You need to find number of ways by which you can make total sum of that array as given number. You are allowed to assign + or - sign to each element. This is same as Count subsets with given sum difference. But it is difficult to identify.","title":"Target Sum Problem"},{"location":"CompCoding/Hard/dp/#unbounded-knapsack","text":"Same item can be taken multiple times. DP [ i ] [ j ] = max ( DP[ i-1 ] [ j ] , DP [ i ] [ j - weight [ i ] ] );","title":"Unbounded Knapsack"},{"location":"CompCoding/Hard/dp/#rod-cutting-problem","text":"There are 2^length-1 options to cut rod. We can either cut or not cut between i , i + 1 for i=1,7 in following case. So 2^7 options. There is an optimal substructure property. If we know answer for length smaller than n then we can use that value in calculation for length n. 1 2 3 4 5 6 7 8 cutRod(n) = max(price[i] + cutRod(n-i-1)) for all i in {0, 1 .. n-1}","title":"Rod Cutting Problem"},{"location":"CompCoding/Hard/dp/#coin-change-combination-sum","text":"Given the target value N and array of allowed numbers, count number of way to write N as sum of those numbers. Here only sum matters. How we are using those coins does not matter. 1+1+2 here we have already used 1s and then used 2 2+1+1 here we have used 2 first and then used 1 which is also allowed. E.g. nums = [1,2,3] N=4 1+1+1+1, 1+1+2, 1+2+1, 1+3, 2+1+1, 2+2, 3+1 -> total 7 Note that 1+1+2 and 1+2+1 are counted as different way. //top down dp [ 0 ] = 1 ; for i in 1. . N : for x in nums : dp [ i ] += dp [ i - x ] //bottom up dp [ 0 ] = 1 ; for i in 1. . N : for x in nums : dp [ i + x ] += dp [ i ]","title":"Coin Change (Combination Sum)"},{"location":"CompCoding/Hard/dp/#coin-change-min","text":"You are given denominations of coins and the target amount N. What is the minimum possible number of coins used. E.g.1: nums=[1,2,5] N=11 5+5+1 -> 3 coins E.g.2: nums=[1,3,4] N=6 3+3 -> 2 coins dp [ 0 ] = 0 ; dp [ 1. . N ] = INF for i in 1. . N : for x in nums : dp [ i ] = min ( dp [ i ], dp [ i - x ] + 1 )","title":"Coin Change (min)"},{"location":"CompCoding/Hard/dp/#coin-change-ways","text":"You are given denomination of coins and the target amount N. What is the number of ways to make up amount N ? E.g. nums=[1,2,5] N=5 5, 1+2+2, 1+1+1+2, 1+1+1+1+1 -> 4 Ways Note that order does not matter here. Here not only sum matters, here sum,coins used till now both matters. This is unbounded knapsack. Here last used coin matters. Since you want to avoid counting 1+2+2 and 2+1+2 differently. You can consider only ascending order ways. Think of it this way: Currently we have 1,2,5 coins. Let's first find no of ways using only 1, then find no of ways using 1,2, etc. dp[amount][coin_i] = dp[ amount-value[coin_i] ][coin_i] + dp[amount][coin_i-1] include coin_i don't include coin_i, so same amount using coin_i-1 coins Form a 2d dp table.","title":"Coin change (ways)"},{"location":"CompCoding/Hard/dp/#longest-common-subsequence","text":"C(i,j) = LCS[ text1(1..i), text2(1..j) ] LCS(text1,text2) = C(m,n) m=length of text1, n=length of text2 C(i,j) = if text1[i] == text2[j] -> C(i-1,j-1) = else max( C(i-1,j), C(i,j-1) ) int longestCommonSubsequence ( string text1 , string text2 ) { short dp [ 1001 ][ 1001 ]; for ( int i = 0 ; i <= text1 . size (); i ++ ) { dp [ i ][ 0 ] = 0 ; } for ( int j = 0 ; j <= text1 . size (); j ++ ) { dp [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i <= text1 . size (); i ++ ) { for ( int j = 1 ; j <= text2 . size (); j ++ ) { //LCS[x,y] = 1 + LCS(x-1,y-1) if equal // else max(LCS(x-1,y), LCS(x,y-1)) dp [ i ][ j ] = text1 [ i -1 ] == text2 [ j -1 ] ? 1 + dp [ i -1 ][ j -1 ] : max ( dp [ i -1 ][ j ], dp [ i ][ j -1 ]); } } return dp [ text1 . size ()][ text2 . size ()]; } //Function to print lcs // Recursive function to find the longest common subsequence of // string `X[0\u2026m-1]` and `Y[0\u2026n-1]` string LCS ( string X , string Y , int m , int n , auto & dp ) { // return an empty string if the end of either sequence is reached if ( m == 0 || n == 0 ) { return string ( \"\" ); } // if the last character of `X` and `Y` matches if ( X [ m - 1 ] == Y [ n - 1 ]) { // append current character (`X[m-1]` or `Y[n-1]`) to LCS of // substring `X[0\u2026m-2]` and `Y[0\u2026n-2]` return LCS ( X , Y , m - 1 , n - 1 , dp ) + X [ m - 1 ]; } // otherwise, if the last character of `X` and `Y` are different // if a top cell of the current cell has more value than the left // cell, then drop the current character of string `X` and find LCS // of substring `X[0\u2026m-2]`, `Y[0\u2026n-1]` if ( dp [ m - 1 ][ n ] > dp [ m ][ n - 1 ]) { return LCS ( X , Y , m - 1 , n , dp ); } else { // if a left cell of the current cell has more value than the top // cell, then drop the current character of string `Y` and find LCS // of substring `X[0\u2026m-1]`, `Y[0\u2026n-2]` return LCS ( X , Y , m , n - 1 , dp ); } }","title":"Longest Common Subsequence"},{"location":"CompCoding/Hard/dp/#longest-common-substring","text":"dp[i][j] represents longest common substring ending at str1[i], str2[j] int LCStr ( string str1 , string str2 , int N , int M ) { int dp [ N + 1 ][ M + 1 ]; int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { if ( i == 0 || j == 0 ){ dp [ i ][ j ] = 0 ; } else if ( str1 [ i - 1 ] == str2 [ j - 1 ]) { dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 ; ans = max ( ans , dp [ i ][ j ]); } else dp [ i ][ j ] = 0 ; } } return ans ; }","title":"Longest Common Substring"},{"location":"CompCoding/Hard/dp/#shortest-supersequence","text":"Subsequence: Here x is a subsequence of y. Order matters but need not be contiguous. x : a b c d y : a x y b z p c q r d Substring: Here x is substring of y. Complete string shouuld be part of parent string. x : a b c d y : p q r a b c d s t Minimum length string containing both strings X and Y as subsequence. Shortest supersequence length = x.size() + y.size() - 2 * LCS(x,y)","title":"Shortest supersequence"},{"location":"CompCoding/Hard/dp/#minuimum-number-of-insertions-and-deletions-to-convert-string-a-to-string-b","text":"ans = b.size() - LCS(a,b)","title":"Minuimum number of insertions and deletions to convert string a to string b"},{"location":"CompCoding/Hard/dp/#longest-palindromic-subsequence","text":"xr = reverse(x.begin(), x.end()); LPS = LCS(x, xr);","title":"Longest palindromic subsequence"},{"location":"CompCoding/Hard/dp/#minimum-number-of-deletions-to-make-it-palindrome","text":"ans = x.size() - LPS","title":"Minimum number of deletions to make it palindrome"},{"location":"CompCoding/Hard/dp/#longest-repeating-subsequence","text":"A A B E B C D D A B D LCS but with additional condition int longestCommonSubsequence(string text1) { string text2 = text1; short dp[1001][1001]; for(int i=0; i<= text1.size(); i++) { dp[i][0] = 0; } for(int j=0; j<= text1.size(); j++) { dp[0][j] = 0; } for(int i=1; i<=text1.size(); i++) { for(int j=1; j<=text2.size(); j++) { //LCS[x,y] = 1 + LCS(x-1,y-1) if equal // else max(LCS(x-1,y), LCS(x,y-1)) //(i!=j) condition to make sure that same position characters are not matched dp[i][j] = text1[i-1] == text2[j-1] && (i!=j) ? 1+dp[i-1][j-1] : max(dp[i-1][j],dp[i][j-1]); } } return dp[text1.size()][text2.size()]; }","title":"Longest Repeating Subsequence"},{"location":"CompCoding/Hard/dp/#minimum-number-of-insertions-to-make-it-palindrome","text":"x = a b a c d xr = d c a b a LCS = a b a Minimum number of insertions = x.size()-LCS","title":"Minimum number of insertions to make it palindrome"},{"location":"CompCoding/Hard/dp/#mcm","text":"DP[i][j] = min ( DP[i][k] + DP[k+1][j] + ( (i-1) k j ) ) for k in range (i,j-1) Time Complexity = O ( n ^ 3 ) //Bottom up // Function to find the most efficient way to multiply // a given sequence of matrices int matrixChainMultiplication ( vector < int > const & dims ) { int n = dims . size (); // c[i, j] = Minimum number of scalar multiplications (i.e., cost) // needed to compute matrix `M[i] M[i+1] \u2026 M[j] = M[i\u2026j]` // The cost is zero when multiplying one matrix int c [ n + 1 ][ n + 1 ]; for ( int i = 1 ; i <= n ; i ++ ) { c [ i ][ i ] = 0 ; } for ( int len = 2 ; len <= n ; len ++ ) // subsequence lengths { for ( int i = 1 ; i <= n - len + 1 ; i ++ ) { int j = i + len - 1 ; c [ i ][ j ] = INT_MAX ; for ( int k = i ; j < n && k <= j - 1 ; k ++ ) { int cost = c [ i ][ k ] + c [ k + 1 ][ j ] + dims [ i - 1 ] * dims [ k ] * dims [ j ]; if ( cost < c [ i ][ j ]) { c [ i ][ j ] = cost ; } } } } return c [ 1 ][ n - 1 ]; }","title":"MCM"},{"location":"CompCoding/Hard/dp/#longest-increasing-subsequence","text":"","title":"Longest Increasing Subsequence"},{"location":"CompCoding/Hard/dp/#palindromic-partition","text":"","title":"Palindromic partition"},{"location":"CompCoding/Hard/dp/#boolean-paranthesization-very-difficult","text":"https://leetcode.com/discuss/general-discussion/1279635/boolean-parenthesization-easy-c","title":"Boolean paranthesization  (very difficult)"},{"location":"CompCoding/Hard/dp/#egg-dropping","text":"","title":"Egg dropping"},{"location":"CompCoding/Hard/dp/#scrambled-string","text":"","title":"Scrambled String"},{"location":"CompCoding/Hard/dp/#burst-balloon","text":"","title":"Burst Balloon"},{"location":"CompCoding/Hard/dp/#buy-sell-stock-with-max-k-transactions","text":"https://www.youtube.com/watch?v=oDhu5uGq_ic&t=935s","title":"Buy Sell stock with max K transactions"},{"location":"CompCoding/Hard/graph/","text":"BFS class Solution { public : vector < int > bfsOfGraph ( int V , vector < int > adj []){ vector < int > bfs ; vector < int > vis ( V , 0 ); queue < int > q ; q . push ( 0 ); vis [ 0 ] = 1 ; while ( ! q . empty ()) { int node = q . front (); q . pop (); bfs . push_back ( node ); for ( auto it : adj [ node ]) { if ( ! vis [ it ]) { q . push ( it ); vis [ it ] = 1 ; } } } return bfs ; } }; DFS class Solution { void dfs ( int node , vector < int > & vis , vector < int > adj [], vector < int > & storeDfs ) { storeDfs . push_back ( node ); //Storing to print output later vis [ node ] = 1 ; for ( auto it : adj [ node ]) { if ( ! vis [ it ]) { dfs ( it , vis , adj , storeDfs ); } } } public : //DFS of all disconnected graphs vector < int > dfsOfGraph ( int V , vector < int > adj []){ vector < int > storeDfs ; vector < int > vis ( V + 1 , 0 ); for ( int i = 1 ; i <= V ; i ++ ) { if ( ! vis [ i ]) dfs ( i , vis , adj , storeDfs ); } return storeDfs ; } }; Cycle detection in Undirected Graph using BFS Do BFS traversal while maintaining parent in queue. If any node is already visited which is not parent, then there is a cycle. class Solution { public : bool checkForCycle ( int s , int V , vector < int > adj [], vector < int >& visited ) { // Create a queue for BFS queue < pair < int , int >> q ; //pair<node,parent> visited [ s ] = true ; q . push ({ s , -1 }); while ( ! q . empty ()) { int node = q . front (). first ; int par = q . front (). second ; q . pop (); for ( auto it : adj [ node ]) { if ( ! visited [ it ]) { visited [ it ] = true ; q . push ({ it , node }); } else if ( par != it ) //Important logic for cycle detection return true ; } } return false ; } public : bool isCycle ( int V , vector < int > adj []){ vector < int > vis ( V , 0 ); //Traverse disconnected components for ( int i = 0 ; i < V ; i ++ ) { if ( ! vis [ i ]) { if ( checkForCycle ( i , V , adj , vis )) return true ; } } return false ; } }; Cycle Detection in Undirected Graph using DFS Cycle present, If any node other than previous node is already visited. class Solution { public : bool checkForCycle ( int node , int parent , vector < int > & vis , vector < int > adj []) { vis [ node ] = 1 ; for ( auto it : adj [ node ]) { if ( ! vis [ it ]) { if ( checkForCycle ( it , node , vis , adj )) return true ; } else if ( it != parent ) //Important logic for cycle logic return true ; } return false ; } public : bool isCycle ( int V , vector < int > adj []){ vector < int > vis ( V + 1 , 0 ); for ( int i = 0 ; i < V ; i ++ ) { if ( ! vis [ i ]) { if ( checkForCycle ( i , -1 , vis , adj )) return true ; } } return false ; } }; Bipartite Graph (BFS) | Graph Coloring Graph that can be colored using 2 colors such that there are no 2 adjacent nodes with same color. Observation : No odd length cycle = Bipartite Graph Implementation : BFS Traversal with color array instead of visited array bool bipartiteBfs ( int src , vector < int > adj [], int color []) { queue < int > q ; q . push ( src ); color [ src ] = 1 ; while ( ! q . empty ()) { int node = q . front (); q . pop (); for ( auto it : adj [ node ]) { if ( color [ it ] == -1 ) { color [ it ] = 1 - color [ node ]; q . push ( it ); } else if ( color [ it ] == color [ node ]) { // If already colored(visited) and has same color then return false return false ; } } } return true ; } bool checkBipartite ( vector < int > adj [], int n ) { int color [ n ]; memset ( color , -1 , sizeof color ); for ( int i = 0 ; i < n ; i ++ ) { if ( color [ i ] == -1 ) { if ( ! bipartiteBfs ( i , adj , color )) { return false ; } } } return true ; } Bipartite Graph (DFS) | Graph Coloring DFS while maintaining color array instead of visited array. bool bipartiteDfs ( int node , vector < int > adj [], int color []) { for ( auto it : adj [ node ]) { if ( color [ it ] == -1 ) { color [ it ] = 1 - color [ node ]; if ( ! bipartiteDfs ( it , adj , color )) { return false ; } } // If already colored and has same color then return false else if ( color [ it ] == color [ node ]) return false ; } return true ; } bool checkBipartite ( vector < int > adj [], int n ) { int color [ n ]; memset ( color , -1 , sizeof color ); for ( int i = 0 ; i < n ; i ++ ) { if ( color [ i ] == -1 ) { color [ i ] = 1 ; if ( ! bipartiteDfs ( i , adj , color )) { return false ; } } } return true ; } Cycle Detection in Directed Graph using DFS Keep 2 arrays vis : maintain overall visited for disconnected components dfsVis : visited in current dfs. (Backtrack while returning) If adjacent node is present in dfsVis then cycle is present. class Solution { private : bool checkCycle ( int node , vector < int > adj [], int vis [], int dfsVis []) { vis [ node ] = 1 ; dfsVis [ node ] = 1 ; for ( auto it : adj [ node ]) { if ( ! vis [ it ]) { if ( checkCycle ( it , adj , vis , dfsVis )) return true ; } else if ( dfsVis [ it ]) { return true ; } } dfsVis [ node ] = 0 ; return false ; } public : bool isCyclic ( int N , vector < int > adj []) { int vis [ N ], dfsVis [ N ]; memset ( vis , 0 , sizeof vis ); memset ( dfsVis , 0 , sizeof dfsVis ); for ( int i = 0 ; i < N ; i ++ ) { if ( ! vis [ i ]) { // cout << i << endl; if ( checkCycle ( i , adj , vis , dfsVis )) { return true ; } } } return false ; } }; Topological sort (DFS) Topological sort: Linear ordering of vertices such that if there is an edge u->v, u appears before v in that ordering. DFS with auxilliary stack to maintain toposort. Add node to auxilliary stack on completion of dfs call of each node. This way last node will be added to stack first. Popping nodes from stack will give topo sort. class Solution { void findTopoSort ( int node , vector < int > & vis , stack < int > & st , vector < int > adj []) { vis [ node ] = 1 ; for ( auto it : adj [ node ]) { if ( ! vis [ it ]) { findTopoSort ( it , vis , st , adj ); } } st . push ( node ); } public : vector < int > topoSort ( int N , vector < int > adj []) { stack < int > st ; vector < int > vis ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { if ( vis [ i ] == 0 ) { findTopoSort ( i , vis , st , adj ); } } vector < int > topo ; while ( ! st . empty ()) { topo . push_back ( st . top ()); st . pop (); } return topo ; } }; Topological Sort (BFS) | Kahn's Algorithm Setup: Create an indegree vector. Add nodes with indegree 0 to queue. Loop: Pop front element from queue, and do BFS and decrement indegree on visiting. If indegree becomes 0, add it to queue. class Solution { public : vector < int > topo ( int N , vector < int > adj []) { queue < int > q ; //create and update indegree vector vector < int > indegree ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { for ( auto it : adj [ i ]) { indegree [ it ] ++ ; } } //Add nodes with indegree 0 to queue for ( int i = 0 ; i < N ; i ++ ) { if ( indegree [ i ] == 0 ) { q . push ( i ); } } vector < int > topo ; while ( ! q . empty ()) { int node = q . front (); q . pop (); topo . push_back ( node ); //update toposort on popping node from queue for ( auto it : adj [ node ]) { indegree [ it ] -- ; if ( indegree [ it ] == 0 ) { q . push ( it ); } } } return topo ; } }; Cycle Detection in Directed Graph using BFS(Kahn's Algorithm) Observation: Topological sort is not possible with cyclic graph. Algo: Try to generate topological sort with above Kahn's algorithm. If successful, then no cycle. class Solution { public : bool isCyclic ( int N , vector < int > adj []) { queue < int > q ; vector < int > indegree ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { for ( auto it : adj [ i ]) { indegree [ it ] ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( indegree [ i ] == 0 ) { q . push ( i ); } } int cnt = 0 ; //Counter while ( ! q . empty ()) { int node = q . front (); q . pop (); cnt ++ ; for ( auto it : adj [ node ]) { indegree [ it ] -- ; if ( indegree [ it ] == 0 ) { q . push ( it ); } } } if ( cnt == N ) return false ; //Cycle check return true ; } }; Shortest Path in Undirected Graph with Unit Weights Initialise distance vector with INT_MAX. Basically a BFS but add to queue only if current node distance + 1 is less that distance in distance vector i.e. if(dist[node] + 1 < dist[it]). void BFS ( vector < int > adj [], int N , int src ) { int dist [ N ]; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INT_MAX ; queue < int > q ; dist [ src ] = 0 ; q . push ( src ); while ( q . empty () == false ) { int node = q . front (); q . pop (); for ( auto it : adj [ node ]){ if ( dist [ node ] + 1 < dist [ it ]){ dist [ it ] = dist [ node ] + 1 ; q . push ( it ); } } } for ( int i = 0 ; i < N ; i ++ ) cout << dist [ i ] << \" \" ; } Shortest Path in weighted Directed Acyclic Graph (DAG) Get the topo sort. Initialize distance vector with INT_MAX. Keep updating distance vector if distance cost is less than dist[node] for each node in topo sort. void findTopoSort ( int node , int vis [], stack < int > & st , vector < pair < int , int >> adj []) { vis [ node ] = 1 ; for ( auto it : adj [ node ]) { if ( ! vis [ it . first ]) { findTopoSort ( it . first , vis , st , adj ); } } st . push ( node ); } void shortestPath ( int src , int N , vector < pair < int , int >> adj []) { int vis [ N ] = { 0 }; stack < int > st ; for ( int i = 0 ; i < N ; i ++ ) if ( ! vis [ i ]) findTopoSort ( i , vis , st , adj ); int dist [ N ]; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = 1e9 ; dist [ src ] = 0 ; while ( ! st . empty ()) { int node = st . top (); st . pop (); if ( dist [ node ] != INF ) { for ( auto it : adj [ node ]) { if ( dist [ node ] + it . second < dist [ it . first ]) { dist [ it . first ] = dist [ node ] + it . second ; } } } } for ( int i = 0 ; i < N ; i ++ ) ( dist [ i ] == 1e9 ) ? cout << \"INF \" : cout << dist [ i ] << \" \" ; } Dijkstra's Algorithm | Shortest Path in Undirected Graphs Initialize distance vector with INT_MAX. Add source node to priority_queue(min heap) of i.e. <0,source> Update distance vector for all adjacent nodes of front popped node from queue. On updating distance vector (if shorter distance), add to queue. Note that this does not work for negative edge weights. Time Complexity = O( ( V + E ) lgV ) priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > pq ; // min-heap ; In pair => ( dist , node ) i . e . dist required to reach node from source vector < int > distTo ( n + 1 , INT_MAX ); // 1-indexed array for calculating shortest paths; distTo [ source ] = 0 ; pq . push ( make_pair ( 0 , source )); // (dist,from) while ( ! pq . empty () ){ int dist = pq . top (). first ; int prev = pq . top (). second ; pq . pop (); vector < pair < int , int > >:: iterator it ; for ( it = g [ prev ]. begin () ; it != g [ prev ]. end () ; it ++ ){ int next = it -> first ; int nextDist = it -> second ; if ( distTo [ next ] > distTo [ prev ] + nextDist ){ distTo [ next ] = distTo [ prev ] + nextDist ; pq . push ( make_pair ( distTo [ next ], next )); } } } Minimum Spanning Tree Minimum spanning tree is the spanning tree where the cost is minimum among all the spanning trees. There also can be many minimum spanning trees. The cost of the spanning tree is the sum of the weights of all the edges in the tree. There can be many spanning trees. Prims Algorithm | Minimum Spanning Tree Start with single node. Pick up edges with minimum weight and expand tree. Keep on doing this until you get N nodes and N-1 edges. Maintain 3 arrays. Key: Maintains weight to reach node MST: Indicates that node is included in MST Parent: Output (To form MST graph at the end) int parent [ N ]; int key [ N ]; //index i represents node i, value key[i] represents distance to node i from mst bool mstSet [ N ]; for ( int i = 0 ; i < N ; i ++ ) key [ i ] = INT_MAX , mstSet [ i ] = false ; key [ 0 ] = 0 ; parent [ 0 ] = -1 ; int ansWeight = 0 ; for ( int count = 0 ; count < N - 1 ; count ++ ) { int mini = INT_MAX , u ; for ( int v = 0 ; v < N ; v ++ ) if ( mstSet [ v ] == false && key [ v ] < mini ) mini = key [ v ], u = v ; mstSet [ u ] = true ; for ( auto it : adj [ u ]) { int v = it . first ; int weight = it . second ; if ( mstSet [ v ] == false && weight < key [ v ]) parent [ v ] = u , key [ v ] = weight ; } } Disjoint set and Union, Path Compression Kruskal's algorithm for MST Sort based on edge weights and add nodes connected to least weight edge if parent of nodes of that edge are different i.e. node is not already included in mst. struct node { int u ; int v ; int wt ; node ( int first , int second , int weight ) { u = first ; v = second ; wt = weight ; } }; bool comp ( node a , node b ) { return a . wt < b . wt ; } int findPar ( int u , vector < int > & parent ) { if ( u == parent [ u ]) return u ; return parent [ u ] = findPar ( parent [ u ], parent ); } void unionn ( int u , int v , vector < int > & parent , vector < int > & rank ) { u = findPar ( u , parent ); v = findPar ( v , parent ); if ( rank [ u ] < rank [ v ]) { parent [ u ] = v ; } else if ( rank [ v ] < rank [ u ]) { parent [ v ] = u ; } else { parent [ v ] = u ; rank [ u ] ++ ; } } int main (){ int N , m ; cin >> N >> m ; vector < node > edges ; for ( int i = 0 ; i < m ; i ++ ) { int u , v , wt ; cin >> u >> v >> wt ; edges . push_back ( node ( u , v , wt )); } sort ( edges . begin (), edges . end (), comp ); vector < int > parent ( N ); for ( int i = 0 ; i < N ; i ++ ) parent [ i ] = i ; vector < int > rank ( N , 0 ); int cost = 0 ; vector < pair < int , int >> mst ; for ( auto it : edges ) { if ( findPar ( it . v , parent ) != findPar ( it . u , parent )) { cost += it . wt ; mst . push_back ({ it . u , it . v }); unionn ( it . u , it . v , parent , rank ); } } cout << cost << endl ; for ( auto it : mst ) cout << it . first << \" - \" << it . second << endl ; return 0 ; } Kosaraju's Algorithm (Strongly connected components) toposort and traverse from end. In above diagram, toposort could be : 1,2,3,4,5,6,7 DFS from from end would result in giving strongly connected components as there is no reverse edge from 1 scc to other scc. DFS from 7 can only traverse 7,6,5. But can't go to 4 as there is no edge from that scc to other scc. Bellman Ford (shortest path algorithm) Relax all edges n-1 times. Relaxation -> update dist[v] if dist[u]+weight(u,v) < dist[v] Works with negative edge weights struct node { int u ; int v ; int wt ; node ( int first , int second , int weight ) { u = first ; v = second ; wt = weight ; } }; int main (){ int N , m ; cin >> N >> m ; vector < node > edges ; for ( int i = 0 ; i < m ; i ++ ) { int u , v , wt ; cin >> u >> v >> wt ; edges . push_back ( node ( u , v , wt )); } int src ; cin >> src ; int inf = 10000000 ; vector < int > dist ( N , inf ); //maintains shortest distance from source dist [ src ] = 0 ; for ( int i = 1 ; i <= N -1 ; i ++ ) { for ( auto it : edges ) { if ( dist [ it . u ] + it . wt < dist [ it . v ]) { dist [ it . v ] = dist [ it . u ] + it . wt ; } } } int fl = 0 ; for ( auto it : edges ) { if ( dist [ it . u ] + it . wt < dist [ it . v ]) { cout << \"Negative Cycle\" ; fl = 1 ; break ; } } if ( ! fl ) { for ( int i = 0 ; i < N ; i ++ ) { cout << i << \" \" << dist [ i ] << endl ; } } return 0 ; } Floyd Warshall Algorithm (All pairs shortest path) This is a dp problem K is node allowed to be included in path for k in 1 , n { ( update 2 d DP ) } 2d DP: dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) Time complexity : O(n^3) // Number of vertices in the graph #define V 4 // Solves the all-pairs shortest path // problem using Floyd Warshall algorithm void floydWarshall ( int graph [][ V ]) { /* dist[][] will be the output matrix that will finally have the shortest distances between every pair of vertices */ int dist [ V ][ V ], i , j , k ; /* Initialize the solution matrix same as input graph matrix. Or we can say the initial values of shortest distances are based on shortest paths considering no intermediate vertex. */ for ( i = 0 ; i < V ; i ++ ) for ( j = 0 ; j < V ; j ++ ) dist [ i ][ j ] = graph [ i ][ j ]; /* Add all vertices one by one to the set of intermediate vertices. ---> Before start of an iteration, we have shortest distances between all pairs of vertices such that the shortest distances consider only the vertices in set {0, 1, 2, .. k-1} as intermediate vertices. ----> After the end of an iteration, vertex no. k is added to the set of intermediate vertices and the set becomes {0, 1, 2, .. k} */ for ( k = 0 ; k < V ; k ++ ) { // Pick all vertices as source one by one for ( i = 0 ; i < V ; i ++ ) { // Pick all vertices as destination for the // above picked source for ( j = 0 ; j < V ; j ++ ) { // If vertex k is on the shortest path from // i to j, then update the value of // dist[i][j] if ( dist [ i ][ j ] > ( dist [ i ][ k ] + dist [ k ][ j ]) && ( dist [ k ][ j ] != INF && dist [ i ][ k ] != INF )) dist [ i ][ j ] = dist [ i ][ k ] + dist [ k ][ j ]; } } } }","title":"Graph Traversal"},{"location":"CompCoding/Hard/graph/#bfs","text":"class Solution { public : vector < int > bfsOfGraph ( int V , vector < int > adj []){ vector < int > bfs ; vector < int > vis ( V , 0 ); queue < int > q ; q . push ( 0 ); vis [ 0 ] = 1 ; while ( ! q . empty ()) { int node = q . front (); q . pop (); bfs . push_back ( node ); for ( auto it : adj [ node ]) { if ( ! vis [ it ]) { q . push ( it ); vis [ it ] = 1 ; } } } return bfs ; } };","title":"BFS"},{"location":"CompCoding/Hard/graph/#dfs","text":"class Solution { void dfs ( int node , vector < int > & vis , vector < int > adj [], vector < int > & storeDfs ) { storeDfs . push_back ( node ); //Storing to print output later vis [ node ] = 1 ; for ( auto it : adj [ node ]) { if ( ! vis [ it ]) { dfs ( it , vis , adj , storeDfs ); } } } public : //DFS of all disconnected graphs vector < int > dfsOfGraph ( int V , vector < int > adj []){ vector < int > storeDfs ; vector < int > vis ( V + 1 , 0 ); for ( int i = 1 ; i <= V ; i ++ ) { if ( ! vis [ i ]) dfs ( i , vis , adj , storeDfs ); } return storeDfs ; } };","title":"DFS"},{"location":"CompCoding/Hard/graph/#cycle-detection-in-undirected-graph-using-bfs","text":"Do BFS traversal while maintaining parent in queue. If any node is already visited which is not parent, then there is a cycle. class Solution { public : bool checkForCycle ( int s , int V , vector < int > adj [], vector < int >& visited ) { // Create a queue for BFS queue < pair < int , int >> q ; //pair<node,parent> visited [ s ] = true ; q . push ({ s , -1 }); while ( ! q . empty ()) { int node = q . front (). first ; int par = q . front (). second ; q . pop (); for ( auto it : adj [ node ]) { if ( ! visited [ it ]) { visited [ it ] = true ; q . push ({ it , node }); } else if ( par != it ) //Important logic for cycle detection return true ; } } return false ; } public : bool isCycle ( int V , vector < int > adj []){ vector < int > vis ( V , 0 ); //Traverse disconnected components for ( int i = 0 ; i < V ; i ++ ) { if ( ! vis [ i ]) { if ( checkForCycle ( i , V , adj , vis )) return true ; } } return false ; } };","title":"Cycle detection in Undirected Graph using BFS"},{"location":"CompCoding/Hard/graph/#cycle-detection-in-undirected-graph-using-dfs","text":"Cycle present, If any node other than previous node is already visited. class Solution { public : bool checkForCycle ( int node , int parent , vector < int > & vis , vector < int > adj []) { vis [ node ] = 1 ; for ( auto it : adj [ node ]) { if ( ! vis [ it ]) { if ( checkForCycle ( it , node , vis , adj )) return true ; } else if ( it != parent ) //Important logic for cycle logic return true ; } return false ; } public : bool isCycle ( int V , vector < int > adj []){ vector < int > vis ( V + 1 , 0 ); for ( int i = 0 ; i < V ; i ++ ) { if ( ! vis [ i ]) { if ( checkForCycle ( i , -1 , vis , adj )) return true ; } } return false ; } };","title":"Cycle Detection in Undirected Graph using DFS"},{"location":"CompCoding/Hard/graph/#bipartite-graph-bfs-graph-coloring","text":"Graph that can be colored using 2 colors such that there are no 2 adjacent nodes with same color. Observation : No odd length cycle = Bipartite Graph Implementation : BFS Traversal with color array instead of visited array bool bipartiteBfs ( int src , vector < int > adj [], int color []) { queue < int > q ; q . push ( src ); color [ src ] = 1 ; while ( ! q . empty ()) { int node = q . front (); q . pop (); for ( auto it : adj [ node ]) { if ( color [ it ] == -1 ) { color [ it ] = 1 - color [ node ]; q . push ( it ); } else if ( color [ it ] == color [ node ]) { // If already colored(visited) and has same color then return false return false ; } } } return true ; } bool checkBipartite ( vector < int > adj [], int n ) { int color [ n ]; memset ( color , -1 , sizeof color ); for ( int i = 0 ; i < n ; i ++ ) { if ( color [ i ] == -1 ) { if ( ! bipartiteBfs ( i , adj , color )) { return false ; } } } return true ; }","title":"Bipartite Graph (BFS) | Graph Coloring"},{"location":"CompCoding/Hard/graph/#bipartite-graph-dfs-graph-coloring","text":"DFS while maintaining color array instead of visited array. bool bipartiteDfs ( int node , vector < int > adj [], int color []) { for ( auto it : adj [ node ]) { if ( color [ it ] == -1 ) { color [ it ] = 1 - color [ node ]; if ( ! bipartiteDfs ( it , adj , color )) { return false ; } } // If already colored and has same color then return false else if ( color [ it ] == color [ node ]) return false ; } return true ; } bool checkBipartite ( vector < int > adj [], int n ) { int color [ n ]; memset ( color , -1 , sizeof color ); for ( int i = 0 ; i < n ; i ++ ) { if ( color [ i ] == -1 ) { color [ i ] = 1 ; if ( ! bipartiteDfs ( i , adj , color )) { return false ; } } } return true ; }","title":"Bipartite Graph (DFS) | Graph Coloring"},{"location":"CompCoding/Hard/graph/#cycle-detection-in-directed-graph-using-dfs","text":"Keep 2 arrays vis : maintain overall visited for disconnected components dfsVis : visited in current dfs. (Backtrack while returning) If adjacent node is present in dfsVis then cycle is present. class Solution { private : bool checkCycle ( int node , vector < int > adj [], int vis [], int dfsVis []) { vis [ node ] = 1 ; dfsVis [ node ] = 1 ; for ( auto it : adj [ node ]) { if ( ! vis [ it ]) { if ( checkCycle ( it , adj , vis , dfsVis )) return true ; } else if ( dfsVis [ it ]) { return true ; } } dfsVis [ node ] = 0 ; return false ; } public : bool isCyclic ( int N , vector < int > adj []) { int vis [ N ], dfsVis [ N ]; memset ( vis , 0 , sizeof vis ); memset ( dfsVis , 0 , sizeof dfsVis ); for ( int i = 0 ; i < N ; i ++ ) { if ( ! vis [ i ]) { // cout << i << endl; if ( checkCycle ( i , adj , vis , dfsVis )) { return true ; } } } return false ; } };","title":"Cycle Detection in Directed Graph using DFS"},{"location":"CompCoding/Hard/graph/#topological-sort-dfs","text":"Topological sort: Linear ordering of vertices such that if there is an edge u->v, u appears before v in that ordering. DFS with auxilliary stack to maintain toposort. Add node to auxilliary stack on completion of dfs call of each node. This way last node will be added to stack first. Popping nodes from stack will give topo sort. class Solution { void findTopoSort ( int node , vector < int > & vis , stack < int > & st , vector < int > adj []) { vis [ node ] = 1 ; for ( auto it : adj [ node ]) { if ( ! vis [ it ]) { findTopoSort ( it , vis , st , adj ); } } st . push ( node ); } public : vector < int > topoSort ( int N , vector < int > adj []) { stack < int > st ; vector < int > vis ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { if ( vis [ i ] == 0 ) { findTopoSort ( i , vis , st , adj ); } } vector < int > topo ; while ( ! st . empty ()) { topo . push_back ( st . top ()); st . pop (); } return topo ; } };","title":"Topological sort (DFS)"},{"location":"CompCoding/Hard/graph/#topological-sort-bfs-kahns-algorithm","text":"Setup: Create an indegree vector. Add nodes with indegree 0 to queue. Loop: Pop front element from queue, and do BFS and decrement indegree on visiting. If indegree becomes 0, add it to queue. class Solution { public : vector < int > topo ( int N , vector < int > adj []) { queue < int > q ; //create and update indegree vector vector < int > indegree ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { for ( auto it : adj [ i ]) { indegree [ it ] ++ ; } } //Add nodes with indegree 0 to queue for ( int i = 0 ; i < N ; i ++ ) { if ( indegree [ i ] == 0 ) { q . push ( i ); } } vector < int > topo ; while ( ! q . empty ()) { int node = q . front (); q . pop (); topo . push_back ( node ); //update toposort on popping node from queue for ( auto it : adj [ node ]) { indegree [ it ] -- ; if ( indegree [ it ] == 0 ) { q . push ( it ); } } } return topo ; } };","title":"Topological Sort (BFS) | Kahn's Algorithm"},{"location":"CompCoding/Hard/graph/#cycle-detection-in-directed-graph-using-bfskahns-algorithm","text":"Observation: Topological sort is not possible with cyclic graph. Algo: Try to generate topological sort with above Kahn's algorithm. If successful, then no cycle. class Solution { public : bool isCyclic ( int N , vector < int > adj []) { queue < int > q ; vector < int > indegree ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { for ( auto it : adj [ i ]) { indegree [ it ] ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( indegree [ i ] == 0 ) { q . push ( i ); } } int cnt = 0 ; //Counter while ( ! q . empty ()) { int node = q . front (); q . pop (); cnt ++ ; for ( auto it : adj [ node ]) { indegree [ it ] -- ; if ( indegree [ it ] == 0 ) { q . push ( it ); } } } if ( cnt == N ) return false ; //Cycle check return true ; } };","title":"Cycle Detection in Directed Graph using BFS(Kahn's Algorithm)"},{"location":"CompCoding/Hard/graph/#shortest-path-in-undirected-graph-with-unit-weights","text":"Initialise distance vector with INT_MAX. Basically a BFS but add to queue only if current node distance + 1 is less that distance in distance vector i.e. if(dist[node] + 1 < dist[it]). void BFS ( vector < int > adj [], int N , int src ) { int dist [ N ]; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INT_MAX ; queue < int > q ; dist [ src ] = 0 ; q . push ( src ); while ( q . empty () == false ) { int node = q . front (); q . pop (); for ( auto it : adj [ node ]){ if ( dist [ node ] + 1 < dist [ it ]){ dist [ it ] = dist [ node ] + 1 ; q . push ( it ); } } } for ( int i = 0 ; i < N ; i ++ ) cout << dist [ i ] << \" \" ; }","title":"Shortest Path in Undirected Graph with Unit Weights"},{"location":"CompCoding/Hard/graph/#shortest-path-in-weighted-directed-acyclic-graph-dag","text":"Get the topo sort. Initialize distance vector with INT_MAX. Keep updating distance vector if distance cost is less than dist[node] for each node in topo sort. void findTopoSort ( int node , int vis [], stack < int > & st , vector < pair < int , int >> adj []) { vis [ node ] = 1 ; for ( auto it : adj [ node ]) { if ( ! vis [ it . first ]) { findTopoSort ( it . first , vis , st , adj ); } } st . push ( node ); } void shortestPath ( int src , int N , vector < pair < int , int >> adj []) { int vis [ N ] = { 0 }; stack < int > st ; for ( int i = 0 ; i < N ; i ++ ) if ( ! vis [ i ]) findTopoSort ( i , vis , st , adj ); int dist [ N ]; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = 1e9 ; dist [ src ] = 0 ; while ( ! st . empty ()) { int node = st . top (); st . pop (); if ( dist [ node ] != INF ) { for ( auto it : adj [ node ]) { if ( dist [ node ] + it . second < dist [ it . first ]) { dist [ it . first ] = dist [ node ] + it . second ; } } } } for ( int i = 0 ; i < N ; i ++ ) ( dist [ i ] == 1e9 ) ? cout << \"INF \" : cout << dist [ i ] << \" \" ; }","title":"Shortest Path in weighted Directed Acyclic Graph (DAG)"},{"location":"CompCoding/Hard/graph/#dijkstras-algorithm-shortest-path-in-undirected-graphs","text":"Initialize distance vector with INT_MAX. Add source node to priority_queue(min heap) of i.e. <0,source> Update distance vector for all adjacent nodes of front popped node from queue. On updating distance vector (if shorter distance), add to queue. Note that this does not work for negative edge weights. Time Complexity = O( ( V + E ) lgV ) priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > pq ; // min-heap ; In pair => ( dist , node ) i . e . dist required to reach node from source vector < int > distTo ( n + 1 , INT_MAX ); // 1-indexed array for calculating shortest paths; distTo [ source ] = 0 ; pq . push ( make_pair ( 0 , source )); // (dist,from) while ( ! pq . empty () ){ int dist = pq . top (). first ; int prev = pq . top (). second ; pq . pop (); vector < pair < int , int > >:: iterator it ; for ( it = g [ prev ]. begin () ; it != g [ prev ]. end () ; it ++ ){ int next = it -> first ; int nextDist = it -> second ; if ( distTo [ next ] > distTo [ prev ] + nextDist ){ distTo [ next ] = distTo [ prev ] + nextDist ; pq . push ( make_pair ( distTo [ next ], next )); } } }","title":"Dijkstra's Algorithm | Shortest Path in Undirected Graphs"},{"location":"CompCoding/Hard/graph/#minimum-spanning-tree","text":"Minimum spanning tree is the spanning tree where the cost is minimum among all the spanning trees. There also can be many minimum spanning trees. The cost of the spanning tree is the sum of the weights of all the edges in the tree. There can be many spanning trees.","title":"Minimum Spanning Tree"},{"location":"CompCoding/Hard/graph/#prims-algorithm-minimum-spanning-tree","text":"Start with single node. Pick up edges with minimum weight and expand tree. Keep on doing this until you get N nodes and N-1 edges. Maintain 3 arrays. Key: Maintains weight to reach node MST: Indicates that node is included in MST Parent: Output (To form MST graph at the end) int parent [ N ]; int key [ N ]; //index i represents node i, value key[i] represents distance to node i from mst bool mstSet [ N ]; for ( int i = 0 ; i < N ; i ++ ) key [ i ] = INT_MAX , mstSet [ i ] = false ; key [ 0 ] = 0 ; parent [ 0 ] = -1 ; int ansWeight = 0 ; for ( int count = 0 ; count < N - 1 ; count ++ ) { int mini = INT_MAX , u ; for ( int v = 0 ; v < N ; v ++ ) if ( mstSet [ v ] == false && key [ v ] < mini ) mini = key [ v ], u = v ; mstSet [ u ] = true ; for ( auto it : adj [ u ]) { int v = it . first ; int weight = it . second ; if ( mstSet [ v ] == false && weight < key [ v ]) parent [ v ] = u , key [ v ] = weight ; } }","title":"Prims Algorithm | Minimum Spanning Tree"},{"location":"CompCoding/Hard/graph/#disjoint-set-and-union-path-compression","text":"","title":"Disjoint set and Union, Path Compression"},{"location":"CompCoding/Hard/graph/#kruskals-algorithm-for-mst","text":"Sort based on edge weights and add nodes connected to least weight edge if parent of nodes of that edge are different i.e. node is not already included in mst. struct node { int u ; int v ; int wt ; node ( int first , int second , int weight ) { u = first ; v = second ; wt = weight ; } }; bool comp ( node a , node b ) { return a . wt < b . wt ; } int findPar ( int u , vector < int > & parent ) { if ( u == parent [ u ]) return u ; return parent [ u ] = findPar ( parent [ u ], parent ); } void unionn ( int u , int v , vector < int > & parent , vector < int > & rank ) { u = findPar ( u , parent ); v = findPar ( v , parent ); if ( rank [ u ] < rank [ v ]) { parent [ u ] = v ; } else if ( rank [ v ] < rank [ u ]) { parent [ v ] = u ; } else { parent [ v ] = u ; rank [ u ] ++ ; } } int main (){ int N , m ; cin >> N >> m ; vector < node > edges ; for ( int i = 0 ; i < m ; i ++ ) { int u , v , wt ; cin >> u >> v >> wt ; edges . push_back ( node ( u , v , wt )); } sort ( edges . begin (), edges . end (), comp ); vector < int > parent ( N ); for ( int i = 0 ; i < N ; i ++ ) parent [ i ] = i ; vector < int > rank ( N , 0 ); int cost = 0 ; vector < pair < int , int >> mst ; for ( auto it : edges ) { if ( findPar ( it . v , parent ) != findPar ( it . u , parent )) { cost += it . wt ; mst . push_back ({ it . u , it . v }); unionn ( it . u , it . v , parent , rank ); } } cout << cost << endl ; for ( auto it : mst ) cout << it . first << \" - \" << it . second << endl ; return 0 ; }","title":"Kruskal's algorithm for MST"},{"location":"CompCoding/Hard/graph/#kosarajus-algorithm-strongly-connected-components","text":"toposort and traverse from end. In above diagram, toposort could be : 1,2,3,4,5,6,7 DFS from from end would result in giving strongly connected components as there is no reverse edge from 1 scc to other scc. DFS from 7 can only traverse 7,6,5. But can't go to 4 as there is no edge from that scc to other scc.","title":"Kosaraju's Algorithm (Strongly connected components)"},{"location":"CompCoding/Hard/graph/#bellman-ford-shortest-path-algorithm","text":"Relax all edges n-1 times. Relaxation -> update dist[v] if dist[u]+weight(u,v) < dist[v] Works with negative edge weights struct node { int u ; int v ; int wt ; node ( int first , int second , int weight ) { u = first ; v = second ; wt = weight ; } }; int main (){ int N , m ; cin >> N >> m ; vector < node > edges ; for ( int i = 0 ; i < m ; i ++ ) { int u , v , wt ; cin >> u >> v >> wt ; edges . push_back ( node ( u , v , wt )); } int src ; cin >> src ; int inf = 10000000 ; vector < int > dist ( N , inf ); //maintains shortest distance from source dist [ src ] = 0 ; for ( int i = 1 ; i <= N -1 ; i ++ ) { for ( auto it : edges ) { if ( dist [ it . u ] + it . wt < dist [ it . v ]) { dist [ it . v ] = dist [ it . u ] + it . wt ; } } } int fl = 0 ; for ( auto it : edges ) { if ( dist [ it . u ] + it . wt < dist [ it . v ]) { cout << \"Negative Cycle\" ; fl = 1 ; break ; } } if ( ! fl ) { for ( int i = 0 ; i < N ; i ++ ) { cout << i << \" \" << dist [ i ] << endl ; } } return 0 ; }","title":"Bellman Ford (shortest path algorithm)"},{"location":"CompCoding/Hard/graph/#floyd-warshall-algorithm-all-pairs-shortest-path","text":"This is a dp problem K is node allowed to be included in path for k in 1 , n { ( update 2 d DP ) } 2d DP: dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) Time complexity : O(n^3) // Number of vertices in the graph #define V 4 // Solves the all-pairs shortest path // problem using Floyd Warshall algorithm void floydWarshall ( int graph [][ V ]) { /* dist[][] will be the output matrix that will finally have the shortest distances between every pair of vertices */ int dist [ V ][ V ], i , j , k ; /* Initialize the solution matrix same as input graph matrix. Or we can say the initial values of shortest distances are based on shortest paths considering no intermediate vertex. */ for ( i = 0 ; i < V ; i ++ ) for ( j = 0 ; j < V ; j ++ ) dist [ i ][ j ] = graph [ i ][ j ]; /* Add all vertices one by one to the set of intermediate vertices. ---> Before start of an iteration, we have shortest distances between all pairs of vertices such that the shortest distances consider only the vertices in set {0, 1, 2, .. k-1} as intermediate vertices. ----> After the end of an iteration, vertex no. k is added to the set of intermediate vertices and the set becomes {0, 1, 2, .. k} */ for ( k = 0 ; k < V ; k ++ ) { // Pick all vertices as source one by one for ( i = 0 ; i < V ; i ++ ) { // Pick all vertices as destination for the // above picked source for ( j = 0 ; j < V ; j ++ ) { // If vertex k is on the shortest path from // i to j, then update the value of // dist[i][j] if ( dist [ i ][ j ] > ( dist [ i ][ k ] + dist [ k ][ j ]) && ( dist [ k ][ j ] != INF && dist [ i ][ k ] != INF )) dist [ i ][ j ] = dist [ i ][ k ] + dist [ k ][ j ]; } } } }","title":"Floyd Warshall Algorithm (All pairs shortest path)"},{"location":"CompCoding/Hard/greedy/","text":"N meetings in a room Sort according to finish times. struct meeting { int start ; int end ; int pos ; }; bool comparator ( struct meeting m1 , meeting m2 ) { if ( m1 . end < m2 . end ) return true ; else if ( m1 . end > m2 . end ) return false ; else if ( m1 . pos < m2 . pos ) return true ; return false ; } void maxMeetings ( int s [], int e [], int n ) { struct meeting meet [ n ]; for ( int i = 0 ; i < n ; i ++ ) { meet [ i ]. start = s [ i ], meet [ i ]. end = e [ i ], meet [ i ]. pos = i + 1 ; } sort ( meet , meet + n , comparator ); vector < int > answer ; int limit = meet [ 0 ]. end ; answer . push_back ( meet [ 0 ]. pos ); for ( int i = 1 ; i < n ; i ++ ) { if ( meet [ i ]. start > limit ) { limit = meet [ i ]. end ; answer . push_back ( meet [ i ]. pos ); } } for ( int i = 0 ; i < answer . size (); i ++ ) { cout << answer [ i ] << \" \" ; } } Minimum coins Fractional Knapsack Job sequencing Minimum platforms","title":"Greedy"},{"location":"CompCoding/Hard/greedy/#n-meetings-in-a-room","text":"Sort according to finish times. struct meeting { int start ; int end ; int pos ; }; bool comparator ( struct meeting m1 , meeting m2 ) { if ( m1 . end < m2 . end ) return true ; else if ( m1 . end > m2 . end ) return false ; else if ( m1 . pos < m2 . pos ) return true ; return false ; } void maxMeetings ( int s [], int e [], int n ) { struct meeting meet [ n ]; for ( int i = 0 ; i < n ; i ++ ) { meet [ i ]. start = s [ i ], meet [ i ]. end = e [ i ], meet [ i ]. pos = i + 1 ; } sort ( meet , meet + n , comparator ); vector < int > answer ; int limit = meet [ 0 ]. end ; answer . push_back ( meet [ 0 ]. pos ); for ( int i = 1 ; i < n ; i ++ ) { if ( meet [ i ]. start > limit ) { limit = meet [ i ]. end ; answer . push_back ( meet [ i ]. pos ); } } for ( int i = 0 ; i < answer . size (); i ++ ) { cout << answer [ i ] << \" \" ; } }","title":"N meetings in a room"},{"location":"CompCoding/Hard/greedy/#minimum-coins","text":"","title":"Minimum coins"},{"location":"CompCoding/Hard/greedy/#fractional-knapsack","text":"","title":"Fractional Knapsack"},{"location":"CompCoding/Hard/greedy/#job-sequencing","text":"","title":"Job sequencing"},{"location":"CompCoding/Hard/greedy/#minimum-platforms","text":"","title":"Minimum platforms"},{"location":"CompCoding/Hard/list/","text":"Leetcode 206 : Reverse a linked list //my written code class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * iter = head ; ListNode * prev = nullptr ; ListNode * next = nullptr ; while ( iter ) { next = iter -> next ; iter -> next = prev ; prev = iter ; iter = next ; } return prev ; } }; Reverse Linked List II Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1->2->3->4->5->NULL, m = 2 and n = 4, return 1->4->3->2->5->NULL. Note: Given m, n satisfy the following condition: 1 \u2264 m \u2264 n \u2264 length of list. ListNode * reverseBetween ( ListNode * head , int m , int n ) { ListNode newHead ( 0 ); newHead . next = head ; ListNode * pre = & newHead , * cur = head , * next = NULL ; int i = 1 ; while ( i < n ) { if ( i ++ < m ) { pre = cur ; cur = cur -> next ; } else { next = cur -> next ; cur -> next = cur -> next -> next ; next -> next = pre -> next ; pre -> next = next ; } } return newHead . next ; } Leetcode 876: Middle of the Linked List Slow pointer and fast pointer approach. class Solution { public : ListNode * middleNode ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; Leetcode 21: merge two sorted lists Similar to merge operation of merge sort. class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { // iterative ListNode * res = new ListNode (); ListNode * temp = res ; while ( l1 != NULL && l2 != NULL ) { if ( l1 -> val < l2 -> val ) { res -> next = l1 ; res = res -> next ; l1 = l1 -> next ; } else { res -> next = l2 ; res = res -> next ; l2 = l2 -> next ; } } while ( l1 != NULL ) { res -> next = l1 ; res = res -> next ; l1 = l1 -> next ; } while ( l2 != NULL ) { res -> next = l2 ; res = res -> next ; l2 = l2 -> next ; } return temp -> next ; } }; Leetcode 19: Remove Nth Node From End of List Step1 : Move fast pointer by N nodes Step2 : Slow points to start of list, Fast points to Nth node, Keep iterating list until fast points to null. Step3 : Remove node pointed by slow. Make sure to add null checks everywhere. class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { ListNode * slow , * fast = head , * dummy , * ret ; slow = new ListNode ( 0 ); slow -> next = head ; fast = slow ; dummy = slow ; for ( int i = 0 ; i < n ; i ++ ) { fast = fast ? fast -> next : nullptr ; } while ( fast && fast -> next != nullptr ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next ? slow -> next -> next : nullptr ; ret = dummy -> next ; delete dummy ; return ret ; } }; Leetcode 2: Add Two Numbers ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int c = 0; ListNode newHead(0); ListNode *t = &newHead; while(c || l1 || l2) { c += (l1? l1->val : 0) + (l2? l2->val : 0); t->next = new ListNode(c%10); t = t->next; c /= 10; if(l1) l1 = l1->next; if(l2) l2 = l2->next; } return newHead.next; } Remove Duplicates from Sorted List Given 1->1->2, return 1->2. ListNode * deleteDuplicates ( ListNode * head ) { if ( ! head ) return head ; ListNode * t = head , * p = head -> next ; int pre = head -> val ; while ( p ) { if ( pre != p -> val ) { t -> next = p ; pre = p -> val ; t = t -> next ; } p = p -> next ; } t -> next = NULL ; return head ; } Remove Duplicates from Sorted List II Given 1->1->1->2->3, return 2->3. Use dummy node to simplify code. ListNode * deleteDuplicates ( ListNode * head ) { ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * cur = dummy ; int duplicate ; while ( cur -> next && cur -> next -> next ) { if ( cur -> next -> val == cur -> next -> next -> val ) { duplicate = cur -> next -> val ; while ( cur -> next && cur -> next -> val == duplicate ) cur -> next = cur -> next -> next ; } else cur = cur -> next ; } return dummy -> next ; } //Recursive ListNode * deleteDuplicates ( ListNode * head ) { if ( ! head ) return 0 ; if ( ! head -> next ) return head ; int val = head -> val ; ListNode * p = head -> next ; if ( p -> val != val ) { head -> next = deleteDuplicates ( p ); return head ;} else { while ( p && p -> val == val ) p = p -> next ; return deleteDuplicates ( p ); } } Check if Palindrome Linked List Find middle of linked list. Set next of middle node to null. Reverse second half. Compare. bool isPalindrome ( ListNode * head ) { if ( ! head || ! head -> next ) return true ; ListNode * slow = head , * fast = head -> next ; while ( fast && fast -> next ) { //split into two halves while the first half can be one-node longer; slow = slow -> next ; fast = fast -> next -> next ; } fast = slow -> next ; slow -> next = NULL ; ListNode newHead ( 0 ); //reverse the second half; ListNode * next = NULL , * p = fast ; while ( p ) { next = p -> next ; p -> next = newHead . next ; newHead . next = p ; p = next ; } fast = newHead . next ; //compare the two lists; while ( fast ) { if ( fast -> val != head -> val ) return false ; fast = fast -> next ; head = head -> next ; } return fast == NULL ; } 160. Intersection of Two Linked Lists /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( headA == NULL || headB == NULL ) return NULL ; ListNode * a = headA ; ListNode * b = headB ; //if a & b have different len, then we will stop the loop after second iteration while ( a != b ){ //for the end of first iteration, we just reset the pointer to the head of another linkedlist a = a == NULL ? headB : a -> next ; b = b == NULL ? headA : b -> next ; } return a ; } }; Detect cycle in linked list /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : bool hasCycle ( ListNode * head ) { if ( head == NULL || head -> next == NULL ) return false ; ListNode * fast = head ; ListNode * slow = head ; while ( fast -> next && fast -> next -> next ){ fast = fast -> next -> next ; slow = slow -> next ; if ( fast == slow ) return true ; } return false ; } }; Check if Palindromic linked list Find middle of linked list. Reverse right half. Compare from start and mid. if equal then palindromic. class Solution { public boolean isPalindrome ( ListNode head ) { if ( head == null || head . next == null ) return true ; ListNode slow = head ; ListNode fast = head ; while ( fast . next != null && fast . next . next != null ){ slow = slow . next ; fast = fast . next . next ; } slow . next = reverseList ( slow . next ); slow = slow . next ; while ( slow != null ){ if ( head . val != slow . val ) return false ; head = head . next ; slow = slow . next ; } return true ; } ListNode reverseList ( ListNode head ) { ListNode pre = null ; ListNode next = null ; while ( head != null ){ next = head . next ; head . next = pre ; pre = head ; head = next ; } return pre ; } } Reverse nodes in groups of K Focus on reversing 1 link. Do above step K times. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( head == NULL || k == 1 ) return head ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * cur = dummy , * nex = dummy , * pre = dummy ; int count = 0 ; while ( cur -> next != NULL ){ cur = cur -> next ; count ++ ; } while ( count >= k ){ cur = pre -> next ; nex = cur -> next ; for ( int i = 1 ; i < k ; i ++ ){ cur -> next = nex -> next ; nex -> next = pre -> next ; pre -> next = nex ; nex = cur -> next ; } pre = cur ; count -= k ; } return dummy -> next ; } }; Clone a Linked List with next and random pointer Naive: Create map of Replace pointers in new nodes. Optimal approach: Insert new nodes next to old nodes. Now you know where is new node for a given old node without map. /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public : Node * copyRandomList ( Node * head ) { Node * iter = head ; Node * front = head ; // First round: make copy of each node, // and link them together side-by-side in a single list. while ( iter != NULL ) { front = iter -> next ; Node * copy = new Node ( iter -> val ); iter -> next = copy ; copy -> next = front ; iter = front ; } // Second round: assign random pointers for the copy nodes. iter = head ; while ( iter != NULL ) { if ( iter -> random != NULL ) { iter -> next -> random = iter -> random -> next ; } iter = iter -> next -> next ; } // Third round: restore the original list, and extract the copy list. iter = head ; Node * pseudoHead = new Node ( 0 ); Node * copy = pseudoHead ; while ( iter != NULL ) { front = iter -> next -> next ; // extract the copy copy -> next = iter -> next ; // restore the original list iter -> next = front ; copy = copy -> next ; iter = front ; } return pseudoHead -> next ; } }; Leetcode 61: Rotate List Given the head of a linked list, rotate the list to the right by k places. Solution: Get size of linked list and do % k operation. This will save rotation by size of list. To rotate by K, keep fast pointer ahead by size-K and point it to null. Point dummy->next to next of fast. Point end of list to start of list.","title":"Linked List"},{"location":"CompCoding/Hard/list/#leetcode-206-reverse-a-linked-list","text":"//my written code class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * iter = head ; ListNode * prev = nullptr ; ListNode * next = nullptr ; while ( iter ) { next = iter -> next ; iter -> next = prev ; prev = iter ; iter = next ; } return prev ; } };","title":"Leetcode 206 : Reverse a linked list"},{"location":"CompCoding/Hard/list/#reverse-linked-list-ii","text":"Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1->2->3->4->5->NULL, m = 2 and n = 4, return 1->4->3->2->5->NULL. Note: Given m, n satisfy the following condition: 1 \u2264 m \u2264 n \u2264 length of list. ListNode * reverseBetween ( ListNode * head , int m , int n ) { ListNode newHead ( 0 ); newHead . next = head ; ListNode * pre = & newHead , * cur = head , * next = NULL ; int i = 1 ; while ( i < n ) { if ( i ++ < m ) { pre = cur ; cur = cur -> next ; } else { next = cur -> next ; cur -> next = cur -> next -> next ; next -> next = pre -> next ; pre -> next = next ; } } return newHead . next ; }","title":"Reverse Linked List II"},{"location":"CompCoding/Hard/list/#leetcode-876-middle-of-the-linked-list","text":"Slow pointer and fast pointer approach. class Solution { public : ListNode * middleNode ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } };","title":"Leetcode 876: Middle of the Linked List"},{"location":"CompCoding/Hard/list/#leetcode-21-merge-two-sorted-lists","text":"Similar to merge operation of merge sort. class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { // iterative ListNode * res = new ListNode (); ListNode * temp = res ; while ( l1 != NULL && l2 != NULL ) { if ( l1 -> val < l2 -> val ) { res -> next = l1 ; res = res -> next ; l1 = l1 -> next ; } else { res -> next = l2 ; res = res -> next ; l2 = l2 -> next ; } } while ( l1 != NULL ) { res -> next = l1 ; res = res -> next ; l1 = l1 -> next ; } while ( l2 != NULL ) { res -> next = l2 ; res = res -> next ; l2 = l2 -> next ; } return temp -> next ; } };","title":"Leetcode 21: merge two sorted lists"},{"location":"CompCoding/Hard/list/#leetcode-19-remove-nth-node-from-end-of-list","text":"Step1 : Move fast pointer by N nodes Step2 : Slow points to start of list, Fast points to Nth node, Keep iterating list until fast points to null. Step3 : Remove node pointed by slow. Make sure to add null checks everywhere. class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { ListNode * slow , * fast = head , * dummy , * ret ; slow = new ListNode ( 0 ); slow -> next = head ; fast = slow ; dummy = slow ; for ( int i = 0 ; i < n ; i ++ ) { fast = fast ? fast -> next : nullptr ; } while ( fast && fast -> next != nullptr ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next ? slow -> next -> next : nullptr ; ret = dummy -> next ; delete dummy ; return ret ; } };","title":"Leetcode 19: Remove Nth Node From End of List"},{"location":"CompCoding/Hard/list/#leetcode-2-add-two-numbers","text":"ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int c = 0; ListNode newHead(0); ListNode *t = &newHead; while(c || l1 || l2) { c += (l1? l1->val : 0) + (l2? l2->val : 0); t->next = new ListNode(c%10); t = t->next; c /= 10; if(l1) l1 = l1->next; if(l2) l2 = l2->next; } return newHead.next; }","title":"Leetcode 2: Add Two Numbers"},{"location":"CompCoding/Hard/list/#remove-duplicates-from-sorted-list","text":"Given 1->1->2, return 1->2. ListNode * deleteDuplicates ( ListNode * head ) { if ( ! head ) return head ; ListNode * t = head , * p = head -> next ; int pre = head -> val ; while ( p ) { if ( pre != p -> val ) { t -> next = p ; pre = p -> val ; t = t -> next ; } p = p -> next ; } t -> next = NULL ; return head ; }","title":"Remove Duplicates from Sorted List"},{"location":"CompCoding/Hard/list/#remove-duplicates-from-sorted-list-ii","text":"Given 1->1->1->2->3, return 2->3. Use dummy node to simplify code. ListNode * deleteDuplicates ( ListNode * head ) { ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * cur = dummy ; int duplicate ; while ( cur -> next && cur -> next -> next ) { if ( cur -> next -> val == cur -> next -> next -> val ) { duplicate = cur -> next -> val ; while ( cur -> next && cur -> next -> val == duplicate ) cur -> next = cur -> next -> next ; } else cur = cur -> next ; } return dummy -> next ; } //Recursive ListNode * deleteDuplicates ( ListNode * head ) { if ( ! head ) return 0 ; if ( ! head -> next ) return head ; int val = head -> val ; ListNode * p = head -> next ; if ( p -> val != val ) { head -> next = deleteDuplicates ( p ); return head ;} else { while ( p && p -> val == val ) p = p -> next ; return deleteDuplicates ( p ); } }","title":"Remove Duplicates from Sorted List II"},{"location":"CompCoding/Hard/list/#check-if-palindrome-linked-list","text":"Find middle of linked list. Set next of middle node to null. Reverse second half. Compare. bool isPalindrome ( ListNode * head ) { if ( ! head || ! head -> next ) return true ; ListNode * slow = head , * fast = head -> next ; while ( fast && fast -> next ) { //split into two halves while the first half can be one-node longer; slow = slow -> next ; fast = fast -> next -> next ; } fast = slow -> next ; slow -> next = NULL ; ListNode newHead ( 0 ); //reverse the second half; ListNode * next = NULL , * p = fast ; while ( p ) { next = p -> next ; p -> next = newHead . next ; newHead . next = p ; p = next ; } fast = newHead . next ; //compare the two lists; while ( fast ) { if ( fast -> val != head -> val ) return false ; fast = fast -> next ; head = head -> next ; } return fast == NULL ; }","title":"Check if Palindrome Linked List"},{"location":"CompCoding/Hard/list/#160-intersection-of-two-linked-lists","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( headA == NULL || headB == NULL ) return NULL ; ListNode * a = headA ; ListNode * b = headB ; //if a & b have different len, then we will stop the loop after second iteration while ( a != b ){ //for the end of first iteration, we just reset the pointer to the head of another linkedlist a = a == NULL ? headB : a -> next ; b = b == NULL ? headA : b -> next ; } return a ; } };","title":"160. Intersection of Two Linked Lists"},{"location":"CompCoding/Hard/list/#detect-cycle-in-linked-list","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : bool hasCycle ( ListNode * head ) { if ( head == NULL || head -> next == NULL ) return false ; ListNode * fast = head ; ListNode * slow = head ; while ( fast -> next && fast -> next -> next ){ fast = fast -> next -> next ; slow = slow -> next ; if ( fast == slow ) return true ; } return false ; } };","title":"Detect cycle in linked list"},{"location":"CompCoding/Hard/list/#check-if-palindromic-linked-list","text":"Find middle of linked list. Reverse right half. Compare from start and mid. if equal then palindromic. class Solution { public boolean isPalindrome ( ListNode head ) { if ( head == null || head . next == null ) return true ; ListNode slow = head ; ListNode fast = head ; while ( fast . next != null && fast . next . next != null ){ slow = slow . next ; fast = fast . next . next ; } slow . next = reverseList ( slow . next ); slow = slow . next ; while ( slow != null ){ if ( head . val != slow . val ) return false ; head = head . next ; slow = slow . next ; } return true ; } ListNode reverseList ( ListNode head ) { ListNode pre = null ; ListNode next = null ; while ( head != null ){ next = head . next ; head . next = pre ; pre = head ; head = next ; } return pre ; } }","title":"Check if Palindromic linked list"},{"location":"CompCoding/Hard/list/#reverse-nodes-in-groups-of-k","text":"Focus on reversing 1 link. Do above step K times. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( head == NULL || k == 1 ) return head ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * cur = dummy , * nex = dummy , * pre = dummy ; int count = 0 ; while ( cur -> next != NULL ){ cur = cur -> next ; count ++ ; } while ( count >= k ){ cur = pre -> next ; nex = cur -> next ; for ( int i = 1 ; i < k ; i ++ ){ cur -> next = nex -> next ; nex -> next = pre -> next ; pre -> next = nex ; nex = cur -> next ; } pre = cur ; count -= k ; } return dummy -> next ; } };","title":"Reverse nodes in groups of K"},{"location":"CompCoding/Hard/list/#clone-a-linked-list-with-next-and-random-pointer","text":"Naive: Create map of Replace pointers in new nodes. Optimal approach: Insert new nodes next to old nodes. Now you know where is new node for a given old node without map. /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public : Node * copyRandomList ( Node * head ) { Node * iter = head ; Node * front = head ; // First round: make copy of each node, // and link them together side-by-side in a single list. while ( iter != NULL ) { front = iter -> next ; Node * copy = new Node ( iter -> val ); iter -> next = copy ; copy -> next = front ; iter = front ; } // Second round: assign random pointers for the copy nodes. iter = head ; while ( iter != NULL ) { if ( iter -> random != NULL ) { iter -> next -> random = iter -> random -> next ; } iter = iter -> next -> next ; } // Third round: restore the original list, and extract the copy list. iter = head ; Node * pseudoHead = new Node ( 0 ); Node * copy = pseudoHead ; while ( iter != NULL ) { front = iter -> next -> next ; // extract the copy copy -> next = iter -> next ; // restore the original list iter -> next = front ; copy = copy -> next ; iter = front ; } return pseudoHead -> next ; } };","title":"Clone a Linked List with next and random pointer"},{"location":"CompCoding/Hard/list/#leetcode-61-rotate-list","text":"Given the head of a linked list, rotate the list to the right by k places. Solution: Get size of linked list and do % k operation. This will save rotation by size of list. To rotate by K, keep fast pointer ahead by size-K and point it to null. Point dummy->next to next of fast. Point end of list to start of list.","title":"Leetcode 61: Rotate List"},{"location":"CompCoding/Hard/numbertheory/","text":"Modular multiplicative inverse: (A/B) % m != A%m / B%m (not equal) (A*B) % m = A%m * B%m (equal) (A/B) => A * B^-1 (A/B) % m = (A * B^-1) %m We need to find B^-1 i.e. modular multiplicative inverse Fermet's little theorem : ( A ^ m-1 ) %m = 1 where m=prime, A is not multiple of m If you take mod m of A ^ m-1, then remainder will always be 1. Multiply by A^-1 on both sides ( A ^ m-2 ) % m = A ^ -1 So, modular multiplicative inverse of A i.e. A^-1 = A^m-2 Use binary exponentiation to calculate pow(A, m-2) as m is 1e9+7 Binary Exponentiation Binary exponentiation is used if int binexp ( int a , int b , int m ) { int result = 1 ; while ( b > 0 ) { if ( b & 1 ) { // odd number result = ( result * 1L L * a ) % m ; } a = ( a * 1L L * a ) % m ; b >> 1 ; } return result ; } Check if prime bool isPrime ( int n ) { if ( n == 1 ) return false ; //Need to check till sqrt(n) since after sqrt we will get same pairs reversed for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } Find gcd int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } Arithmetic Progressions A sequence of numbers is called an arithmetic progression if the difference between any two consecutive terms is always same. In simple terms, it means that next number in the series is calculated by adding a fixed number to the previous number in the series. This fixed number is called the common difference. For example, 2,4,6,8,10 is an AP because difference between any two consecutive terms in the series (common difference) is same (4 \u2013 2 = 6 \u2013 4 = 8 \u2013 6 = 10 \u2013 8 = 2). If \u2018a\u2019 is the first term and \u2018d\u2019 is the common difference, nth term of an AP = a + (n-1) d Arithmetic Mean = Sum of all terms in the AP / Number of terms in the AP Sum of \u2018n\u2019 terms of an AP = 0.5 n (first term + last term) = 0.5 n [ 2a + (n-1) d ] Sum of all numbers from 1 to N Sum(N) = N * (N+1) / 2 Geometric Progressions A sequence of numbers is called a geometric progression if the ratio of any two consecutive terms is always same. In simple terms, it means that next number in the series is calculated by multiplying a fixed number to the previous number in the series. This fixed number is called the common ratio. For example, 2,4,8,16 is a GP because ratio of any two consecutive terms in the series (common difference) is same (4 / 2 = 8 / 4 = 16 / 8 = 2). If \u2018a\u2019 is the first term and \u2018r\u2019 is the common ratio, nth term of a GP = a rn-1 Geometric Mean = nth root of product of n terms in the GP Sum of \u2018n\u2019 terms of a GP (r < 1) = [a (1 \u2013 rn)] / [1 \u2013 r] Sum of \u2018n\u2019 terms of a GP (r > 1) = [a (rn \u2013 1)] / [r \u2013 1] Sum of infinite terms of a GP (r < 1) = (a) / (1 \u2013 r) Catalan Numbers Cn = C0Cn-1 + C1Cn-2 + C2Cn-3 (2n)! / ((n + 1)!n!)","title":"Number Theory"},{"location":"CompCoding/Hard/numbertheory/#modular-multiplicative-inverse","text":"(A/B) % m != A%m / B%m (not equal) (A*B) % m = A%m * B%m (equal) (A/B) => A * B^-1 (A/B) % m = (A * B^-1) %m We need to find B^-1 i.e. modular multiplicative inverse Fermet's little theorem : ( A ^ m-1 ) %m = 1 where m=prime, A is not multiple of m If you take mod m of A ^ m-1, then remainder will always be 1. Multiply by A^-1 on both sides ( A ^ m-2 ) % m = A ^ -1 So, modular multiplicative inverse of A i.e. A^-1 = A^m-2 Use binary exponentiation to calculate pow(A, m-2) as m is 1e9+7","title":"Modular multiplicative inverse:"},{"location":"CompCoding/Hard/numbertheory/#binary-exponentiation","text":"Binary exponentiation is used if int binexp ( int a , int b , int m ) { int result = 1 ; while ( b > 0 ) { if ( b & 1 ) { // odd number result = ( result * 1L L * a ) % m ; } a = ( a * 1L L * a ) % m ; b >> 1 ; } return result ; }","title":"Binary Exponentiation"},{"location":"CompCoding/Hard/numbertheory/#check-if-prime","text":"bool isPrime ( int n ) { if ( n == 1 ) return false ; //Need to check till sqrt(n) since after sqrt we will get same pairs reversed for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }","title":"Check if prime"},{"location":"CompCoding/Hard/numbertheory/#find-gcd","text":"int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); }","title":"Find gcd"},{"location":"CompCoding/Hard/numbertheory/#arithmetic-progressions","text":"A sequence of numbers is called an arithmetic progression if the difference between any two consecutive terms is always same. In simple terms, it means that next number in the series is calculated by adding a fixed number to the previous number in the series. This fixed number is called the common difference. For example, 2,4,6,8,10 is an AP because difference between any two consecutive terms in the series (common difference) is same (4 \u2013 2 = 6 \u2013 4 = 8 \u2013 6 = 10 \u2013 8 = 2). If \u2018a\u2019 is the first term and \u2018d\u2019 is the common difference, nth term of an AP = a + (n-1) d Arithmetic Mean = Sum of all terms in the AP / Number of terms in the AP Sum of \u2018n\u2019 terms of an AP = 0.5 n (first term + last term) = 0.5 n [ 2a + (n-1) d ] Sum of all numbers from 1 to N Sum(N) = N * (N+1) / 2","title":"Arithmetic Progressions"},{"location":"CompCoding/Hard/numbertheory/#geometric-progressions","text":"A sequence of numbers is called a geometric progression if the ratio of any two consecutive terms is always same. In simple terms, it means that next number in the series is calculated by multiplying a fixed number to the previous number in the series. This fixed number is called the common ratio. For example, 2,4,8,16 is a GP because ratio of any two consecutive terms in the series (common difference) is same (4 / 2 = 8 / 4 = 16 / 8 = 2). If \u2018a\u2019 is the first term and \u2018r\u2019 is the common ratio, nth term of a GP = a rn-1 Geometric Mean = nth root of product of n terms in the GP Sum of \u2018n\u2019 terms of a GP (r < 1) = [a (1 \u2013 rn)] / [1 \u2013 r] Sum of \u2018n\u2019 terms of a GP (r > 1) = [a (rn \u2013 1)] / [r \u2013 1] Sum of infinite terms of a GP (r < 1) = (a) / (1 \u2013 r)","title":"Geometric Progressions"},{"location":"CompCoding/Hard/numbertheory/#catalan-numbers","text":"Cn = C0Cn-1 + C1Cn-2 + C2Cn-3 (2n)! / ((n + 1)!n!)","title":"Catalan Numbers"},{"location":"CompCoding/Hard/recursion/","text":"Print all permutation of given sequence Question: Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. class Solution { private : void recurPermute ( vector < int > & ds , vector < int > & nums , vector < vector < int >> & ans , int freq []) { if ( ds . size () == nums . size ()) { ans . push_back ( ds ); return ; } for ( int i = 0 ; i < nums . size (); i ++ ) { if ( ! freq [ i ]) { ds . push_back ( nums [ i ]); //Mark that we have used index i freq [ i ] = 1 ; recurPermute ( ds , nums , ans , freq ); freq [ i ] = 0 ; ds . pop_back (); } } } public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > ds ; int freq [ nums . size ()]; for ( int i = 0 ; i < nums . size (); i ++ ) freq [ i ] = 0 ; recurPermute ( ds , nums , ans , freq ); return ans ; } }; //Approach 2: class Solution { private : void recurPermute ( int index , vector < int > & nums , vector < vector < int >> & ans ) { if ( index == nums . size ()) { ans . push_back ( nums ); return ; } for ( int i = index ; i < nums . size (); i ++ ) { swap ( nums [ index ], nums [ i ]); recurPermute ( index + 1 , nums , ans ); swap ( nums [ index ], nums [ i ]); } } public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; recurPermute ( 0 , nums , ans ); return ans ; } }; N queens class Solution { public : void solve ( int col , vector < string > & board , vector < vector < string >> & ans , vector < int > & leftRow , vector < int > & upperDiagonal , vector < int > & lowerDiagonal , int n ) { if ( col == n ) { ans . push_back ( board ); return ; } for ( int row = 0 ; row < n ; row ++ ) { if ( leftRow [ row ] == 0 && lowerDiagonal [ row + col ] == 0 && upperDiagonal [ n -1 + col - row ] == 0 ) { board [ row ][ col ] = 'Q' ; leftRow [ row ] = 1 ; lowerDiagonal [ row + col ] = 1 ; upperDiagonal [ n -1 + col - row ] = 1 ; solve ( col + 1 , board , ans , leftRow , upperDiagonal , lowerDiagonal , n ); board [ row ][ col ] = '.' ; leftRow [ row ] = 0 ; lowerDiagonal [ row + col ] = 0 ; upperDiagonal [ n -1 + col - row ] = 0 ; } } } public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n ); string s ( n , '.' ); for ( int i = 0 ; i < n ; i ++ ) { board [ i ] = s ; } vector < int > leftRow ( n , 0 ), upperDiagonal ( 2 * n - 1 , 0 ), lowerDiagonal ( 2 * n - 1 , 0 ); solve ( 0 , board , ans , leftRow , upperDiagonal , lowerDiagonal , n ); return ans ; } }; Subset sums Return all subset sums. public : void func ( int ind , int sum , vector < int > & arr , int N , vector < int > & sumSubset ) { if ( ind == N ) { sumSubset . push_back ( sum ); return ; } // pick the element func ( ind + 1 , sum + arr [ ind ], arr , N , sumSubset ); // Do-not pick the element func ( ind + 1 , sum , arr , N , sumSubset ); } public : vector < int > subsetSums ( vector < int > arr , int N ) { vector < int > sumSubset ; //use set directly func ( 0 , 0 , arr , N , sumSubset ); sort ( sumSubset . begin (), sumSubset . end ()); return sumSubset ; } Leetcode 90. Subsets II Question: Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. class Solution { private : void subsetsWithDup ( std :: vector < std :: vector < int > > & res , std :: vector < int > & nums , std :: vector < int > & vec , int begin ) { res . push_back ( vec ); for ( int i = begin ; i != nums . size (); ++ i ) //i==begin is required to avoid oob for i-1 //11112 Here if you have considered first 1 then no need to consider duplicate 1s ahead if ( i == begin || nums [ i ] != nums [ i - 1 ]) { vec . push_back ( nums [ i ]); subsetsWithDup ( res , nums , vec , i + 1 ); vec . pop_back (); } } public : std :: vector < std :: vector < int > > subsetsWithDup ( std :: vector < int > & nums ) { std :: sort ( nums . begin (), nums . end ()); std :: vector < std :: vector < int > > res ; std :: vector < int > vec ; subsetsWithDup ( res , nums , vec , 0 ); return res ; } }; Combination sum Same as subests //#define Test #ifdef Test #define debug(x) cout << #x<<\" \"; _print(x); cout << endl; #else #define debug(x); #endif void _print ( int t ) { cout << t ;} template < class T > void _print ( vector < T > v ) { cout << \"[ \" ; for ( T i : v ) { _print ( i ); cout << \" \" ; } cout << \"]\" ; } class Solution { public : void func ( vector < int >& candidates , vector < int >& ds , int & sum , int index , int target , vector < vector < int >>& ans ) { if ( sum > target ) return ; if ( index == candidates . size ()){ debug ( ds ) //cout<<\"sum=\"<<sum<<endl; if ( sum == target ) ans . push_back ( ds ); return ; } func ( candidates , ds , sum , index + 1 , target , ans ); //dont take current index //take current index ds . push_back ( candidates [ index ]); sum += candidates [ index ]; func ( candidates , ds , sum , index , target , ans ); sum -= candidates [ index ]; ds . pop_back (); } vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > ds ; int sum = 0 ; func ( candidates , ds , sum , 0 , target , ans ); return ans ; } }; Combination Sum 2 Question : Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. class Solution { private : void func ( vector < int >& candidates , vector < int >& ds , int & sum , int index , int target , vector < vector < int >>& ans ) { if ( sum == target ) { debug ( ds ) ans . push_back ( ds ); return ; } for ( int i = index ; i < candidates . size (); i ++ ) { debug ( i ) if ( i == index || candidates [ i ] != candidates [ i -1 ]) { //func(candidates,ds,sum,i+1,target,ans); ds . push_back ( candidates [ i ]); sum += candidates [ i ]; func ( candidates , ds , sum , i + 1 , target , ans ); sum -= candidates [ i ]; ds . pop_back (); } } } public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > ds ; sort ( candidates . begin (), candidates . end ()); int sum = 0 ; func ( candidates , ds , sum , 0 , target , ans ); return ans ; } }; Sudoku Solver M coloring Rat in a maze Kth permutation Following example is using sorted input. But it will work even for unsorted input. ip=[1,2,3,4] n=4 -> So there are total 4! permutations k=17 i.e. find 17th permutation of given sequence 3! 1 (2,3,4) 6 2 (1,3,4) +6 3 (1,2,4) +6 4 (1,2,3) +6 24 so 17th (16th in 0 based indexing) permutation will be in 3rd group. Do recursion on this. class Solution { public : string getPermutation ( int n , int k ) { int fact = 1 ; vector < int > numbers ; for ( int i = 1 ; i < n ; i ++ ) { fact = fact * i ; numbers . push_back ( i ); } numbers . push_back ( n ); string ans = \"\" ; k = k - 1 ; while ( true ) { ans = ans + to_string ( numbers [ k / fact ]); //fact is n-1! numbers . erase ( numbers . begin () + k / fact ); //remove number added to answer if ( numbers . size () == 0 ) { break ; } k = k % fact ; fact = fact / numbers . size (); } return ans ; } };","title":"Recursion"},{"location":"CompCoding/Hard/recursion/#print-all-permutation-of-given-sequence","text":"Question: Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. class Solution { private : void recurPermute ( vector < int > & ds , vector < int > & nums , vector < vector < int >> & ans , int freq []) { if ( ds . size () == nums . size ()) { ans . push_back ( ds ); return ; } for ( int i = 0 ; i < nums . size (); i ++ ) { if ( ! freq [ i ]) { ds . push_back ( nums [ i ]); //Mark that we have used index i freq [ i ] = 1 ; recurPermute ( ds , nums , ans , freq ); freq [ i ] = 0 ; ds . pop_back (); } } } public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > ds ; int freq [ nums . size ()]; for ( int i = 0 ; i < nums . size (); i ++ ) freq [ i ] = 0 ; recurPermute ( ds , nums , ans , freq ); return ans ; } }; //Approach 2: class Solution { private : void recurPermute ( int index , vector < int > & nums , vector < vector < int >> & ans ) { if ( index == nums . size ()) { ans . push_back ( nums ); return ; } for ( int i = index ; i < nums . size (); i ++ ) { swap ( nums [ index ], nums [ i ]); recurPermute ( index + 1 , nums , ans ); swap ( nums [ index ], nums [ i ]); } } public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; recurPermute ( 0 , nums , ans ); return ans ; } };","title":"Print all permutation of given sequence"},{"location":"CompCoding/Hard/recursion/#n-queens","text":"class Solution { public : void solve ( int col , vector < string > & board , vector < vector < string >> & ans , vector < int > & leftRow , vector < int > & upperDiagonal , vector < int > & lowerDiagonal , int n ) { if ( col == n ) { ans . push_back ( board ); return ; } for ( int row = 0 ; row < n ; row ++ ) { if ( leftRow [ row ] == 0 && lowerDiagonal [ row + col ] == 0 && upperDiagonal [ n -1 + col - row ] == 0 ) { board [ row ][ col ] = 'Q' ; leftRow [ row ] = 1 ; lowerDiagonal [ row + col ] = 1 ; upperDiagonal [ n -1 + col - row ] = 1 ; solve ( col + 1 , board , ans , leftRow , upperDiagonal , lowerDiagonal , n ); board [ row ][ col ] = '.' ; leftRow [ row ] = 0 ; lowerDiagonal [ row + col ] = 0 ; upperDiagonal [ n -1 + col - row ] = 0 ; } } } public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n ); string s ( n , '.' ); for ( int i = 0 ; i < n ; i ++ ) { board [ i ] = s ; } vector < int > leftRow ( n , 0 ), upperDiagonal ( 2 * n - 1 , 0 ), lowerDiagonal ( 2 * n - 1 , 0 ); solve ( 0 , board , ans , leftRow , upperDiagonal , lowerDiagonal , n ); return ans ; } };","title":"N queens"},{"location":"CompCoding/Hard/recursion/#subset-sums","text":"Return all subset sums. public : void func ( int ind , int sum , vector < int > & arr , int N , vector < int > & sumSubset ) { if ( ind == N ) { sumSubset . push_back ( sum ); return ; } // pick the element func ( ind + 1 , sum + arr [ ind ], arr , N , sumSubset ); // Do-not pick the element func ( ind + 1 , sum , arr , N , sumSubset ); } public : vector < int > subsetSums ( vector < int > arr , int N ) { vector < int > sumSubset ; //use set directly func ( 0 , 0 , arr , N , sumSubset ); sort ( sumSubset . begin (), sumSubset . end ()); return sumSubset ; }","title":"Subset sums"},{"location":"CompCoding/Hard/recursion/#leetcode-90-subsets-ii","text":"Question: Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. class Solution { private : void subsetsWithDup ( std :: vector < std :: vector < int > > & res , std :: vector < int > & nums , std :: vector < int > & vec , int begin ) { res . push_back ( vec ); for ( int i = begin ; i != nums . size (); ++ i ) //i==begin is required to avoid oob for i-1 //11112 Here if you have considered first 1 then no need to consider duplicate 1s ahead if ( i == begin || nums [ i ] != nums [ i - 1 ]) { vec . push_back ( nums [ i ]); subsetsWithDup ( res , nums , vec , i + 1 ); vec . pop_back (); } } public : std :: vector < std :: vector < int > > subsetsWithDup ( std :: vector < int > & nums ) { std :: sort ( nums . begin (), nums . end ()); std :: vector < std :: vector < int > > res ; std :: vector < int > vec ; subsetsWithDup ( res , nums , vec , 0 ); return res ; } };","title":"Leetcode 90. Subsets II"},{"location":"CompCoding/Hard/recursion/#combination-sum","text":"Same as subests //#define Test #ifdef Test #define debug(x) cout << #x<<\" \"; _print(x); cout << endl; #else #define debug(x); #endif void _print ( int t ) { cout << t ;} template < class T > void _print ( vector < T > v ) { cout << \"[ \" ; for ( T i : v ) { _print ( i ); cout << \" \" ; } cout << \"]\" ; } class Solution { public : void func ( vector < int >& candidates , vector < int >& ds , int & sum , int index , int target , vector < vector < int >>& ans ) { if ( sum > target ) return ; if ( index == candidates . size ()){ debug ( ds ) //cout<<\"sum=\"<<sum<<endl; if ( sum == target ) ans . push_back ( ds ); return ; } func ( candidates , ds , sum , index + 1 , target , ans ); //dont take current index //take current index ds . push_back ( candidates [ index ]); sum += candidates [ index ]; func ( candidates , ds , sum , index , target , ans ); sum -= candidates [ index ]; ds . pop_back (); } vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > ds ; int sum = 0 ; func ( candidates , ds , sum , 0 , target , ans ); return ans ; } };","title":"Combination sum"},{"location":"CompCoding/Hard/recursion/#combination-sum-2","text":"Question : Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. class Solution { private : void func ( vector < int >& candidates , vector < int >& ds , int & sum , int index , int target , vector < vector < int >>& ans ) { if ( sum == target ) { debug ( ds ) ans . push_back ( ds ); return ; } for ( int i = index ; i < candidates . size (); i ++ ) { debug ( i ) if ( i == index || candidates [ i ] != candidates [ i -1 ]) { //func(candidates,ds,sum,i+1,target,ans); ds . push_back ( candidates [ i ]); sum += candidates [ i ]; func ( candidates , ds , sum , i + 1 , target , ans ); sum -= candidates [ i ]; ds . pop_back (); } } } public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > ds ; sort ( candidates . begin (), candidates . end ()); int sum = 0 ; func ( candidates , ds , sum , 0 , target , ans ); return ans ; } };","title":"Combination Sum 2"},{"location":"CompCoding/Hard/recursion/#sudoku-solver","text":"","title":"Sudoku Solver"},{"location":"CompCoding/Hard/recursion/#m-coloring","text":"","title":"M coloring"},{"location":"CompCoding/Hard/recursion/#rat-in-a-maze","text":"","title":"Rat in a maze"},{"location":"CompCoding/Hard/recursion/#kth-permutation","text":"Following example is using sorted input. But it will work even for unsorted input. ip=[1,2,3,4] n=4 -> So there are total 4! permutations k=17 i.e. find 17th permutation of given sequence 3! 1 (2,3,4) 6 2 (1,3,4) +6 3 (1,2,4) +6 4 (1,2,3) +6 24 so 17th (16th in 0 based indexing) permutation will be in 3rd group. Do recursion on this. class Solution { public : string getPermutation ( int n , int k ) { int fact = 1 ; vector < int > numbers ; for ( int i = 1 ; i < n ; i ++ ) { fact = fact * i ; numbers . push_back ( i ); } numbers . push_back ( n ); string ans = \"\" ; k = k - 1 ; while ( true ) { ans = ans + to_string ( numbers [ k / fact ]); //fact is n-1! numbers . erase ( numbers . begin () + k / fact ); //remove number added to answer if ( numbers . size () == 0 ) { break ; } k = k % fact ; fact = fact / numbers . size (); } return ans ; } };","title":"Kth permutation"},{"location":"CompCoding/Hard/sdesheet/","text":"Leetcode 31: Next Permutation Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, just reverse nums and done. Find the largest index l > k such that nums[k] < nums[l]. Swap nums[k] and nums[l]. Reverse the sub-array nums[k + 1:]. class Solution { public : void nextPermutation ( vector < int >& nums ) { int n = nums . size (), k , l ; for ( k = n - 2 ; k >= 0 ; k -- ) { if ( nums [ k ] < nums [ k + 1 ]) { break ; } } if ( k < 0 ) { reverse ( nums . begin (), nums . end ()); } else { for ( l = n - 1 ; l > k ; l -- ) { if ( nums [ l ] > nums [ k ]) { break ; } } swap ( nums [ k ], nums [ l ]); reverse ( nums . begin () + k + 1 , nums . end ()); } } }; Maximum Sum Subarray (Kadane's Algorithm) Initialize: max_so_far = INT_MIN max_ending_here = 0 Loop for each element of the array (a) max_ending_here = max_ending_here + a[i] (b) if(max_so_far < max_ending_here) max_so_far = max_ending_here (c) if(max_ending_here < 0) max_ending_here = 0 return max_so_far int maxSubArraySum ( int a [], int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ]; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } Sort Colors 0, 1, 2: Dutch national flag algo (Similar to quick sort) The solution requires the use of tracking 3 positions, the Low, Mid and High. We assume that the mid is the \"Unknown\" area that we must evaluate. If we encounter a 0, we know that it will be on the low end of the array, and if we encounter a 2, we know it will be on the high end of the array. To achieve this in one pass without preprocessing (counting), we simply traverse the unknown will generating the low and high ends. Take this example: Assume our input is: 1 0 2 2 1 0 (short for simplicity). Running the algorithm by hand would look something like: 1 0 2 2 1 0 ^ ^ L H M Mid != 0 || 2 Mid++ 1 0 2 2 1 0 ^ ^ ^ L M H Mid == 0 Swap Low and Mid Mid++ Low++ 0 1 2 2 1 0 ^ ^ ^ L M H Mid == 2 Swap High and Mid High-- 0 1 0 2 1 2 ^ ^ ^ L M H Mid == 0 Swap Low and Mid Mid++ Low++ 0 0 1 2 1 2 ^ ^ ^ L M H Mid == 2 Swap High and Mid High-- 0 0 1 1 2 2 ^ ^ L M H Mid <= High is our exit case class Solution { public : void sortColors ( vector < int >& nums ) { int tmp = 0 , low = 0 , mid = 0 , high = nums . size () - 1 ; while ( mid <= high ) { if ( nums [ mid ] == 0 ) { tmp = nums [ low ]; nums [ low ] = nums [ mid ]; nums [ mid ] = tmp ; low ++ ; mid ++ ; } else if ( nums [ mid ] == 1 ) { mid ++ ; } else if ( nums [ mid ] == 2 ) { tmp = nums [ high ]; nums [ high ] = nums [ mid ]; nums [ mid ] = tmp ; high -- ; } } } }; Stock Buy and Sell Case 1: Only 1 transaction 121. Best Time to Buy and Sell Stock Approach 1: Convert given stock prices array to price change array. Now this is nothing but a maximum sum contiguous subarray problem. Approach 2: we keep track the lowest price and once the price exceeds the old lowest price, we record the difference. var maxProfit = function ( prices ) { const size = prices . length ; let lowPrice = prices [ 0 ]; let profit = 0 ; for ( let i = 1 ; i < size ; i ++ ) { if ( prices [ i ] < lowPrice ) { lowPrice = prices [ i ]; } else { profit = Math . max ( prices [ i ] - lowPrice , profit ); } } return profit ; }; Case 2: Multiple transaction 122. Best Time to Buy and Sell Stock II Everyday transact if profit for that day is >0. int maxProfit ( vector < int > & prices ) { int ret = 0 ; for ( size_t p = 1 ; p < prices . size (); ++ p ) ret += max ( prices [ p ] - prices [ p - 1 ], 0 ); return ret ; } Case 3: Maximum 2 transactions 123. Best Time to Buy and Sell Stock III Here, the oneBuy keeps track of the lowest price, and oneBuyOneSell keeps track of the biggest profit we could get. Then the tricky part comes, how to handle the twoBuy? Suppose in real life, you have bought and sold a stock and made 100 dollar profit. When you want to purchase a stock which costs you 300 dollars, how would you think this? You must think, um, I have made 100 profit, so I think this 300 dollar stock is worth 200 FOR ME since I have hold 100 for free. There we go, you got the idea how we calculate twoBuy!! We just minimize the cost again!! The twoBuyTwoSell is just making as much profit as possible. Hope this explanation helps other people to understand this! int maxProfit ( vector < int > prices ) { int oneBuyOneSell = 0 ; int twoBuyTwoSell = 0 ; int oneBuy = INT_MAX ; int twoBuy = INT_MAX ; for ( let i = 0 ; i < prices . length (); i ++ ) { int p = prices [ i ]; oneBuy = min ( oneBuy , p ); oneBuyOneSell = max ( oneBuyOneSell , p - oneBuy ); twoBuy = min ( twoBuy , p - oneBuyOneSell ); twoBuyTwoSell = max ( twoBuyTwoSell , p - twoBuy ); } return twoBuyTwoSell ; }; Case 4: Maximum K transations (DP) Best Time to Buy and Sell Stock IV If K<n/2 then use case 2 as you can buy and sell everyday For K>= n/2, There are 2 options. Get max profit (profit[k][day]) of following 2 options: Don't transact(sell) on Day d => profit[k][day-1] Transact on Day d => price[d] - price[i] + profit[k-1][i] where i=0..d-1 price[d] - price[i] = Profit from i-d transaction https://www.youtube.com/watch?v=oDhu5uGq_ic Time : O ( n ^ 2 k ) Space : O ( nk ) int maxProfitWithKTransactions ( vector < int > prices , int k ) { if ( prices . size () == 0 or k == 0 ) return 0 ; vector < vector < int >> profits ( k + 1 , vector < int > ( prices . size (), 0 )); // DP table for ( int t = 1 ; t <= k ; t ++ ) { for ( int d = 1 ; d < prices . size (); d ++ ) { int maxi = 0 ; for ( int i = d -1 ; i >= 0 ; i -- ) { maxi = max ( maxi , ( prices [ d ] - prices [ i ] + profits [ t -1 ][ i ]) ); } profits [ t ][ d ] = max ( profits [ t ][ d -1 ], maxi ); } } return profits [ k ][ prices . size () -1 ]; } Time : O ( nk ) Space : O ( nk ) int maxProfitWithKTransactions ( vector < int > prices , int k ) { if ( prices . size () == 0 or k == 0 ) return 0 ; vector < vector < int >> profits ( k + 1 , vector < int > ( prices . size (), 0 )); // DP table for ( int t = 1 ; t <= k ; t ++ ) { int maxSoFar = INT_MIN ; for ( int d = 1 ; d < prices . size (); d ++ ) { maxSoFar = max ( maxSoFar , profits [ t -1 ][ d -1 ] - prices [ d -1 ]); profits [ t ][ d ] = max ( profits [ t ][ d -1 ], maxSoFar + prices [ d ]); } } return profits [ k ][ prices . size () -1 ]; } Leetcode 56: Merge Intervals vector < Interval > merge ( vector < Interval >& ins ) { if ( ins . empty ()) return vector < Interval > {}; vector < Interval > res ; sort ( ins . begin (), ins . end (), []( Interval a , Interval b ){ return a . start < b . start ;}); res . push_back ( ins [ 0 ]); for ( int i = 1 ; i < ins . size (); i ++ ) { if ( res . back (). end < ins [ i ]. start ) res . push_back ( ins [ i ]); else res . back (). end = max ( res . back (). end , ins [ i ]. end ); } return res ; } Similar questions: 252 Meeting Rooms 253 Meeting Rooms II 435 Non-overlapping Intervals Leetcode 88: Merge Sorted Array without extra space E.g: Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int i = m - 1 , j = n - 1 , tar = m + n - 1 ; while ( j >= 0 ) { nums1 [ tar -- ] = i >= 0 && nums1 [ i ] > nums2 [ j ] ? nums1 [ i -- ] : nums2 [ j -- ]; } } }; Leetcode 287: Find the Duplicate Number Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. Input: nums = [1,3,4,2,2] Output: 2 Approach 1: Sort and iterate through the vector. Approach 2: Keep frequency map where you maintain which number has already occurred. Time = O(N) Space = O(N) Approach 3: Given problem is converted to linked list using array index and value. This is possible because input is in range [1,n] E.g.: Given example input converted to linked list: 0->1->3->2->4->2 Use two pointers the fast and the slow. The fast one goes forward two steps each time, while the slow one goes only step each time. They must meet the same item when slow==fast. In fact, they meet in a circle, the duplicate number must be the entry point of the circle when visiting the array from nums[0]. Next we just need to find the entry point. We use a point(we can use the fast one before) to visit form begining with one step each time, do the same job to slow. When fast==slow, they meet at the entry point of the circle. Time = O(N) Space = O(1) int findDuplicate3 ( vector < int >& nums ) { if ( nums . size () > 1 ) { int slow = nums [ 0 ]; int fast = nums [ nums [ 0 ]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } fast = 0 ; while ( fast != slow ) { fast = nums [ fast ]; slow = nums [ slow ]; } return slow ; } return -1 ; } Leetcode 493. Reverse Pairs //My written code class Solution { public : int count = 0 ; void merge ( vector < int >& nums , int left , int mid , int right ) { vector < int > tmp ; int i = left ; int j = mid + 1 ; for (; i <= mid ; i ++ ) { while ( j <= right && nums [ i ] > ( long ) 2 * nums [ j ]) { j ++ ; } count += j - mid -1 ; } //For code simplicity you can directly sort using std::sort(nums.begin()+left, nums.end()+right) //Merging int p = left ; int q = mid + 1 ; while ( p <= mid && q <= right ) { if ( nums [ p ] < nums [ q ]){ tmp . push_back ( nums [ p ]); p ++ ; } else { tmp . push_back ( nums [ q ]); q ++ ; } } //Remaining Elements while ( p <= mid ) { tmp . push_back ( nums [ p ]); p ++ ; } while ( q <= right ) { tmp . push_back ( nums [ q ]); q ++ ; } for ( int r = left ; r <= right ; r ++ ) { nums [ r ] = tmp [ r - left ]; } } void mergeSort ( vector < int >& nums , int left , int right ) { if ( left < right ) { int mid = ( right + left ) / 2 ; mergeSort ( nums , left , mid ); mergeSort ( nums , mid + 1 , right ); merge ( nums , left , mid , right ); } } int reversePairs ( vector < int >& nums ) { mergeSort ( nums , 0 , nums . size () -1 ); return count ; } }; Leetcode 169: Majority Element Boyer Moore Voting Algorithm: This algorithm works on the fact that if an element occurs more than N/2 times, it means that the remaining elements other than this would definitely be less than N/2. So let us check the proceeding of the algorithm. First, choose a candidate from the given set of elements if it is the same as the candidate element, increase the votes. Otherwise, decrease the votes if votes become 0, select another new element as the new candidate. Leetcode Nice Explanation with Pictures class Solution { public : int majorityElement ( vector < int >& nums ) { int count = 0 ; int candidate = 0 ; for ( int num : nums ) { if ( count == 0 ) { candidate = num ; } if ( num == candidate ) count += 1 ; else count -= 1 ; } return candidate ; } }; Leetcode 229: Majority Element II (N/3) This is similar to N/2 Leetcode Explanation class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { int sz = nums . size (); int num1 = -1 , num2 = -1 , count1 = 0 , count2 = 0 , i ; for ( i = 0 ; i < sz ; i ++ ) { if ( nums [ i ] == num1 ) count1 ++ ; else if ( nums [ i ] == num2 ) count2 ++ ; else if ( count1 == 0 ) { num1 = nums [ i ]; count1 = 1 ; } else if ( count2 == 0 ) { num2 = nums [ i ]; count2 = 1 ; } else { count1 -- ; count2 -- ; } } vector < int > ans ; count1 = count2 = 0 ; for ( i = 0 ; i < sz ; i ++ ) { if ( nums [ i ] == num1 ) count1 ++ ; else if ( nums [ i ] == num2 ) count2 ++ ; } if ( count1 > sz / 3 ) ans . push_back ( num1 ); if ( count2 > sz / 3 ) ans . push_back ( num2 ); return ans ; } }; Leetcode 128: Longest Consecutive Sequence Store given array in hashset or hashmap. Solution 1 : check consecutive elements lesser,greater than current element and delete them if present. Update max len. Solution 2 : check current element - 1 in hashset, if present then ignore current. Start counting consecutive only when curr-1 is not present. class Solution { public : int longestConsecutive ( vector < int >& nums ) { unordered_set < int > hashset ( nums . begin (), nums . end ()); int maxlen = 0 ; for ( int n : nums ) { if ( hashset . find ( n ) != hashset . end ()) { int prev = n -1 ; int next = n + 1 ; while ( hashset . find ( prev ) != hashset . end ()) hashset . erase ( prev -- ); while ( hashset . find ( next ) != hashset . end ()) hashset . erase ( next ++ ); maxlen = max ( maxlen , next - prev -1 ); } } return maxlen ; } }; class Solution { public : int longestConsecutive ( vector < int >& nums ) { set < int > hashSet ; for ( int num : nums ) { hashSet . insert ( num ); } int longestStreak = 0 ; for ( int num : nums ) { if ( ! hashSet . count ( num -1 )) { int currentNum = num ; int currentStreak = 1 ; while ( hashSet . count ( currentNum + 1 )) { currentNum += 1 ; currentStreak += 1 ; } longestStreak = max ( longestStreak , currentStreak ); } } return longestStreak ; } }; Length of largest subarray with 0 sum Given an array having both positive and negative integers. The task is to compute the length of the largest subarray with sum 0. Idea is to create a prefix sum array and run loop over prefix sum array and keep updating prefix sum in map. Don't update if already present. int maxLen ( int A [], int n ) { unordered_map < int , int > mpp ; int maxi = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += A [ i ]; if ( sum == 0 ) { maxi = i + 1 ; } else { if ( mpp . find ( sum ) != mpp . end ()) { maxi = max ( maxi , i - mpp [ sum ]); } else { mpp [ sum ] = i ; } } } return maxi ; } Leetcode 3: Longest Substring without repeat Similar to sliding window while maintaining set of characters present in window. class Solution { public : int lengthOfLongestSubstring ( string s ) { int left = 0 , right = 0 ; set < char > st ; int n = s . size (); int len = 0 ; while ( right < n ) { if ( st . find ( s [ right ]) != st . end ()) { st . erase ( s [ left ]); left ++ ; } else { st . insert ( s [ right ]); len = max ( len , right - left + 1 ); right ++ ; } } return len ; } }; Leetcode 496. Next Greater Element I //self written //Storing value on stack and iterating from end (Simple) class Solution { public : vector < int > nextGreaterElement ( vector < int >& nums1 , vector < int >& nums2 ) { stack < int > st ; map < int , int > hash ; for ( int i = nums2 . size () -1 ; i >= 0 ; i -- ) { while ( ! st . empty () && st . top () < nums2 [ i ]) { st . pop (); } if ( st . empty ()) { hash [ nums2 [ i ]] = -1 ; } else { hash [ nums2 [ i ]] = st . top (); } st . push ( nums2 [ i ]); } vector < int > res ; for ( auto i : nums1 ){ res . push_back ( hash [ i ]); } return res ; } }; //Storing value on stack, iterating from start class Solution { public : vector < int > nextGreaterElement ( vector < int >& findNums , vector < int >& nums ) { stack < int > st ; unordered_map < int , int > hash ; for ( int n : nums ) { while ( st . size () && st . top () < n ) { hash [ st . top ()] = n ; st . pop (); } st . push ( n ); } vector < int > ans ; for ( int n : findNums ) ans . push_back ( hash . count ( n ) ? hash [ n ] : -1 ); return ans ; } }; Leetcode 503. Next Greater Element II Simple but difficult to find. //Storing index on stack and iterating from start vector < int > nextGreaterElements ( vector < int >& A ) { int n = A . size (); vector < int > stack , res ( n , -1 ); for ( int i = 0 ; i < n * 2 ; ++ i ) { while ( stack . size () && A [ stack . back ()] < A [ i % n ]) { res [ stack . back ()] = A [ i % n ]; stack . pop_back (); } stack . push_back ( i % n ); } return res ; } Leetcode 26. Remove Duplicates from Sorted Array class Solution { public : int removeDuplicates ( vector < int >& nums ) { int j = 0 ; for ( int i = 1 ; i < nums . size (); i ++ ) { if ( nums [ i ] != nums [ i -1 ]) { j ++ ; nums [ j ] = nums [ i ]; } } return j + 1 ; } }; Leetcode 42. Trapping Rain Water //Simple solution class Solution { public : int trap ( vector < int >& height ) { vector < int > st ( height . size ()); int maxi = 0 ; for ( int i = height . size () -1 ; i >= 0 ; i -- ) { maxi = max ( height [ i ], maxi ); st [ i ] = maxi ; } vector < int > fin ( height . size ()); maxi = 0 ; for ( int i = 0 ; i < height . size (); i ++ ) { maxi = max ( height [ i ], maxi ); fin [ i ] = maxi ; } int ans = 0 ; for ( int i = 1 ; i < height . size () -1 ; i ++ ) { ans += min ( st [ i ], fin [ i ]) - height [ i ]; } return ans ; } }; //Efficient 2 pointers approach (Very difficult to understand) 3 1 2 4 0 1 3 2 3 3 3 4 4 4 4 4 - rmax 4 4 4 4 3 3 3 2 - lmax /* We keep modifying pointers(left/right) until we find current max(right) If arr[left] <= arr[right], this means that arr[right] is the max value found so far on right. This also means that maxLeft will be less than or equal to arr[right], which means that maxLeft will be bounding the addition to the answer(res variable, in this solution), since it has be less than or equal to arr[right] e, so we dont have to consider maxRight when adding to the counter. If arr[left] > arr[right] , this means at arr[left] is the max value found so far on left. Same thing applies as explained in the paragraph above. */ class Solution { public : int trap ( int A [], int n ) { int left = 0 ; int right = n -1 ; int res = 0 ; int maxleft = 0 , maxright = 0 ; while ( left <= right ){ if ( A [ left ] <= A [ right ]){ if ( A [ left ] >= maxleft ) maxleft = A [ left ]; else res += maxleft - A [ left ]; left ++ ; } else { if ( A [ right ] >= maxright ) maxright = A [ right ]; else res += maxright - A [ right ]; right -- ; } } return res ; } };","title":"SDE Sheet"},{"location":"CompCoding/Hard/sdesheet/#leetcode-31-next-permutation","text":"Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, just reverse nums and done. Find the largest index l > k such that nums[k] < nums[l]. Swap nums[k] and nums[l]. Reverse the sub-array nums[k + 1:]. class Solution { public : void nextPermutation ( vector < int >& nums ) { int n = nums . size (), k , l ; for ( k = n - 2 ; k >= 0 ; k -- ) { if ( nums [ k ] < nums [ k + 1 ]) { break ; } } if ( k < 0 ) { reverse ( nums . begin (), nums . end ()); } else { for ( l = n - 1 ; l > k ; l -- ) { if ( nums [ l ] > nums [ k ]) { break ; } } swap ( nums [ k ], nums [ l ]); reverse ( nums . begin () + k + 1 , nums . end ()); } } };","title":"Leetcode 31: Next Permutation"},{"location":"CompCoding/Hard/sdesheet/#maximum-sum-subarray-kadanes-algorithm","text":"Initialize: max_so_far = INT_MIN max_ending_here = 0 Loop for each element of the array (a) max_ending_here = max_ending_here + a[i] (b) if(max_so_far < max_ending_here) max_so_far = max_ending_here (c) if(max_ending_here < 0) max_ending_here = 0 return max_so_far int maxSubArraySum ( int a [], int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ]; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }","title":"Maximum Sum Subarray (Kadane's Algorithm)"},{"location":"CompCoding/Hard/sdesheet/#sort-colors-0-1-2-dutch-national-flag-algo-similar-to-quick-sort","text":"The solution requires the use of tracking 3 positions, the Low, Mid and High. We assume that the mid is the \"Unknown\" area that we must evaluate. If we encounter a 0, we know that it will be on the low end of the array, and if we encounter a 2, we know it will be on the high end of the array. To achieve this in one pass without preprocessing (counting), we simply traverse the unknown will generating the low and high ends. Take this example: Assume our input is: 1 0 2 2 1 0 (short for simplicity). Running the algorithm by hand would look something like: 1 0 2 2 1 0 ^ ^ L H M Mid != 0 || 2 Mid++ 1 0 2 2 1 0 ^ ^ ^ L M H Mid == 0 Swap Low and Mid Mid++ Low++ 0 1 2 2 1 0 ^ ^ ^ L M H Mid == 2 Swap High and Mid High-- 0 1 0 2 1 2 ^ ^ ^ L M H Mid == 0 Swap Low and Mid Mid++ Low++ 0 0 1 2 1 2 ^ ^ ^ L M H Mid == 2 Swap High and Mid High-- 0 0 1 1 2 2 ^ ^ L M H Mid <= High is our exit case class Solution { public : void sortColors ( vector < int >& nums ) { int tmp = 0 , low = 0 , mid = 0 , high = nums . size () - 1 ; while ( mid <= high ) { if ( nums [ mid ] == 0 ) { tmp = nums [ low ]; nums [ low ] = nums [ mid ]; nums [ mid ] = tmp ; low ++ ; mid ++ ; } else if ( nums [ mid ] == 1 ) { mid ++ ; } else if ( nums [ mid ] == 2 ) { tmp = nums [ high ]; nums [ high ] = nums [ mid ]; nums [ mid ] = tmp ; high -- ; } } } };","title":"Sort Colors 0, 1, 2: Dutch national flag algo (Similar to quick sort)"},{"location":"CompCoding/Hard/sdesheet/#stock-buy-and-sell","text":"Case 1: Only 1 transaction 121. Best Time to Buy and Sell Stock Approach 1: Convert given stock prices array to price change array. Now this is nothing but a maximum sum contiguous subarray problem. Approach 2: we keep track the lowest price and once the price exceeds the old lowest price, we record the difference. var maxProfit = function ( prices ) { const size = prices . length ; let lowPrice = prices [ 0 ]; let profit = 0 ; for ( let i = 1 ; i < size ; i ++ ) { if ( prices [ i ] < lowPrice ) { lowPrice = prices [ i ]; } else { profit = Math . max ( prices [ i ] - lowPrice , profit ); } } return profit ; }; Case 2: Multiple transaction 122. Best Time to Buy and Sell Stock II Everyday transact if profit for that day is >0. int maxProfit ( vector < int > & prices ) { int ret = 0 ; for ( size_t p = 1 ; p < prices . size (); ++ p ) ret += max ( prices [ p ] - prices [ p - 1 ], 0 ); return ret ; } Case 3: Maximum 2 transactions 123. Best Time to Buy and Sell Stock III Here, the oneBuy keeps track of the lowest price, and oneBuyOneSell keeps track of the biggest profit we could get. Then the tricky part comes, how to handle the twoBuy? Suppose in real life, you have bought and sold a stock and made 100 dollar profit. When you want to purchase a stock which costs you 300 dollars, how would you think this? You must think, um, I have made 100 profit, so I think this 300 dollar stock is worth 200 FOR ME since I have hold 100 for free. There we go, you got the idea how we calculate twoBuy!! We just minimize the cost again!! The twoBuyTwoSell is just making as much profit as possible. Hope this explanation helps other people to understand this! int maxProfit ( vector < int > prices ) { int oneBuyOneSell = 0 ; int twoBuyTwoSell = 0 ; int oneBuy = INT_MAX ; int twoBuy = INT_MAX ; for ( let i = 0 ; i < prices . length (); i ++ ) { int p = prices [ i ]; oneBuy = min ( oneBuy , p ); oneBuyOneSell = max ( oneBuyOneSell , p - oneBuy ); twoBuy = min ( twoBuy , p - oneBuyOneSell ); twoBuyTwoSell = max ( twoBuyTwoSell , p - twoBuy ); } return twoBuyTwoSell ; }; Case 4: Maximum K transations (DP) Best Time to Buy and Sell Stock IV If K<n/2 then use case 2 as you can buy and sell everyday For K>= n/2, There are 2 options. Get max profit (profit[k][day]) of following 2 options: Don't transact(sell) on Day d => profit[k][day-1] Transact on Day d => price[d] - price[i] + profit[k-1][i] where i=0..d-1 price[d] - price[i] = Profit from i-d transaction https://www.youtube.com/watch?v=oDhu5uGq_ic Time : O ( n ^ 2 k ) Space : O ( nk ) int maxProfitWithKTransactions ( vector < int > prices , int k ) { if ( prices . size () == 0 or k == 0 ) return 0 ; vector < vector < int >> profits ( k + 1 , vector < int > ( prices . size (), 0 )); // DP table for ( int t = 1 ; t <= k ; t ++ ) { for ( int d = 1 ; d < prices . size (); d ++ ) { int maxi = 0 ; for ( int i = d -1 ; i >= 0 ; i -- ) { maxi = max ( maxi , ( prices [ d ] - prices [ i ] + profits [ t -1 ][ i ]) ); } profits [ t ][ d ] = max ( profits [ t ][ d -1 ], maxi ); } } return profits [ k ][ prices . size () -1 ]; } Time : O ( nk ) Space : O ( nk ) int maxProfitWithKTransactions ( vector < int > prices , int k ) { if ( prices . size () == 0 or k == 0 ) return 0 ; vector < vector < int >> profits ( k + 1 , vector < int > ( prices . size (), 0 )); // DP table for ( int t = 1 ; t <= k ; t ++ ) { int maxSoFar = INT_MIN ; for ( int d = 1 ; d < prices . size (); d ++ ) { maxSoFar = max ( maxSoFar , profits [ t -1 ][ d -1 ] - prices [ d -1 ]); profits [ t ][ d ] = max ( profits [ t ][ d -1 ], maxSoFar + prices [ d ]); } } return profits [ k ][ prices . size () -1 ]; }","title":"Stock Buy and Sell"},{"location":"CompCoding/Hard/sdesheet/#leetcode-56-merge-intervals","text":"vector < Interval > merge ( vector < Interval >& ins ) { if ( ins . empty ()) return vector < Interval > {}; vector < Interval > res ; sort ( ins . begin (), ins . end (), []( Interval a , Interval b ){ return a . start < b . start ;}); res . push_back ( ins [ 0 ]); for ( int i = 1 ; i < ins . size (); i ++ ) { if ( res . back (). end < ins [ i ]. start ) res . push_back ( ins [ i ]); else res . back (). end = max ( res . back (). end , ins [ i ]. end ); } return res ; } Similar questions: 252 Meeting Rooms 253 Meeting Rooms II 435 Non-overlapping Intervals","title":"Leetcode 56: Merge Intervals"},{"location":"CompCoding/Hard/sdesheet/#leetcode-88-merge-sorted-array-without-extra-space","text":"E.g: Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int i = m - 1 , j = n - 1 , tar = m + n - 1 ; while ( j >= 0 ) { nums1 [ tar -- ] = i >= 0 && nums1 [ i ] > nums2 [ j ] ? nums1 [ i -- ] : nums2 [ j -- ]; } } };","title":"Leetcode 88: Merge Sorted Array without extra space"},{"location":"CompCoding/Hard/sdesheet/#leetcode-287-find-the-duplicate-number","text":"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. Input: nums = [1,3,4,2,2] Output: 2 Approach 1: Sort and iterate through the vector. Approach 2: Keep frequency map where you maintain which number has already occurred. Time = O(N) Space = O(N) Approach 3: Given problem is converted to linked list using array index and value. This is possible because input is in range [1,n] E.g.: Given example input converted to linked list: 0->1->3->2->4->2 Use two pointers the fast and the slow. The fast one goes forward two steps each time, while the slow one goes only step each time. They must meet the same item when slow==fast. In fact, they meet in a circle, the duplicate number must be the entry point of the circle when visiting the array from nums[0]. Next we just need to find the entry point. We use a point(we can use the fast one before) to visit form begining with one step each time, do the same job to slow. When fast==slow, they meet at the entry point of the circle. Time = O(N) Space = O(1) int findDuplicate3 ( vector < int >& nums ) { if ( nums . size () > 1 ) { int slow = nums [ 0 ]; int fast = nums [ nums [ 0 ]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } fast = 0 ; while ( fast != slow ) { fast = nums [ fast ]; slow = nums [ slow ]; } return slow ; } return -1 ; }","title":"Leetcode 287: Find the Duplicate Number"},{"location":"CompCoding/Hard/sdesheet/#leetcode-493-reverse-pairs","text":"//My written code class Solution { public : int count = 0 ; void merge ( vector < int >& nums , int left , int mid , int right ) { vector < int > tmp ; int i = left ; int j = mid + 1 ; for (; i <= mid ; i ++ ) { while ( j <= right && nums [ i ] > ( long ) 2 * nums [ j ]) { j ++ ; } count += j - mid -1 ; } //For code simplicity you can directly sort using std::sort(nums.begin()+left, nums.end()+right) //Merging int p = left ; int q = mid + 1 ; while ( p <= mid && q <= right ) { if ( nums [ p ] < nums [ q ]){ tmp . push_back ( nums [ p ]); p ++ ; } else { tmp . push_back ( nums [ q ]); q ++ ; } } //Remaining Elements while ( p <= mid ) { tmp . push_back ( nums [ p ]); p ++ ; } while ( q <= right ) { tmp . push_back ( nums [ q ]); q ++ ; } for ( int r = left ; r <= right ; r ++ ) { nums [ r ] = tmp [ r - left ]; } } void mergeSort ( vector < int >& nums , int left , int right ) { if ( left < right ) { int mid = ( right + left ) / 2 ; mergeSort ( nums , left , mid ); mergeSort ( nums , mid + 1 , right ); merge ( nums , left , mid , right ); } } int reversePairs ( vector < int >& nums ) { mergeSort ( nums , 0 , nums . size () -1 ); return count ; } };","title":"Leetcode 493. Reverse Pairs"},{"location":"CompCoding/Hard/sdesheet/#leetcode-169-majority-element","text":"Boyer Moore Voting Algorithm: This algorithm works on the fact that if an element occurs more than N/2 times, it means that the remaining elements other than this would definitely be less than N/2. So let us check the proceeding of the algorithm. First, choose a candidate from the given set of elements if it is the same as the candidate element, increase the votes. Otherwise, decrease the votes if votes become 0, select another new element as the new candidate. Leetcode Nice Explanation with Pictures class Solution { public : int majorityElement ( vector < int >& nums ) { int count = 0 ; int candidate = 0 ; for ( int num : nums ) { if ( count == 0 ) { candidate = num ; } if ( num == candidate ) count += 1 ; else count -= 1 ; } return candidate ; } };","title":"Leetcode 169: Majority Element"},{"location":"CompCoding/Hard/sdesheet/#leetcode-229-majority-element-ii-n3","text":"This is similar to N/2 Leetcode Explanation class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { int sz = nums . size (); int num1 = -1 , num2 = -1 , count1 = 0 , count2 = 0 , i ; for ( i = 0 ; i < sz ; i ++ ) { if ( nums [ i ] == num1 ) count1 ++ ; else if ( nums [ i ] == num2 ) count2 ++ ; else if ( count1 == 0 ) { num1 = nums [ i ]; count1 = 1 ; } else if ( count2 == 0 ) { num2 = nums [ i ]; count2 = 1 ; } else { count1 -- ; count2 -- ; } } vector < int > ans ; count1 = count2 = 0 ; for ( i = 0 ; i < sz ; i ++ ) { if ( nums [ i ] == num1 ) count1 ++ ; else if ( nums [ i ] == num2 ) count2 ++ ; } if ( count1 > sz / 3 ) ans . push_back ( num1 ); if ( count2 > sz / 3 ) ans . push_back ( num2 ); return ans ; } };","title":"Leetcode 229: Majority Element II (N/3)"},{"location":"CompCoding/Hard/sdesheet/#leetcode-128-longest-consecutive-sequence","text":"Store given array in hashset or hashmap. Solution 1 : check consecutive elements lesser,greater than current element and delete them if present. Update max len. Solution 2 : check current element - 1 in hashset, if present then ignore current. Start counting consecutive only when curr-1 is not present. class Solution { public : int longestConsecutive ( vector < int >& nums ) { unordered_set < int > hashset ( nums . begin (), nums . end ()); int maxlen = 0 ; for ( int n : nums ) { if ( hashset . find ( n ) != hashset . end ()) { int prev = n -1 ; int next = n + 1 ; while ( hashset . find ( prev ) != hashset . end ()) hashset . erase ( prev -- ); while ( hashset . find ( next ) != hashset . end ()) hashset . erase ( next ++ ); maxlen = max ( maxlen , next - prev -1 ); } } return maxlen ; } }; class Solution { public : int longestConsecutive ( vector < int >& nums ) { set < int > hashSet ; for ( int num : nums ) { hashSet . insert ( num ); } int longestStreak = 0 ; for ( int num : nums ) { if ( ! hashSet . count ( num -1 )) { int currentNum = num ; int currentStreak = 1 ; while ( hashSet . count ( currentNum + 1 )) { currentNum += 1 ; currentStreak += 1 ; } longestStreak = max ( longestStreak , currentStreak ); } } return longestStreak ; } };","title":"Leetcode 128: Longest Consecutive Sequence"},{"location":"CompCoding/Hard/sdesheet/#length-of-largest-subarray-with-0-sum","text":"Given an array having both positive and negative integers. The task is to compute the length of the largest subarray with sum 0. Idea is to create a prefix sum array and run loop over prefix sum array and keep updating prefix sum in map. Don't update if already present. int maxLen ( int A [], int n ) { unordered_map < int , int > mpp ; int maxi = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += A [ i ]; if ( sum == 0 ) { maxi = i + 1 ; } else { if ( mpp . find ( sum ) != mpp . end ()) { maxi = max ( maxi , i - mpp [ sum ]); } else { mpp [ sum ] = i ; } } } return maxi ; }","title":"Length of largest subarray with 0 sum"},{"location":"CompCoding/Hard/sdesheet/#leetcode-3-longest-substring-without-repeat","text":"Similar to sliding window while maintaining set of characters present in window. class Solution { public : int lengthOfLongestSubstring ( string s ) { int left = 0 , right = 0 ; set < char > st ; int n = s . size (); int len = 0 ; while ( right < n ) { if ( st . find ( s [ right ]) != st . end ()) { st . erase ( s [ left ]); left ++ ; } else { st . insert ( s [ right ]); len = max ( len , right - left + 1 ); right ++ ; } } return len ; } };","title":"Leetcode 3: Longest Substring without repeat"},{"location":"CompCoding/Hard/sdesheet/#leetcode-496-next-greater-element-i","text":"//self written //Storing value on stack and iterating from end (Simple) class Solution { public : vector < int > nextGreaterElement ( vector < int >& nums1 , vector < int >& nums2 ) { stack < int > st ; map < int , int > hash ; for ( int i = nums2 . size () -1 ; i >= 0 ; i -- ) { while ( ! st . empty () && st . top () < nums2 [ i ]) { st . pop (); } if ( st . empty ()) { hash [ nums2 [ i ]] = -1 ; } else { hash [ nums2 [ i ]] = st . top (); } st . push ( nums2 [ i ]); } vector < int > res ; for ( auto i : nums1 ){ res . push_back ( hash [ i ]); } return res ; } }; //Storing value on stack, iterating from start class Solution { public : vector < int > nextGreaterElement ( vector < int >& findNums , vector < int >& nums ) { stack < int > st ; unordered_map < int , int > hash ; for ( int n : nums ) { while ( st . size () && st . top () < n ) { hash [ st . top ()] = n ; st . pop (); } st . push ( n ); } vector < int > ans ; for ( int n : findNums ) ans . push_back ( hash . count ( n ) ? hash [ n ] : -1 ); return ans ; } };","title":"Leetcode 496. Next Greater Element I"},{"location":"CompCoding/Hard/sdesheet/#leetcode-503-next-greater-element-ii","text":"Simple but difficult to find. //Storing index on stack and iterating from start vector < int > nextGreaterElements ( vector < int >& A ) { int n = A . size (); vector < int > stack , res ( n , -1 ); for ( int i = 0 ; i < n * 2 ; ++ i ) { while ( stack . size () && A [ stack . back ()] < A [ i % n ]) { res [ stack . back ()] = A [ i % n ]; stack . pop_back (); } stack . push_back ( i % n ); } return res ; }","title":"Leetcode 503. Next Greater Element II"},{"location":"CompCoding/Hard/sdesheet/#leetcode-26-remove-duplicates-from-sorted-array","text":"class Solution { public : int removeDuplicates ( vector < int >& nums ) { int j = 0 ; for ( int i = 1 ; i < nums . size (); i ++ ) { if ( nums [ i ] != nums [ i -1 ]) { j ++ ; nums [ j ] = nums [ i ]; } } return j + 1 ; } };","title":"Leetcode 26. Remove Duplicates from Sorted Array"},{"location":"CompCoding/Hard/sdesheet/#_1","text":"","title":""},{"location":"CompCoding/Hard/sdesheet/#leetcode-42-trapping-rain-water","text":"//Simple solution class Solution { public : int trap ( vector < int >& height ) { vector < int > st ( height . size ()); int maxi = 0 ; for ( int i = height . size () -1 ; i >= 0 ; i -- ) { maxi = max ( height [ i ], maxi ); st [ i ] = maxi ; } vector < int > fin ( height . size ()); maxi = 0 ; for ( int i = 0 ; i < height . size (); i ++ ) { maxi = max ( height [ i ], maxi ); fin [ i ] = maxi ; } int ans = 0 ; for ( int i = 1 ; i < height . size () -1 ; i ++ ) { ans += min ( st [ i ], fin [ i ]) - height [ i ]; } return ans ; } }; //Efficient 2 pointers approach (Very difficult to understand) 3 1 2 4 0 1 3 2 3 3 3 4 4 4 4 4 - rmax 4 4 4 4 3 3 3 2 - lmax /* We keep modifying pointers(left/right) until we find current max(right) If arr[left] <= arr[right], this means that arr[right] is the max value found so far on right. This also means that maxLeft will be less than or equal to arr[right], which means that maxLeft will be bounding the addition to the answer(res variable, in this solution), since it has be less than or equal to arr[right] e, so we dont have to consider maxRight when adding to the counter. If arr[left] > arr[right] , this means at arr[left] is the max value found so far on left. Same thing applies as explained in the paragraph above. */ class Solution { public : int trap ( int A [], int n ) { int left = 0 ; int right = n -1 ; int res = 0 ; int maxleft = 0 , maxright = 0 ; while ( left <= right ){ if ( A [ left ] <= A [ right ]){ if ( A [ left ] >= maxleft ) maxleft = A [ left ]; else res += maxleft - A [ left ]; left ++ ; } else { if ( A [ right ] >= maxright ) maxright = A [ right ]; else res += maxright - A [ right ]; right -- ; } } return res ; } };","title":"Leetcode 42. Trapping Rain Water"},{"location":"CompCoding/Hard/string/","text":"String matching using polynomial rolling hash Calculate hash(text) and hash(pattern) hash(s) = p^0 * s[0] + p^1 * s[1] + p^2 * s[2] + p^3 * s[3] + p^4 * s[4] ... Here you can directly divide by P^2. So you need modulo multiplicative inverse. #include <bits/stdc++.h> #define REP(i,n) for (int i = 1; i <= n; i++) #define mod 1000000007 #define pb push_back #define ff first #define ss second #define ii pair<int,int> #define vi vector<int> #define vii vector<ii> #define lli long long int #define INF 1000000000 #define endl '\\n' const double PI = 3.141592653589793238460 ; typedef std :: complex < double > Complex ; typedef std :: valarray < Complex > CArray ; using namespace std ; lli dp [ 1000001 ]; lli inv [ 1000001 ]; lli power ( lli a , lli n ) { lli result = 1 ; while ( n ) { if ( n & 1 ) result = ( result * a ) % mod ; n >>= 1 ; a = ( a * a ) % mod ; } return result ; } void init ( string input_string ) { lli p = 31 ; lli p_power = 1 ; inv [ 0 ] = 1 ; dp [ 0 ] = ( input_string [ 0 ] - 'a' + 1 ); for ( int i = 1 ; i < input_string . size (); i ++ ) { char ch = input_string [ i ]; p_power = ( p_power * p ) % mod ; inv [ i ] = power ( p_power , mod - 2 ); dp [ i ] = ( dp [ i -1 ] + ( ch - 'a' + 1 ) * p_power ) % mod ; } } lli substringHash ( int L , int R ) { int result = dp [ R ]; if ( L > 0 ) result -= dp [ L -1 ]; result = ( result * inv [ L ]) % mod ; return result ; } int main () { string input_string ; int tc , L , R ; cin >> input_string ; init ( input_string ); cin >> tc ; REP ( i , tc ) { cin >> L >> R ; cout << substringHash ( L , R ) << endl ; } } String matching using Rabin Karp Same as above but no need to calculate modulo inverse. pattern * p^L = hash[r] - hash[l-1] String matching using Z function https://youtu.be/hDKTCWWGIxk?list=PL2q4fbVm1Ik6ThrYKCzgEpmaS_XWDGHjx&t=580 https://cp-algorithms.com/string/z-function.html vector < int > z_function ( string s ) { int n = ( int ) s . length (); vector < int > z ( n ); for ( int i = 1 , l = 0 , r = 0 ; i < n ; ++ i ) { //i<=r means that there was a segment match whose right pointer is to the right of i //So we can take headstart by peeking value from z[i-l] if ( i <= r ) z [ i ] = min ( r - i + 1 , z [ i - l ]); //r-i+1 is the boundary condition //i+z[i]<n is boundary condition. Calculate z[] for e.g. a a a a a a a while ( i + z [ i ] < n && s [ z [ i ]] == s [ i + z [ i ]]) ++ z [ i ]; //z[i] = Length of matching prefix from //Update l and r only if there is new rightmost segment match if ( i + z [ i ] - 1 > r ) l = i , r = i + z [ i ] - 1 ; } return z ; } String matching using KMP https://www.youtube.com/watch?v=4jY57Ehc14Y vector < int > prefix_function ( string s ) { int n = ( int ) s . length (); vector < int > LPS ( n ); for ( int i = 1 ; i < n ; i ++ ) { int j = LPS [ i -1 ]; while ( j > 0 && s [ i ] != s [ j ]) j = LPS [ j -1 ]; if ( s [ i ] == s [ j ]) j ++ ; LPS [ i ] = j ; } return LPS ; } //self written function for LPS vector < int > computeLPS ( string needle ) { int i = 1 ; int len = 0 ; vector < int > lps ( needle . size (), 0 ); lps [ 0 ] = 0 ; while ( i < needle . size ()) { if ( needle [ i ] == needle [ len ]) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len -1 ]; //headstart: lps of previous element else { lps [ i ] = 0 ; i ++ ; } } } return lps ; } int strStr ( string haystack , string needle ) { vector < int > lps ; if ( needle . size () == 0 ) return 0 ; lps = computeLPS ( needle ); int i = 0 , j = 0 ; while ( i < haystack . size ()) { if ( haystack [ i ] == needle [ j ]) { i ++ ; j ++ ; } else { if ( j != 0 ) { //Few chars have matched in current segment //We can take headstart from LPS j = lps [ j -1 ]; } else { //since first char of segment doesn't match, just increment i i ++ ; } } if ( j == needle . length ()) { //j = lps[j-1]; //in case you want all the occurrences return i - j ; } } return -1 ; }","title":"Strings"},{"location":"CompCoding/Hard/string/#string-matching-using-polynomial-rolling-hash","text":"Calculate hash(text) and hash(pattern) hash(s) = p^0 * s[0] + p^1 * s[1] + p^2 * s[2] + p^3 * s[3] + p^4 * s[4] ... Here you can directly divide by P^2. So you need modulo multiplicative inverse. #include <bits/stdc++.h> #define REP(i,n) for (int i = 1; i <= n; i++) #define mod 1000000007 #define pb push_back #define ff first #define ss second #define ii pair<int,int> #define vi vector<int> #define vii vector<ii> #define lli long long int #define INF 1000000000 #define endl '\\n' const double PI = 3.141592653589793238460 ; typedef std :: complex < double > Complex ; typedef std :: valarray < Complex > CArray ; using namespace std ; lli dp [ 1000001 ]; lli inv [ 1000001 ]; lli power ( lli a , lli n ) { lli result = 1 ; while ( n ) { if ( n & 1 ) result = ( result * a ) % mod ; n >>= 1 ; a = ( a * a ) % mod ; } return result ; } void init ( string input_string ) { lli p = 31 ; lli p_power = 1 ; inv [ 0 ] = 1 ; dp [ 0 ] = ( input_string [ 0 ] - 'a' + 1 ); for ( int i = 1 ; i < input_string . size (); i ++ ) { char ch = input_string [ i ]; p_power = ( p_power * p ) % mod ; inv [ i ] = power ( p_power , mod - 2 ); dp [ i ] = ( dp [ i -1 ] + ( ch - 'a' + 1 ) * p_power ) % mod ; } } lli substringHash ( int L , int R ) { int result = dp [ R ]; if ( L > 0 ) result -= dp [ L -1 ]; result = ( result * inv [ L ]) % mod ; return result ; } int main () { string input_string ; int tc , L , R ; cin >> input_string ; init ( input_string ); cin >> tc ; REP ( i , tc ) { cin >> L >> R ; cout << substringHash ( L , R ) << endl ; } }","title":"String matching using polynomial rolling hash"},{"location":"CompCoding/Hard/string/#string-matching-using-rabin-karp","text":"Same as above but no need to calculate modulo inverse. pattern * p^L = hash[r] - hash[l-1]","title":"String matching using Rabin Karp"},{"location":"CompCoding/Hard/string/#string-matching-using-z-function","text":"https://youtu.be/hDKTCWWGIxk?list=PL2q4fbVm1Ik6ThrYKCzgEpmaS_XWDGHjx&t=580 https://cp-algorithms.com/string/z-function.html vector < int > z_function ( string s ) { int n = ( int ) s . length (); vector < int > z ( n ); for ( int i = 1 , l = 0 , r = 0 ; i < n ; ++ i ) { //i<=r means that there was a segment match whose right pointer is to the right of i //So we can take headstart by peeking value from z[i-l] if ( i <= r ) z [ i ] = min ( r - i + 1 , z [ i - l ]); //r-i+1 is the boundary condition //i+z[i]<n is boundary condition. Calculate z[] for e.g. a a a a a a a while ( i + z [ i ] < n && s [ z [ i ]] == s [ i + z [ i ]]) ++ z [ i ]; //z[i] = Length of matching prefix from //Update l and r only if there is new rightmost segment match if ( i + z [ i ] - 1 > r ) l = i , r = i + z [ i ] - 1 ; } return z ; }","title":"String matching using Z function"},{"location":"CompCoding/Hard/string/#string-matching-using-kmp","text":"https://www.youtube.com/watch?v=4jY57Ehc14Y vector < int > prefix_function ( string s ) { int n = ( int ) s . length (); vector < int > LPS ( n ); for ( int i = 1 ; i < n ; i ++ ) { int j = LPS [ i -1 ]; while ( j > 0 && s [ i ] != s [ j ]) j = LPS [ j -1 ]; if ( s [ i ] == s [ j ]) j ++ ; LPS [ i ] = j ; } return LPS ; } //self written function for LPS vector < int > computeLPS ( string needle ) { int i = 1 ; int len = 0 ; vector < int > lps ( needle . size (), 0 ); lps [ 0 ] = 0 ; while ( i < needle . size ()) { if ( needle [ i ] == needle [ len ]) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len -1 ]; //headstart: lps of previous element else { lps [ i ] = 0 ; i ++ ; } } } return lps ; } int strStr ( string haystack , string needle ) { vector < int > lps ; if ( needle . size () == 0 ) return 0 ; lps = computeLPS ( needle ); int i = 0 , j = 0 ; while ( i < haystack . size ()) { if ( haystack [ i ] == needle [ j ]) { i ++ ; j ++ ; } else { if ( j != 0 ) { //Few chars have matched in current segment //We can take headstart from LPS j = lps [ j -1 ]; } else { //since first char of segment doesn't match, just increment i i ++ ; } } if ( j == needle . length ()) { //j = lps[j-1]; //in case you want all the occurrences return i - j ; } } return -1 ; }","title":"String matching using KMP"},{"location":"CompCoding/Hard/tree/","text":"L21 Vertical order traversal answer storage -> map <vertical_level, map > queue -> (node*, vertical, level(horizontal) ) You can do any of inorder, preorder, postorder traversal with above structure. class Solution { public : vector < vector < int >> verticalTraversal ( TreeNode * root ) { map < int , map < int , multiset < int >>> nodes ; queue < pair < TreeNode * , pair < int , int >>> todo ; todo . push ({ root , { 0 , 0 }}); while ( ! todo . empty ()) { auto p = todo . front (); todo . pop (); TreeNode * node = p . first ; int x = p . second . first , y = p . second . second ; nodes [ x ][ y ]. insert ( node -> val ); if ( node -> left ) { todo . push ({ node -> left , { x - 1 , y + 1 }}); } if ( node -> right ) { todo . push ({ node -> right , { x + 1 , y + 1 }}); } } vector < vector < int >> ans ; for ( auto p : nodes ) { vector < int > col ; for ( auto q : p . second ) { col . insert ( col . end (), q . second . begin (), q . second . end ()); } ans . push_back ( col ); } return ans ; } }; L22 Top view of binary tree Based on above vertical order traversal. Keep storage as just map< vertical, int > as we just need first element from top for that vertical. class Solution { public : //Function to return a list of nodes visible from the top view //from left to right in Binary Tree. vector < int > topView ( Node * root ) { vector < int > ans ; if ( root == NULL ) return ans ; map < int , int > mpp ; queue < pair < Node * , int >> q ; q . push ({ root , 0 }); while ( ! q . empty ()) { auto it = q . front (); q . pop (); Node * node = it . first ; int line = it . second ; if ( mpp . find ( line ) == mpp . end ()) mpp [ line ] = node -> data ; if ( node -> left != NULL ) { q . push ({ node -> left , line -1 }); } if ( node -> right != NULL ) { q . push ({ node -> right , line + 1 }); } } for ( auto it : mpp ) { ans . push_back ( it . second ); } return ans ; } }; L23: Bottom view of tree Same as above only difference is that we keep updating map even if it is already filled as we need last node from that line. class Solution { public : vector < int > bottomView ( Node * root ) { vector < int > ans ; if ( root == NULL ) return ans ; map < int , int > mpp ; queue < pair < Node * , int >> q ; q . push ({ root , 0 }); while ( ! q . empty ()) { auto it = q . front (); q . pop (); Node * node = it . first ; int line = it . second ; mpp [ line ] = node -> data ; if ( node -> left != NULL ) { q . push ({ node -> left , line -1 }); } if ( node -> right != NULL ) { q . push ({ node -> right , line + 1 }); } } for ( auto it : mpp ) { ans . push_back ( it . second ); } return ans ; } }; L24 : Left/Right view of binary tree Left view : root, left, right recursive traversal while maintaining level Right view : root, right, left recursive traversal while maintaining level //Right view: class Solution { public : void recursion ( TreeNode * root , int level , vector < int > & res ) { if ( root == NULL ) return ; if ( res . size () == level ) { //Not updating result for level if already updated i.e. res.size() == level res . push_back ( root -> val ); } recursion ( root -> right , level + 1 , res ); recursion ( root -> left , level + 1 , res ); } vector < int > rightSideView ( TreeNode * root ) { vector < int > res ; recursion ( root , 0 , res ); return res ; } }; L25: Symmetric Binary tree Symmetric Tree: Consider it as mirror of left half. 1 2 2 3 4 4 3 class Solution { public : bool f ( TreeNode * root1 , TreeNode * root2 ) { if ( ! root1 ) return ! root2 ; if ( ! root2 ) return ! root1 ; return ( root1 -> val == root2 -> val ) && f ( root1 -> left , root2 -> right ) && f ( root1 -> right , root2 -> left ); } bool isSymmetric ( TreeNode * root ) { if ( ! root ) return true ; return f ( root -> left , root -> right ); } }; L26: Print Root to Node path in Binary tree Keeping vector reference and adding node values while traversing and removing values if value not found (backtracking) bool getPath ( TreeNode * root , vector < int > & arr , int x ) { // if root is NULL // there is no path if ( ! root ) return false ; // push the node's value in 'arr' arr . push_back ( root -> val ); // if it is the required node // return true if ( root -> val == x ) return true ; // else check whether the required node lies // in the left subtree or right subtree of // the current node if ( getPath ( root -> left , arr , x ) || getPath ( root -> right , arr , x )) return true ; // required node does not lie either in the // left or right subtree of the current node // Thus, remove current node's value from // 'arr'and then return false arr . pop_back (); return false ; } vector < int > Solution :: solve ( TreeNode * A , int B ) { vector < int > arr ; if ( A == NULL ) { return arr ; } getPath ( A , arr , B ); return arr ; } L27: Lowest Common Ancestor in Binary Tree Naive: One way could be to print path for both nodes using above function. And find last common node in both results. But that will use extra result. Recursive: class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { //base case if ( root == NULL || root == p || root == q ) { return root ; } TreeNode * left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * right = lowestCommonAncestor ( root -> right , p , q ); //result if ( left == NULL ) { return right ; } else if ( right == NULL ) { return left ; } else { //both left and right are not null, we found our result return root ; } } }; LCA in BST Note: Previous question was binary tree and this question is binary search tree. If both p and q values are less than cur value, then recursively search in right. If both p and q values are greater than cur value, then recursively search in left. Else cur node is the LCA. class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root ) return NULL ; int curr = root -> val ; if ( curr < p -> val && curr < q -> val ) { return lowestCommonAncestor ( root -> right , p , q ); } if ( curr > p -> val && curr > q -> val ) { return lowestCommonAncestor ( root -> left , p , q ); } return root ; } }; L28: Maximum Width of binary tree The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. Indexing of nodes is important here. It is possible that few nodes in the middle part can be missing but still width is last - first + 1. 1 1 2 3 1 2 4 5 6 7 1 2 3 4 8 9 10 11 12 13 14 15 1 2 3 4 5 6 7 8 class Solution { public : int widthOfBinaryTree ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < pair < TreeNode * , int >> q ; q . push ({ root , 0 }); while ( ! q . empty ()){ int size = q . size (); int mmin = q . front (). second ; //to make the id starting from zero int first , last ; for ( int i = 0 ; i < size ; i ++ ){ int cur_id = q . front (). second - mmin ; //to start with index with 0 TreeNode * node = q . front (). first ; q . pop (); if ( i == 0 ) first = cur_id ; if ( i == size -1 ) last = cur_id ; if ( node -> left ) q . push ({ node -> left , cur_id * 2 + 1 }); if ( node -> right ) q . push ({ node -> right , cur_id * 2 + 2 }); } ans = max ( ans , last - first + 1 ); } return ans ; } }; L29: Children Sum Property in Binary Tree For any node, value should be equivalent to left + right. Allowed to increment any node by +1 any no of times. 2 -> 45 35 10 35 10 2 3 5 2 30 5 8 2 If sum of children is greater than root, then change root = sum of children else change both children to root. void reorder ( BinaryTreeNode < int > * root ) { if ( root == NULL ) return ; int child = 0 ; if ( root -> left ) { child += root -> left -> data ; } if ( root -> right ) { child += root -> right -> data ; } if ( child >= root -> data ) root -> data = child ; else { if ( root -> left ) root -> left -> data = root -> data ; else if ( root -> right ) root -> right -> data = root -> data ; } reorder ( root -> left ); reorder ( root -> right ); int tot = 0 ; if ( root -> left ) tot += root -> left -> data ; if ( root -> right ) tot += root -> right -> data ; if ( root -> left or root -> right ) root -> data = tot ; } void changeTree ( BinaryTreeNode < int > * root ) { reorder ( root ); } Print all nodes at a distance of K in Binary Tree First mark parent pointers in a map using BFS. Do radial BFS traversal from given node. 1. Keep visited map. 2. Radially visiting -> Visit parent, left, right class Solution { void markParents ( TreeNode * root , unordered_map < TreeNode * , TreeNode *> & parent_track , TreeNode * target ) { queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { TreeNode * current = queue . front (); queue . pop (); if ( current -> left ) { parent_track [ current -> left ] = current ; queue . push ( current -> left ); } if ( current -> right ) { parent_track [ current -> right ] = current ; queue . push ( current -> right ); } } } public : vector < int > distanceK ( TreeNode * root , TreeNode * target , int k ) { unordered_map < TreeNode * , TreeNode *> parent_track ; // node -> parent markParents ( root , parent_track , target ); unordered_map < TreeNode * , bool > visited ; queue < TreeNode *> queue ; queue . push ( target ); visited [ target ] = true ; int curr_level = 0 ; while ( ! queue . empty ()) { /*Second BFS to go upto K level from target node and using our hashtable info*/ int size = queue . size (); if ( curr_level ++ == k ) break ; for ( int i = 0 ; i < size ; i ++ ) { TreeNode * current = queue . front (); queue . pop (); if ( current -> left && ! visited [ current -> left ]) { queue . push ( current -> left ); visited [ current -> left ] = true ; } if ( current -> right && ! visited [ current -> right ]) { queue . push ( current -> right ); visited [ current -> right ] = true ; } if ( parent_track [ current ] && ! visited [ parent_track [ current ]]) { queue . push ( parent_track [ current ]); visited [ parent_track [ current ]] = true ; } } } vector < int > result ; while ( ! queue . empty ()) { TreeNode * current = queue . front (); queue . pop (); result . push_back ( current -> val ); } return result ; } }; L31: Minimum time taken to BURN the Binary Tree from a Node This is similar to above question to print nodes at distance K from given node. Here only difference is to find max length from given node. In previous question, we did radial bfs traversal for K length and break out of loop after k but in current question we need to keep going until all nodes are traversed and increment time(maxi) only if we are burning some node. #include <bits/stdc++.h> int findMaxDistance ( map < BinaryTreeNode < int >* , BinaryTreeNode < int >*> & mpp , BinaryTreeNode < int >* target ) { queue < BinaryTreeNode < int >*> q ; q . push ( target ); map < BinaryTreeNode < int >* , int > vis ; vis [ target ] = 1 ; int maxi = 0 ; while ( ! q . empty ()) { int sz = q . size (); int fl = 0 ; //Flag to indicate that at least 1 node is burnt in this level for ( int i = 0 ; i < sz ; i ++ ) { auto node = q . front (); q . pop (); if ( node -> left && ! vis [ node -> left ]) { fl = 1 ; vis [ node -> left ] = 1 ; q . push ( node -> left ); } if ( node -> right && ! vis [ node -> right ]) { fl = 1 ; vis [ node -> right ] = 1 ; q . push ( node -> right ); } if ( mpp [ node ] && ! vis [ mpp [ node ]]) { fl = 1 ; vis [ mpp [ node ]] = 1 ; q . push ( mpp [ node ]); } } if ( fl ) maxi ++ ; } return maxi ; } BinaryTreeNode < int >* bfsToMapParents ( BinaryTreeNode < int >* root , map < BinaryTreeNode < int >* , BinaryTreeNode < int >*> & mpp , int start ) { queue < BinaryTreeNode < int >*> q ; q . push ( root ); BinaryTreeNode < int >* res ; while ( ! q . empty ()) { BinaryTreeNode < int >* node = q . front (); if ( node -> data == start ) res = node ; q . pop (); if ( node -> left ) { mpp [ node -> left ] = node ; q . push ( node -> left ); } if ( node -> right ) { mpp [ node -> right ] = node ; q . push ( node -> right ); } } return res ; } int timeToBurnTree ( BinaryTreeNode < int >* root , int start ) { map < BinaryTreeNode < int >* , BinaryTreeNode < int >*> mpp ; BinaryTreeNode < int >* target = bfsToMapParents ( root , mpp , start ); int maxi = findMaxDistance ( mpp , target ); return maxi ; } L32: Count total node in a balanced binary tree Following is a balanced binary tree but not a complete binary tree. If left height == right height i.e. If complete binary tree then no of nodes = 2^h - 1 1 2 3 4 5 6 7 8 9 10 11 Time complexity = (lg N)^2 class Solution { public : int countNodes ( TreeNode * root ) { if ( root == NULL ) return 0 ; int lh = findHeightLeft ( root ); int rh = findHeightRight ( root ); if ( lh == rh ) return ( 1 << lh ) - 1 ; return 1 + countNodes ( root -> left ) + countNodes ( root -> right ); } int findHeightLeft ( TreeNode * node ) { int hght = 0 ; while ( node ) { hght ++ ; node = node -> left ; } return hght ; } int findHeightRight ( TreeNode * node ) { int hght = 0 ; while ( node ) { hght ++ ; node = node -> right ; } return hght ; } }; L34: Construct a Binary Tree from Preorder and Inorder traversal Note that inorder traversal is very important to reconstruct a unique tree as it gives exact position of root in pre or post order and then only we know what is left part and right part of unique tree. Steps: Put complete inorder traversal in hash map i.e. inMap. This helps in finding location of root in inorder. And we can recursively call buildTree for left part and right part. class Solution { private : TreeNode * buildTree ( vector < int >& preorder , int preStart , int preEnd , vector < int >& inorder , int inStart , int inEnd , map < int , int > & inMap ) { if ( preStart > preEnd || inStart > inEnd ) return NULL ; TreeNode * root = new TreeNode ( preorder [ preStart ]); int inRoot = inMap [ root -> val ]; int numsLeft = inRoot - inStart ; root -> left = buildTree ( preorder , preStart + 1 , preStart + numsLeft , inorder , inStart , inRoot - 1 , inMap ); root -> right = buildTree ( preorder , preStart + numsLeft + 1 , preEnd , inorder , inRoot + 1 , inEnd , inMap ); return root ; } public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { map < int , int > inMap ; for ( int i = 0 ; i < inorder . size (); i ++ ) { inMap [ inorder [ i ]] = i ; } TreeNode * root = buildTree ( preorder , 0 , preorder . size () - 1 , inorder , 0 , inorder . size () - 1 , inMap ); return root ; } }; L35: Construct binary tree from post order and inorder traversal This is similar to above question. In preorder first node is the root, in postorder last node is the root. //Modify above code and construct class Solution { public : TreeNode * buildTree ( vector < int >& postorder , vector < int >& inorder ) { map < int , int > inMap ; for ( int i = 0 ; i < inorder . size (); i ++ ) { inMap [ inorder [ i ]] = i ; } TreeNode * root = buildTree ( preorder , 0 , postorder . size () - 1 , inorder , 0 , inorder . size () - 1 , inMap ); return root ; } TreeNode * buildTree ( vector < int >& postorder , int postStart , int postEnd , vector < int >& inorder , int inStart , int inEnd , map < int , int > & inMap ) { if ( preStart > preEnd || inStart > inEnd ) return NULL ; TreeNode * root = new TreeNode ( postorder [ postEnd ]); int inRoot = inMap [ root -> val ]; int numsLeft = inRoot - inStart ; root -> left = buildTree ( postorder , postStart , preStart + numsLeft - 1 , inorder , inStart , inRoot - 1 , inMap ); root -> right = buildTree ( postorder , postStart + numsLeft , postEnd - 1 , inorder , inRoot + 1 , inEnd , inMap ); return root ; } }; L36: Leetcode 297: Serialize and deserialise a binary tree You can use any traversal, not necessarily preorder traversal. Need to add indicator(delimiter) for null pointers in preorder traversal. //Following implementation is using BFS: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public : // Encodes a tree to a single string. string serialize ( TreeNode * root ) { if ( ! root ) return \"\" ; string s = \"\" ; queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { TreeNode * curNode = q . front (); q . pop (); if ( curNode == NULL ) s . append ( \"#,\" ); else s . append ( to_string ( curNode -> val ) + ',' ); if ( curNode != NULL ){ q . push ( curNode -> left ); q . push ( curNode -> right ); } } return s ; } // Decodes your encoded data to tree. TreeNode * deserialize ( string data ) { if ( data . size () == 0 ) return NULL ; stringstream s ( data ); string str ; getline ( s , str , ',' ); TreeNode * root = new TreeNode ( stoi ( str )); queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { TreeNode * node = q . front (); q . pop (); getline ( s , str , ',' ); if ( str == \"#\" ) { node -> left = NULL ; } else { TreeNode * leftNode = new TreeNode ( stoi ( str )); node -> left = leftNode ; q . push ( leftNode ); } getline ( s , str , ',' ); if ( str == \"#\" ) { node -> right = NULL ; } else { TreeNode * rightNode = new TreeNode ( stoi ( str )); node -> right = rightNode ; q . push ( rightNode ); } } return root ; } }; //Following implementation is using DFS: class Codec { public : // Encodes a tree to a single string. void dfs ( TreeNode * curr , string & s ){ if ( ! curr ){ s . push_back ( '*' ); return ; } s . append ( to_string ( curr -> val ) + \",\" ); dfs ( curr -> left , s ); dfs ( curr -> right , s ); } string serialize ( TreeNode * root ) { string s = \"\" ; dfs ( root , s ); cout << s ; return s ; } // Decodes your encoded data to tree. TreeNode * decode ( string & data ){ if ( data . size () == 0 ) return NULL ; if ( data [ 0 ] == '*' ){ data = data . substr ( 1 ); return NULL ; } int pos = 0 ; string no = \"\" ; while ( data [ pos ] != ',' ) no += data [ pos ++ ]; TreeNode * curr = new TreeNode ( stoi ( no )); data = data . substr ( pos + 1 ); curr -> left = decode ( data ); curr -> right = decode ( data ); return curr ; } TreeNode * deserialize ( string data ) { if ( data . size () <= 1 ) return NULL ; return decode ( data ); } }; // Your Codec object will be instantiated and called as such: // Codec ser, deser; // TreeNode* ans = deser.deserialize(ser.serialize(root)); L37: Morris traversal Does not consume extra auxilliar y space of O(N) which is used in recursive or iterative traversal. This is based on concept of threaded binary tree. Intuition: In inorder, we go back to root after last node of left subtree. Critical step: Find rightmost node of left subtree and 1. connect last(rightmost) node of left subtree to root. or 2. if rightmost node == current node at any point in loop, then cut the thread and move to right //Inorder Morris traversal class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > inorder ; TreeNode * cur = root ; while ( cur != NULL ) { if ( cur -> left == NULL ) { inorder . push_back ( cur -> val ); cur = cur -> right ; } else { TreeNode * prev = cur -> left ; while ( prev -> right != NULL && prev -> right != cur ) { prev = prev -> right ; } if ( prev -> right == NULL ) { prev -> right = cur ; cur = cur -> left ; } else { prev -> right = NULL ; //Add to inorder when cutting thread inorder . push_back ( cur -> val ); cur = cur -> right ; } } } return inorder ; } }; //Preorder Morris traversal class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > preorder ; TreeNode * cur = root ; while ( cur != NULL ) { if ( cur -> left == NULL ) { preorder . push_back ( cur -> val ); cur = cur -> right ; } else { TreeNode * prev = cur -> left ; while ( prev -> right != NULL && prev -> right != cur ) { prev = prev -> right ; } if ( prev -> right == NULL ) { //Add to preorder when moving to left prev -> right = cur ; preorder . push_back ( cur -> val ); //Preorder change: add to result when finding rightmost cur = cur -> left ; } else { prev -> right = NULL ; cur = cur -> right ; } } } return preorder ; } }; L38: Flatten Binary tree Approach 1 : Recursive // TC - O(N) // SC - O(N) class Solution { TreeNode * prev = NULL ; public : void flatten ( TreeNode * root ) { if ( root == NULL ) return ; flatten ( root -> right ); flatten ( root -> left ); root -> right = prev ; root -> left = NULL ; prev = root ; } }; // TC - O(N) // SC - O(N) // Iterative (Simplest) // pop top from stack, push right, left to stack (note right first) // set cur->right = stack.top // set cur->left = null class Solution { public : void flatten ( TreeNode * root ) { if ( root == NULL ) return ; stack < TreeNode *> st ; st . push ( root ); while ( ! st . empty ()) { TreeNode * cur = st . top (); st . pop (); if ( cur -> right != NULL ) { st . push ( cur -> right ); } if ( cur -> left != NULL ) { st . push ( cur -> left ); } if ( ! st . empty ()) { cur -> right = st . top (); } cur -> left = NULL ; } } }; //This is similar to Morris Traversal //Difference: Connect last node of left subtree to right node instead of cur. //cur->right = cur->left // TC - O(N) // SC - O(1) class Solution { public : void flatten ( TreeNode * root ) { TreeNode * cur = root ; while ( cur ) { if ( cur -> left ) { TreeNode * pre = cur -> left ; while ( pre -> right ) { pre = pre -> right ; } pre -> right = cur -> right ; cur -> right = cur -> left ; cur -> left = NULL ; } cur = cur -> right ; } } }; L41 Ceil Smallest value greater than key. int findCeil ( BinaryTreeNode < int > * root , int key ){ int ceil = -1 ; while ( root ) { if ( root -> data == key ) { ceil = root -> data ; return ceil ; } if ( key > root -> data ) { root = root -> right ; } else { ceil = root -> data ; root = root -> left ; } } return ceil ; } L42: Floor Greatest value smaller than given key. int floorInBST ( TreeNode < int > * root , int key ) { int floor = -1 ; while ( root ) { if ( root -> val == key ) { floor = root -> val ; return floor ; } if ( key > root -> val ) { floor = root -> val ; root = root -> right ; } else { root = root -> left ; } } return floor ; } L43. Insert in BST class Solution { public : TreeNode * insertIntoBST ( TreeNode * root , int val ) { if ( root == NULL ) return new TreeNode ( val ); TreeNode * cur = root ; while ( true ) { if ( cur -> val <= val ) { if ( cur -> right != NULL ) cur = cur -> right ; else { cur -> right = new TreeNode ( val ); break ; } } else { if ( cur -> left != NULL ) cur = cur -> left ; else { cur -> left = new TreeNode ( val ); break ; } } } return root ; } }; L44. Delete a node from BST class Solution { public : TreeNode * deleteNode ( TreeNode * root , int key ) { if ( root == NULL ) { return NULL ; } if ( root -> val == key ) { return helper ( root ); } TreeNode * dummy = root ; while ( root != NULL ) { if ( root -> val > key ) { if ( root -> left != NULL && root -> left -> val == key ) { root -> left = helper ( root -> left ); break ; } else { root = root -> left ; } } else { if ( root -> right != NULL && root -> right -> val == key ) { root -> right = helper ( root -> right ); break ; } else { root = root -> right ; } } } return dummy ; } //Attaches right subtree to last node of left subtree and returns pointer to left subtree. TreeNode * helper ( TreeNode * root ) { if ( root -> left == NULL ) { return root -> right ; } else if ( root -> right == NULL ) { return root -> left ; } TreeNode * rightChild = root -> right ; TreeNode * lastRight = findLastRight ( root -> left ); lastRight -> right = rightChild ; return root -> left ; } TreeNode * findLastRight ( TreeNode * root ) { if ( root -> right == NULL ) { return root ; } return findLastRight ( root -> right ); } }; L45 Kth smallest element in binary search tree You can use any Inorder traversal with count. Increment count at cout(process root) step. //iterative inorder traversal class Solution { public int kthSmallest ( TreeNode root , int k ) { Stack < TreeNode > stack = new Stack < TreeNode > (); TreeNode node = root ; int cnt = 0 ; while ( true ){ if ( node != null ){ stack . push ( node ); node = node . left ; } else { if ( stack . isEmpty ()){ break ; } node = stack . pop (); // inorder.add(node.val); cnt ++ ; if ( cnt == k ) return node . val ; node = node . right ; } } return -1 ; } } L46. Check if a tree is a BST or BT | Validate a BST //Recursive class Solution { public boolean isValidBST ( TreeNode root ) { return isValidBST ( root , Long . MIN_VALUE , Long . MAX_VALUE ); } public boolean isValidBST ( TreeNode root , long minVal , long maxVal ) { if ( root == null ) return true ; if ( root . val >= maxVal || root . val <= minVal ) return false ; return isValidBST ( root . left , minVal , root . val ) && isValidBST ( root . right , root . val , maxVal ); } } //Iterative class Solution { public : bool isValidBST ( TreeNode * root ) { stack < TreeNode *> st ; TreeNode * node = root ; TreeNode * prev = NULL ; while ( true ) { if ( node != NULL ) { st . push ( node ); node = node -> left ; } else { if ( st . empty () == true ) break ; node = st . top (); st . pop (); // inorder.push_back(node->val); //since we keep going from left to right, make sure node's value should be greater than prev value if ( prev != NULL && node -> val <= prev -> val ) return false ; prev = node ; node = node -> right ; } } return true ; } }; L47 LCA in Binary Search Tree class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root ) return NULL ; int curr = root -> val ; if ( curr < p -> val && curr < q -> val ) { return lowestCommonAncestor ( root -> right , p , q ); } if ( curr > p -> val && curr > q -> val ) { return lowestCommonAncestor ( root -> left , p , q ); } return root ; } }; L48. Construct a BST from a preorder traversal You are given pre order, sorting of pre order will give inorder. Now this is same as L34 Keep upper bound with recursive calls, if not possible then return null. class Solution { public : TreeNode * bstFromPreorder ( vector < int >& A ) { int i = 0 ; return build ( A , i , INT_MAX ); } TreeNode * build ( vector < int >& A , int & i , int bound ) { if ( i == A . size () || A [ i ] > bound ) return NULL ; TreeNode * root = new TreeNode ( A [ i ++ ]); root -> left = build ( A , i , root -> val ); root -> right = build ( A , i , bound ); return root ; } }; BST Iterator class BSTIterator { stack < TreeNode *> myStack ; public : BSTIterator ( TreeNode * root ) { pushAll ( root ); } /** @return whether we have a next smallest number */ bool hasNext () { return ! myStack . empty (); } /** @return the next smallest number */ int next () { TreeNode * tmpNode = myStack . top (); myStack . pop (); pushAll ( tmpNode -> right ); return tmpNode -> val ; } private : void pushAll ( TreeNode * node ) { for (; node != NULL ; myStack . push ( node ), node = node -> left ); } }; 2 Sum BST Create iterator next, prev. And follow 2 pointer approach. class BSTIterator { stack < TreeNode *> myStack ; bool reverse = true ; public : BSTIterator ( TreeNode * root , bool isReverse ) { reverse = isReverse ; pushAll ( root ); } /** @return whether we have a next smallest number */ bool hasNext () { return ! myStack . empty (); } /** @return the next smallest number */ int next () { TreeNode * tmpNode = myStack . top (); myStack . pop (); if ( ! reverse ) pushAll ( tmpNode -> right ); else pushAll ( tmpNode -> left ); return tmpNode -> val ; } private : void pushAll ( TreeNode * node ) { for (; node != NULL ; ) { myStack . push ( node ); if ( reverse == true ) { node = node -> right ; } else { node = node -> left ; } } } }; class Solution { public : bool findTarget ( TreeNode * root , int k ) { if ( ! root ) return false ; BSTIterator l ( root , false ); BSTIterator r ( root , true ); int i = l . next (); int j = r . next (); while ( i < j ) { if ( i + j == k ) return true ; else if ( i + j < k ) i = l . next (); else j = r . next (); } return false ; } }; Recover BST 2 nodes are swapped, you need to correct. 2 Cases: 1. swapped nodes are adjacent (2 violations) 2. swapped nodes are not adjacent (1 violation) 11 <- root prev->1 5 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : TreeNode * first ; TreeNode * prev ; TreeNode * middle ; TreeNode * last ; private : void inorder ( TreeNode * root ) { if ( root == NULL ) return ; inorder ( root -> left ); if ( prev != NULL && ( root -> val < prev -> val )) { // If this is first violation, mark these two nodes as // 'first' and 'middle' if ( first == NULL ) { first = prev ; middle = root ; } // If this is second violation, mark this node as last else last = root ; } // Mark this node as previous prev = root ; inorder ( root -> right ); } public : void recoverTree ( TreeNode * root ) { first = middle = last = NULL ; prev = new TreeNode ( INT_MIN ); inorder ( root ); if ( first && last ) swap ( first -> val , last -> val ); else if ( first && middle ) swap ( first -> val , middle -> val ); } }; Largest BST in BT /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class NodeValue { public : int maxNode , minNode , maxSize ; NodeValue ( int minNode , int maxNode , int maxSize ) { this -> minNode = minNode ; this -> maxNode = maxNode ; this -> maxSize = maxSize ; } }; class Solution { private : NodeValue largestBSTSubtreeHelper ( TreeNode * root ) { // An empty tree is a BST of size 0. if ( ! root ) { return NodeValue ( INT_MAX , INT_MIN , 0 ); } // Get values from left and right subtree of current tree. auto left = largestBSTSubtreeHelper ( root -> left ); auto right = largestBSTSubtreeHelper ( root -> right ); // Current node is greater than max in left AND smaller than min in right, it is a BST. if ( left . maxNode < root -> val && root -> val < right . minNode ) { // It is a BST. return NodeValue ( min ( root -> val , left . minNode ), max ( root -> val , right . maxNode ), left . maxSize + right . maxSize + 1 ); } // Otherwise, return [-inf, inf] so that parent can't be valid BST return NodeValue ( INT_MIN , INT_MAX , max ( left . maxSize , right . maxSize )); } public : int largestBSTSubtree ( TreeNode * root ) { return largestBSTSubtreeHelper ( root ). maxSize ; } }; Huffman Encoding Create a leaf node for each character and add them to the priority queue. While there is more than one node in the queue: Remove the two nodes of the highest priority (the lowest frequency) from the queue. Create a new internal node with these two nodes as children and a frequency equal to the sum of both nodes\u2019 frequencies. Add the new node to the priority queue. The remaining node is the root node and the tree is complete. // C++ Program for Huffman Coding // using Priority Queue #include <iostream> #include <queue> using namespace std ; // Maximum Height of Huffman Tree. #define MAX_SIZE 100 class HuffmanTreeNode { public : // Stores character char data ; // Stores frequency of // the character int freq ; // Left child of the // current node HuffmanTreeNode * left ; // Right child of the // current node HuffmanTreeNode * right ; // Initializing the // current node HuffmanTreeNode ( char character , int frequency ) { data = character ; freq = frequency ; left = right = NULL ; } }; /* // Custom comparator class class Compare { public: bool operator()(HuffmanTreeNode* a, HuffmanTreeNode* b) { // Defining priority on // the basis of frequency return a->freq > b->freq; } }; */ bool Compare ()( HuffmanTreeNode * a , HuffmanTreeNode * b ) { // Defining priority on // the basis of frequency return a -> freq > b -> freq ; } // Function to generate Huffman // Encoding Tree HuffmanTreeNode * generateTree ( priority_queue < HuffmanTreeNode * , vector < HuffmanTreeNode *> , Compare > pq ) { // We keep on looping till // only one node remains in // the Priority Queue while ( pq . size () != 1 ) { // Node which has least // frequency HuffmanTreeNode * left = pq . top (); // Remove node from // Priority Queue pq . pop (); // Node which has least // frequency HuffmanTreeNode * right = pq . top (); // Remove node from // Priority Queue pq . pop (); // A new node is formed // with frequency left->freq // + right->freq // We take data as '$' // because we are only // concerned with the // frequency HuffmanTreeNode * node = new HuffmanTreeNode ( '$' , left -> freq + right -> freq ); node -> left = left ; node -> right = right ; // Push back node // created to the // Priority Queue pq . push ( node ); } return pq . top (); } // Function to print the // huffman code for each // character. // It uses arr to store the codes void printCodes ( HuffmanTreeNode * root , int arr [], int top ) { // Assign 0 to the left node // and recur if ( root -> left ) { arr [ top ] = 0 ; printCodes ( root -> left , arr , top + 1 ); } // Assign 1 to the right // node and recur if ( root -> right ) { arr [ top ] = 1 ; printCodes ( root -> right , arr , top + 1 ); } // If this is a leaf node, // then we print root->data // We also print the code // for this character from arr if ( ! root -> left && ! root -> right ) { cout << root -> data << \" \" ; for ( int i = 0 ; i < top ; i ++ ) { cout << arr [ i ]; } cout << endl ; } } void HuffmanCodes ( char data [], int freq [], int size ) { // Declaring priority queue // using custom comparator priority_queue < HuffmanTreeNode * , vector < HuffmanTreeNode *> , Compare > pq ; // Populating the priority // queue for ( int i = 0 ; i < size ; i ++ ) { HuffmanTreeNode * newNode = new HuffmanTreeNode ( data [ i ], freq [ i ]); pq . push ( newNode ); } // Generate Huffman Encoding // Tree and get the root node HuffmanTreeNode * root = generateTree ( pq ); // Print Huffman Codes int arr [ MAX_SIZE ], top = 0 ; printCodes ( root , arr , top ); } // Driver Code int main () { char data [] = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' }; int freq [] = { 5 , 9 , 12 , 13 , 16 , 45 }; int size = sizeof ( data ) / sizeof ( data [ 0 ]); HuffmanCodes ( data , freq , size ); return 0 ; }","title":"Tree"},{"location":"CompCoding/Hard/tree/#l21-vertical-order-traversal","text":"answer storage -> map <vertical_level, map > queue -> (node*, vertical, level(horizontal) ) You can do any of inorder, preorder, postorder traversal with above structure. class Solution { public : vector < vector < int >> verticalTraversal ( TreeNode * root ) { map < int , map < int , multiset < int >>> nodes ; queue < pair < TreeNode * , pair < int , int >>> todo ; todo . push ({ root , { 0 , 0 }}); while ( ! todo . empty ()) { auto p = todo . front (); todo . pop (); TreeNode * node = p . first ; int x = p . second . first , y = p . second . second ; nodes [ x ][ y ]. insert ( node -> val ); if ( node -> left ) { todo . push ({ node -> left , { x - 1 , y + 1 }}); } if ( node -> right ) { todo . push ({ node -> right , { x + 1 , y + 1 }}); } } vector < vector < int >> ans ; for ( auto p : nodes ) { vector < int > col ; for ( auto q : p . second ) { col . insert ( col . end (), q . second . begin (), q . second . end ()); } ans . push_back ( col ); } return ans ; } };","title":"L21 Vertical order traversal"},{"location":"CompCoding/Hard/tree/#l22-top-view-of-binary-tree","text":"Based on above vertical order traversal. Keep storage as just map< vertical, int > as we just need first element from top for that vertical. class Solution { public : //Function to return a list of nodes visible from the top view //from left to right in Binary Tree. vector < int > topView ( Node * root ) { vector < int > ans ; if ( root == NULL ) return ans ; map < int , int > mpp ; queue < pair < Node * , int >> q ; q . push ({ root , 0 }); while ( ! q . empty ()) { auto it = q . front (); q . pop (); Node * node = it . first ; int line = it . second ; if ( mpp . find ( line ) == mpp . end ()) mpp [ line ] = node -> data ; if ( node -> left != NULL ) { q . push ({ node -> left , line -1 }); } if ( node -> right != NULL ) { q . push ({ node -> right , line + 1 }); } } for ( auto it : mpp ) { ans . push_back ( it . second ); } return ans ; } };","title":"L22 Top view of binary tree"},{"location":"CompCoding/Hard/tree/#l23-bottom-view-of-tree","text":"Same as above only difference is that we keep updating map even if it is already filled as we need last node from that line. class Solution { public : vector < int > bottomView ( Node * root ) { vector < int > ans ; if ( root == NULL ) return ans ; map < int , int > mpp ; queue < pair < Node * , int >> q ; q . push ({ root , 0 }); while ( ! q . empty ()) { auto it = q . front (); q . pop (); Node * node = it . first ; int line = it . second ; mpp [ line ] = node -> data ; if ( node -> left != NULL ) { q . push ({ node -> left , line -1 }); } if ( node -> right != NULL ) { q . push ({ node -> right , line + 1 }); } } for ( auto it : mpp ) { ans . push_back ( it . second ); } return ans ; } };","title":"L23: Bottom view of tree"},{"location":"CompCoding/Hard/tree/#l24-leftright-view-of-binary-tree","text":"Left view : root, left, right recursive traversal while maintaining level Right view : root, right, left recursive traversal while maintaining level //Right view: class Solution { public : void recursion ( TreeNode * root , int level , vector < int > & res ) { if ( root == NULL ) return ; if ( res . size () == level ) { //Not updating result for level if already updated i.e. res.size() == level res . push_back ( root -> val ); } recursion ( root -> right , level + 1 , res ); recursion ( root -> left , level + 1 , res ); } vector < int > rightSideView ( TreeNode * root ) { vector < int > res ; recursion ( root , 0 , res ); return res ; } };","title":"L24 : Left/Right view of binary tree"},{"location":"CompCoding/Hard/tree/#l25-symmetric-binary-tree","text":"Symmetric Tree: Consider it as mirror of left half. 1 2 2 3 4 4 3 class Solution { public : bool f ( TreeNode * root1 , TreeNode * root2 ) { if ( ! root1 ) return ! root2 ; if ( ! root2 ) return ! root1 ; return ( root1 -> val == root2 -> val ) && f ( root1 -> left , root2 -> right ) && f ( root1 -> right , root2 -> left ); } bool isSymmetric ( TreeNode * root ) { if ( ! root ) return true ; return f ( root -> left , root -> right ); } };","title":"L25: Symmetric Binary tree"},{"location":"CompCoding/Hard/tree/#l26-print-root-to-node-path-in-binary-tree","text":"Keeping vector reference and adding node values while traversing and removing values if value not found (backtracking) bool getPath ( TreeNode * root , vector < int > & arr , int x ) { // if root is NULL // there is no path if ( ! root ) return false ; // push the node's value in 'arr' arr . push_back ( root -> val ); // if it is the required node // return true if ( root -> val == x ) return true ; // else check whether the required node lies // in the left subtree or right subtree of // the current node if ( getPath ( root -> left , arr , x ) || getPath ( root -> right , arr , x )) return true ; // required node does not lie either in the // left or right subtree of the current node // Thus, remove current node's value from // 'arr'and then return false arr . pop_back (); return false ; } vector < int > Solution :: solve ( TreeNode * A , int B ) { vector < int > arr ; if ( A == NULL ) { return arr ; } getPath ( A , arr , B ); return arr ; }","title":"L26: Print Root to Node path in Binary tree"},{"location":"CompCoding/Hard/tree/#l27-lowest-common-ancestor-in-binary-tree","text":"Naive: One way could be to print path for both nodes using above function. And find last common node in both results. But that will use extra result. Recursive: class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { //base case if ( root == NULL || root == p || root == q ) { return root ; } TreeNode * left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * right = lowestCommonAncestor ( root -> right , p , q ); //result if ( left == NULL ) { return right ; } else if ( right == NULL ) { return left ; } else { //both left and right are not null, we found our result return root ; } } };","title":"L27: Lowest Common Ancestor in Binary Tree"},{"location":"CompCoding/Hard/tree/#lca-in-bst","text":"Note: Previous question was binary tree and this question is binary search tree. If both p and q values are less than cur value, then recursively search in right. If both p and q values are greater than cur value, then recursively search in left. Else cur node is the LCA. class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root ) return NULL ; int curr = root -> val ; if ( curr < p -> val && curr < q -> val ) { return lowestCommonAncestor ( root -> right , p , q ); } if ( curr > p -> val && curr > q -> val ) { return lowestCommonAncestor ( root -> left , p , q ); } return root ; } };","title":"LCA in BST"},{"location":"CompCoding/Hard/tree/#l28-maximum-width-of-binary-tree","text":"The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. Indexing of nodes is important here. It is possible that few nodes in the middle part can be missing but still width is last - first + 1. 1 1 2 3 1 2 4 5 6 7 1 2 3 4 8 9 10 11 12 13 14 15 1 2 3 4 5 6 7 8 class Solution { public : int widthOfBinaryTree ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < pair < TreeNode * , int >> q ; q . push ({ root , 0 }); while ( ! q . empty ()){ int size = q . size (); int mmin = q . front (). second ; //to make the id starting from zero int first , last ; for ( int i = 0 ; i < size ; i ++ ){ int cur_id = q . front (). second - mmin ; //to start with index with 0 TreeNode * node = q . front (). first ; q . pop (); if ( i == 0 ) first = cur_id ; if ( i == size -1 ) last = cur_id ; if ( node -> left ) q . push ({ node -> left , cur_id * 2 + 1 }); if ( node -> right ) q . push ({ node -> right , cur_id * 2 + 2 }); } ans = max ( ans , last - first + 1 ); } return ans ; } };","title":"L28: Maximum Width of binary tree"},{"location":"CompCoding/Hard/tree/#l29-children-sum-property-in-binary-tree","text":"For any node, value should be equivalent to left + right. Allowed to increment any node by +1 any no of times. 2 -> 45 35 10 35 10 2 3 5 2 30 5 8 2 If sum of children is greater than root, then change root = sum of children else change both children to root. void reorder ( BinaryTreeNode < int > * root ) { if ( root == NULL ) return ; int child = 0 ; if ( root -> left ) { child += root -> left -> data ; } if ( root -> right ) { child += root -> right -> data ; } if ( child >= root -> data ) root -> data = child ; else { if ( root -> left ) root -> left -> data = root -> data ; else if ( root -> right ) root -> right -> data = root -> data ; } reorder ( root -> left ); reorder ( root -> right ); int tot = 0 ; if ( root -> left ) tot += root -> left -> data ; if ( root -> right ) tot += root -> right -> data ; if ( root -> left or root -> right ) root -> data = tot ; } void changeTree ( BinaryTreeNode < int > * root ) { reorder ( root ); }","title":"L29: Children Sum Property in Binary Tree"},{"location":"CompCoding/Hard/tree/#print-all-nodes-at-a-distance-of-k-in-binary-tree","text":"First mark parent pointers in a map using BFS. Do radial BFS traversal from given node. 1. Keep visited map. 2. Radially visiting -> Visit parent, left, right class Solution { void markParents ( TreeNode * root , unordered_map < TreeNode * , TreeNode *> & parent_track , TreeNode * target ) { queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { TreeNode * current = queue . front (); queue . pop (); if ( current -> left ) { parent_track [ current -> left ] = current ; queue . push ( current -> left ); } if ( current -> right ) { parent_track [ current -> right ] = current ; queue . push ( current -> right ); } } } public : vector < int > distanceK ( TreeNode * root , TreeNode * target , int k ) { unordered_map < TreeNode * , TreeNode *> parent_track ; // node -> parent markParents ( root , parent_track , target ); unordered_map < TreeNode * , bool > visited ; queue < TreeNode *> queue ; queue . push ( target ); visited [ target ] = true ; int curr_level = 0 ; while ( ! queue . empty ()) { /*Second BFS to go upto K level from target node and using our hashtable info*/ int size = queue . size (); if ( curr_level ++ == k ) break ; for ( int i = 0 ; i < size ; i ++ ) { TreeNode * current = queue . front (); queue . pop (); if ( current -> left && ! visited [ current -> left ]) { queue . push ( current -> left ); visited [ current -> left ] = true ; } if ( current -> right && ! visited [ current -> right ]) { queue . push ( current -> right ); visited [ current -> right ] = true ; } if ( parent_track [ current ] && ! visited [ parent_track [ current ]]) { queue . push ( parent_track [ current ]); visited [ parent_track [ current ]] = true ; } } } vector < int > result ; while ( ! queue . empty ()) { TreeNode * current = queue . front (); queue . pop (); result . push_back ( current -> val ); } return result ; } };","title":"Print all nodes at a distance of K in Binary Tree"},{"location":"CompCoding/Hard/tree/#l31-minimum-time-taken-to-burn-the-binary-tree-from-a-node","text":"This is similar to above question to print nodes at distance K from given node. Here only difference is to find max length from given node. In previous question, we did radial bfs traversal for K length and break out of loop after k but in current question we need to keep going until all nodes are traversed and increment time(maxi) only if we are burning some node. #include <bits/stdc++.h> int findMaxDistance ( map < BinaryTreeNode < int >* , BinaryTreeNode < int >*> & mpp , BinaryTreeNode < int >* target ) { queue < BinaryTreeNode < int >*> q ; q . push ( target ); map < BinaryTreeNode < int >* , int > vis ; vis [ target ] = 1 ; int maxi = 0 ; while ( ! q . empty ()) { int sz = q . size (); int fl = 0 ; //Flag to indicate that at least 1 node is burnt in this level for ( int i = 0 ; i < sz ; i ++ ) { auto node = q . front (); q . pop (); if ( node -> left && ! vis [ node -> left ]) { fl = 1 ; vis [ node -> left ] = 1 ; q . push ( node -> left ); } if ( node -> right && ! vis [ node -> right ]) { fl = 1 ; vis [ node -> right ] = 1 ; q . push ( node -> right ); } if ( mpp [ node ] && ! vis [ mpp [ node ]]) { fl = 1 ; vis [ mpp [ node ]] = 1 ; q . push ( mpp [ node ]); } } if ( fl ) maxi ++ ; } return maxi ; } BinaryTreeNode < int >* bfsToMapParents ( BinaryTreeNode < int >* root , map < BinaryTreeNode < int >* , BinaryTreeNode < int >*> & mpp , int start ) { queue < BinaryTreeNode < int >*> q ; q . push ( root ); BinaryTreeNode < int >* res ; while ( ! q . empty ()) { BinaryTreeNode < int >* node = q . front (); if ( node -> data == start ) res = node ; q . pop (); if ( node -> left ) { mpp [ node -> left ] = node ; q . push ( node -> left ); } if ( node -> right ) { mpp [ node -> right ] = node ; q . push ( node -> right ); } } return res ; } int timeToBurnTree ( BinaryTreeNode < int >* root , int start ) { map < BinaryTreeNode < int >* , BinaryTreeNode < int >*> mpp ; BinaryTreeNode < int >* target = bfsToMapParents ( root , mpp , start ); int maxi = findMaxDistance ( mpp , target ); return maxi ; }","title":"L31: Minimum time taken to BURN the Binary Tree from a Node"},{"location":"CompCoding/Hard/tree/#l32-count-total-node-in-a-balanced-binary-tree","text":"Following is a balanced binary tree but not a complete binary tree. If left height == right height i.e. If complete binary tree then no of nodes = 2^h - 1 1 2 3 4 5 6 7 8 9 10 11 Time complexity = (lg N)^2 class Solution { public : int countNodes ( TreeNode * root ) { if ( root == NULL ) return 0 ; int lh = findHeightLeft ( root ); int rh = findHeightRight ( root ); if ( lh == rh ) return ( 1 << lh ) - 1 ; return 1 + countNodes ( root -> left ) + countNodes ( root -> right ); } int findHeightLeft ( TreeNode * node ) { int hght = 0 ; while ( node ) { hght ++ ; node = node -> left ; } return hght ; } int findHeightRight ( TreeNode * node ) { int hght = 0 ; while ( node ) { hght ++ ; node = node -> right ; } return hght ; } };","title":"L32: Count total node in a balanced binary tree"},{"location":"CompCoding/Hard/tree/#l34-construct-a-binary-tree-from-preorder-and-inorder-traversal","text":"Note that inorder traversal is very important to reconstruct a unique tree as it gives exact position of root in pre or post order and then only we know what is left part and right part of unique tree. Steps: Put complete inorder traversal in hash map i.e. inMap. This helps in finding location of root in inorder. And we can recursively call buildTree for left part and right part. class Solution { private : TreeNode * buildTree ( vector < int >& preorder , int preStart , int preEnd , vector < int >& inorder , int inStart , int inEnd , map < int , int > & inMap ) { if ( preStart > preEnd || inStart > inEnd ) return NULL ; TreeNode * root = new TreeNode ( preorder [ preStart ]); int inRoot = inMap [ root -> val ]; int numsLeft = inRoot - inStart ; root -> left = buildTree ( preorder , preStart + 1 , preStart + numsLeft , inorder , inStart , inRoot - 1 , inMap ); root -> right = buildTree ( preorder , preStart + numsLeft + 1 , preEnd , inorder , inRoot + 1 , inEnd , inMap ); return root ; } public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { map < int , int > inMap ; for ( int i = 0 ; i < inorder . size (); i ++ ) { inMap [ inorder [ i ]] = i ; } TreeNode * root = buildTree ( preorder , 0 , preorder . size () - 1 , inorder , 0 , inorder . size () - 1 , inMap ); return root ; } };","title":"L34: Construct a Binary Tree from Preorder and Inorder traversal"},{"location":"CompCoding/Hard/tree/#l35-construct-binary-tree-from-post-order-and-inorder-traversal","text":"This is similar to above question. In preorder first node is the root, in postorder last node is the root. //Modify above code and construct class Solution { public : TreeNode * buildTree ( vector < int >& postorder , vector < int >& inorder ) { map < int , int > inMap ; for ( int i = 0 ; i < inorder . size (); i ++ ) { inMap [ inorder [ i ]] = i ; } TreeNode * root = buildTree ( preorder , 0 , postorder . size () - 1 , inorder , 0 , inorder . size () - 1 , inMap ); return root ; } TreeNode * buildTree ( vector < int >& postorder , int postStart , int postEnd , vector < int >& inorder , int inStart , int inEnd , map < int , int > & inMap ) { if ( preStart > preEnd || inStart > inEnd ) return NULL ; TreeNode * root = new TreeNode ( postorder [ postEnd ]); int inRoot = inMap [ root -> val ]; int numsLeft = inRoot - inStart ; root -> left = buildTree ( postorder , postStart , preStart + numsLeft - 1 , inorder , inStart , inRoot - 1 , inMap ); root -> right = buildTree ( postorder , postStart + numsLeft , postEnd - 1 , inorder , inRoot + 1 , inEnd , inMap ); return root ; } };","title":"L35: Construct binary tree from post order and inorder traversal"},{"location":"CompCoding/Hard/tree/#l36-leetcode-297-serialize-and-deserialise-a-binary-tree","text":"You can use any traversal, not necessarily preorder traversal. Need to add indicator(delimiter) for null pointers in preorder traversal. //Following implementation is using BFS: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public : // Encodes a tree to a single string. string serialize ( TreeNode * root ) { if ( ! root ) return \"\" ; string s = \"\" ; queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { TreeNode * curNode = q . front (); q . pop (); if ( curNode == NULL ) s . append ( \"#,\" ); else s . append ( to_string ( curNode -> val ) + ',' ); if ( curNode != NULL ){ q . push ( curNode -> left ); q . push ( curNode -> right ); } } return s ; } // Decodes your encoded data to tree. TreeNode * deserialize ( string data ) { if ( data . size () == 0 ) return NULL ; stringstream s ( data ); string str ; getline ( s , str , ',' ); TreeNode * root = new TreeNode ( stoi ( str )); queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { TreeNode * node = q . front (); q . pop (); getline ( s , str , ',' ); if ( str == \"#\" ) { node -> left = NULL ; } else { TreeNode * leftNode = new TreeNode ( stoi ( str )); node -> left = leftNode ; q . push ( leftNode ); } getline ( s , str , ',' ); if ( str == \"#\" ) { node -> right = NULL ; } else { TreeNode * rightNode = new TreeNode ( stoi ( str )); node -> right = rightNode ; q . push ( rightNode ); } } return root ; } }; //Following implementation is using DFS: class Codec { public : // Encodes a tree to a single string. void dfs ( TreeNode * curr , string & s ){ if ( ! curr ){ s . push_back ( '*' ); return ; } s . append ( to_string ( curr -> val ) + \",\" ); dfs ( curr -> left , s ); dfs ( curr -> right , s ); } string serialize ( TreeNode * root ) { string s = \"\" ; dfs ( root , s ); cout << s ; return s ; } // Decodes your encoded data to tree. TreeNode * decode ( string & data ){ if ( data . size () == 0 ) return NULL ; if ( data [ 0 ] == '*' ){ data = data . substr ( 1 ); return NULL ; } int pos = 0 ; string no = \"\" ; while ( data [ pos ] != ',' ) no += data [ pos ++ ]; TreeNode * curr = new TreeNode ( stoi ( no )); data = data . substr ( pos + 1 ); curr -> left = decode ( data ); curr -> right = decode ( data ); return curr ; } TreeNode * deserialize ( string data ) { if ( data . size () <= 1 ) return NULL ; return decode ( data ); } }; // Your Codec object will be instantiated and called as such: // Codec ser, deser; // TreeNode* ans = deser.deserialize(ser.serialize(root));","title":"L36: Leetcode 297: Serialize and deserialise a binary tree"},{"location":"CompCoding/Hard/tree/#l37-morris-traversal","text":"Does not consume extra auxilliar y space of O(N) which is used in recursive or iterative traversal. This is based on concept of threaded binary tree. Intuition: In inorder, we go back to root after last node of left subtree. Critical step: Find rightmost node of left subtree and 1. connect last(rightmost) node of left subtree to root. or 2. if rightmost node == current node at any point in loop, then cut the thread and move to right //Inorder Morris traversal class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > inorder ; TreeNode * cur = root ; while ( cur != NULL ) { if ( cur -> left == NULL ) { inorder . push_back ( cur -> val ); cur = cur -> right ; } else { TreeNode * prev = cur -> left ; while ( prev -> right != NULL && prev -> right != cur ) { prev = prev -> right ; } if ( prev -> right == NULL ) { prev -> right = cur ; cur = cur -> left ; } else { prev -> right = NULL ; //Add to inorder when cutting thread inorder . push_back ( cur -> val ); cur = cur -> right ; } } } return inorder ; } }; //Preorder Morris traversal class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > preorder ; TreeNode * cur = root ; while ( cur != NULL ) { if ( cur -> left == NULL ) { preorder . push_back ( cur -> val ); cur = cur -> right ; } else { TreeNode * prev = cur -> left ; while ( prev -> right != NULL && prev -> right != cur ) { prev = prev -> right ; } if ( prev -> right == NULL ) { //Add to preorder when moving to left prev -> right = cur ; preorder . push_back ( cur -> val ); //Preorder change: add to result when finding rightmost cur = cur -> left ; } else { prev -> right = NULL ; cur = cur -> right ; } } } return preorder ; } };","title":"L37: Morris traversal"},{"location":"CompCoding/Hard/tree/#l38-flatten-binary-tree","text":"Approach 1 : Recursive // TC - O(N) // SC - O(N) class Solution { TreeNode * prev = NULL ; public : void flatten ( TreeNode * root ) { if ( root == NULL ) return ; flatten ( root -> right ); flatten ( root -> left ); root -> right = prev ; root -> left = NULL ; prev = root ; } }; // TC - O(N) // SC - O(N) // Iterative (Simplest) // pop top from stack, push right, left to stack (note right first) // set cur->right = stack.top // set cur->left = null class Solution { public : void flatten ( TreeNode * root ) { if ( root == NULL ) return ; stack < TreeNode *> st ; st . push ( root ); while ( ! st . empty ()) { TreeNode * cur = st . top (); st . pop (); if ( cur -> right != NULL ) { st . push ( cur -> right ); } if ( cur -> left != NULL ) { st . push ( cur -> left ); } if ( ! st . empty ()) { cur -> right = st . top (); } cur -> left = NULL ; } } }; //This is similar to Morris Traversal //Difference: Connect last node of left subtree to right node instead of cur. //cur->right = cur->left // TC - O(N) // SC - O(1) class Solution { public : void flatten ( TreeNode * root ) { TreeNode * cur = root ; while ( cur ) { if ( cur -> left ) { TreeNode * pre = cur -> left ; while ( pre -> right ) { pre = pre -> right ; } pre -> right = cur -> right ; cur -> right = cur -> left ; cur -> left = NULL ; } cur = cur -> right ; } } };","title":"L38: Flatten Binary tree"},{"location":"CompCoding/Hard/tree/#l41-ceil","text":"Smallest value greater than key. int findCeil ( BinaryTreeNode < int > * root , int key ){ int ceil = -1 ; while ( root ) { if ( root -> data == key ) { ceil = root -> data ; return ceil ; } if ( key > root -> data ) { root = root -> right ; } else { ceil = root -> data ; root = root -> left ; } } return ceil ; }","title":"L41 Ceil"},{"location":"CompCoding/Hard/tree/#l42-floor","text":"Greatest value smaller than given key. int floorInBST ( TreeNode < int > * root , int key ) { int floor = -1 ; while ( root ) { if ( root -> val == key ) { floor = root -> val ; return floor ; } if ( key > root -> val ) { floor = root -> val ; root = root -> right ; } else { root = root -> left ; } } return floor ; }","title":"L42:  Floor"},{"location":"CompCoding/Hard/tree/#l43-insert-in-bst","text":"class Solution { public : TreeNode * insertIntoBST ( TreeNode * root , int val ) { if ( root == NULL ) return new TreeNode ( val ); TreeNode * cur = root ; while ( true ) { if ( cur -> val <= val ) { if ( cur -> right != NULL ) cur = cur -> right ; else { cur -> right = new TreeNode ( val ); break ; } } else { if ( cur -> left != NULL ) cur = cur -> left ; else { cur -> left = new TreeNode ( val ); break ; } } } return root ; } };","title":"L43. Insert in BST"},{"location":"CompCoding/Hard/tree/#l44-delete-a-node-from-bst","text":"class Solution { public : TreeNode * deleteNode ( TreeNode * root , int key ) { if ( root == NULL ) { return NULL ; } if ( root -> val == key ) { return helper ( root ); } TreeNode * dummy = root ; while ( root != NULL ) { if ( root -> val > key ) { if ( root -> left != NULL && root -> left -> val == key ) { root -> left = helper ( root -> left ); break ; } else { root = root -> left ; } } else { if ( root -> right != NULL && root -> right -> val == key ) { root -> right = helper ( root -> right ); break ; } else { root = root -> right ; } } } return dummy ; } //Attaches right subtree to last node of left subtree and returns pointer to left subtree. TreeNode * helper ( TreeNode * root ) { if ( root -> left == NULL ) { return root -> right ; } else if ( root -> right == NULL ) { return root -> left ; } TreeNode * rightChild = root -> right ; TreeNode * lastRight = findLastRight ( root -> left ); lastRight -> right = rightChild ; return root -> left ; } TreeNode * findLastRight ( TreeNode * root ) { if ( root -> right == NULL ) { return root ; } return findLastRight ( root -> right ); } };","title":"L44. Delete a node from BST"},{"location":"CompCoding/Hard/tree/#l45-kth-smallest-element-in-binary-search-tree","text":"You can use any Inorder traversal with count. Increment count at cout(process root) step. //iterative inorder traversal class Solution { public int kthSmallest ( TreeNode root , int k ) { Stack < TreeNode > stack = new Stack < TreeNode > (); TreeNode node = root ; int cnt = 0 ; while ( true ){ if ( node != null ){ stack . push ( node ); node = node . left ; } else { if ( stack . isEmpty ()){ break ; } node = stack . pop (); // inorder.add(node.val); cnt ++ ; if ( cnt == k ) return node . val ; node = node . right ; } } return -1 ; } }","title":"L45 Kth smallest element in binary search tree"},{"location":"CompCoding/Hard/tree/#l46-check-if-a-tree-is-a-bst-or-bt-validate-a-bst","text":"//Recursive class Solution { public boolean isValidBST ( TreeNode root ) { return isValidBST ( root , Long . MIN_VALUE , Long . MAX_VALUE ); } public boolean isValidBST ( TreeNode root , long minVal , long maxVal ) { if ( root == null ) return true ; if ( root . val >= maxVal || root . val <= minVal ) return false ; return isValidBST ( root . left , minVal , root . val ) && isValidBST ( root . right , root . val , maxVal ); } } //Iterative class Solution { public : bool isValidBST ( TreeNode * root ) { stack < TreeNode *> st ; TreeNode * node = root ; TreeNode * prev = NULL ; while ( true ) { if ( node != NULL ) { st . push ( node ); node = node -> left ; } else { if ( st . empty () == true ) break ; node = st . top (); st . pop (); // inorder.push_back(node->val); //since we keep going from left to right, make sure node's value should be greater than prev value if ( prev != NULL && node -> val <= prev -> val ) return false ; prev = node ; node = node -> right ; } } return true ; } };","title":"L46. Check if a tree is a BST or BT | Validate a BST"},{"location":"CompCoding/Hard/tree/#l47-lca-in-binary-search-tree","text":"class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root ) return NULL ; int curr = root -> val ; if ( curr < p -> val && curr < q -> val ) { return lowestCommonAncestor ( root -> right , p , q ); } if ( curr > p -> val && curr > q -> val ) { return lowestCommonAncestor ( root -> left , p , q ); } return root ; } };","title":"L47 LCA in Binary Search Tree"},{"location":"CompCoding/Hard/tree/#l48-construct-a-bst-from-a-preorder-traversal","text":"You are given pre order, sorting of pre order will give inorder. Now this is same as L34 Keep upper bound with recursive calls, if not possible then return null. class Solution { public : TreeNode * bstFromPreorder ( vector < int >& A ) { int i = 0 ; return build ( A , i , INT_MAX ); } TreeNode * build ( vector < int >& A , int & i , int bound ) { if ( i == A . size () || A [ i ] > bound ) return NULL ; TreeNode * root = new TreeNode ( A [ i ++ ]); root -> left = build ( A , i , root -> val ); root -> right = build ( A , i , bound ); return root ; } };","title":"L48. Construct a BST from a preorder traversal"},{"location":"CompCoding/Hard/tree/#bst-iterator","text":"class BSTIterator { stack < TreeNode *> myStack ; public : BSTIterator ( TreeNode * root ) { pushAll ( root ); } /** @return whether we have a next smallest number */ bool hasNext () { return ! myStack . empty (); } /** @return the next smallest number */ int next () { TreeNode * tmpNode = myStack . top (); myStack . pop (); pushAll ( tmpNode -> right ); return tmpNode -> val ; } private : void pushAll ( TreeNode * node ) { for (; node != NULL ; myStack . push ( node ), node = node -> left ); } };","title":"BST Iterator"},{"location":"CompCoding/Hard/tree/#2-sum-bst","text":"Create iterator next, prev. And follow 2 pointer approach. class BSTIterator { stack < TreeNode *> myStack ; bool reverse = true ; public : BSTIterator ( TreeNode * root , bool isReverse ) { reverse = isReverse ; pushAll ( root ); } /** @return whether we have a next smallest number */ bool hasNext () { return ! myStack . empty (); } /** @return the next smallest number */ int next () { TreeNode * tmpNode = myStack . top (); myStack . pop (); if ( ! reverse ) pushAll ( tmpNode -> right ); else pushAll ( tmpNode -> left ); return tmpNode -> val ; } private : void pushAll ( TreeNode * node ) { for (; node != NULL ; ) { myStack . push ( node ); if ( reverse == true ) { node = node -> right ; } else { node = node -> left ; } } } }; class Solution { public : bool findTarget ( TreeNode * root , int k ) { if ( ! root ) return false ; BSTIterator l ( root , false ); BSTIterator r ( root , true ); int i = l . next (); int j = r . next (); while ( i < j ) { if ( i + j == k ) return true ; else if ( i + j < k ) i = l . next (); else j = r . next (); } return false ; } };","title":"2 Sum BST"},{"location":"CompCoding/Hard/tree/#recover-bst","text":"2 nodes are swapped, you need to correct. 2 Cases: 1. swapped nodes are adjacent (2 violations) 2. swapped nodes are not adjacent (1 violation) 11 <- root prev->1 5 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private : TreeNode * first ; TreeNode * prev ; TreeNode * middle ; TreeNode * last ; private : void inorder ( TreeNode * root ) { if ( root == NULL ) return ; inorder ( root -> left ); if ( prev != NULL && ( root -> val < prev -> val )) { // If this is first violation, mark these two nodes as // 'first' and 'middle' if ( first == NULL ) { first = prev ; middle = root ; } // If this is second violation, mark this node as last else last = root ; } // Mark this node as previous prev = root ; inorder ( root -> right ); } public : void recoverTree ( TreeNode * root ) { first = middle = last = NULL ; prev = new TreeNode ( INT_MIN ); inorder ( root ); if ( first && last ) swap ( first -> val , last -> val ); else if ( first && middle ) swap ( first -> val , middle -> val ); } };","title":"Recover BST"},{"location":"CompCoding/Hard/tree/#largest-bst-in-bt","text":"/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class NodeValue { public : int maxNode , minNode , maxSize ; NodeValue ( int minNode , int maxNode , int maxSize ) { this -> minNode = minNode ; this -> maxNode = maxNode ; this -> maxSize = maxSize ; } }; class Solution { private : NodeValue largestBSTSubtreeHelper ( TreeNode * root ) { // An empty tree is a BST of size 0. if ( ! root ) { return NodeValue ( INT_MAX , INT_MIN , 0 ); } // Get values from left and right subtree of current tree. auto left = largestBSTSubtreeHelper ( root -> left ); auto right = largestBSTSubtreeHelper ( root -> right ); // Current node is greater than max in left AND smaller than min in right, it is a BST. if ( left . maxNode < root -> val && root -> val < right . minNode ) { // It is a BST. return NodeValue ( min ( root -> val , left . minNode ), max ( root -> val , right . maxNode ), left . maxSize + right . maxSize + 1 ); } // Otherwise, return [-inf, inf] so that parent can't be valid BST return NodeValue ( INT_MIN , INT_MAX , max ( left . maxSize , right . maxSize )); } public : int largestBSTSubtree ( TreeNode * root ) { return largestBSTSubtreeHelper ( root ). maxSize ; } };","title":"Largest BST in BT"},{"location":"CompCoding/Hard/tree/#huffman-encoding","text":"Create a leaf node for each character and add them to the priority queue. While there is more than one node in the queue: Remove the two nodes of the highest priority (the lowest frequency) from the queue. Create a new internal node with these two nodes as children and a frequency equal to the sum of both nodes\u2019 frequencies. Add the new node to the priority queue. The remaining node is the root node and the tree is complete. // C++ Program for Huffman Coding // using Priority Queue #include <iostream> #include <queue> using namespace std ; // Maximum Height of Huffman Tree. #define MAX_SIZE 100 class HuffmanTreeNode { public : // Stores character char data ; // Stores frequency of // the character int freq ; // Left child of the // current node HuffmanTreeNode * left ; // Right child of the // current node HuffmanTreeNode * right ; // Initializing the // current node HuffmanTreeNode ( char character , int frequency ) { data = character ; freq = frequency ; left = right = NULL ; } }; /* // Custom comparator class class Compare { public: bool operator()(HuffmanTreeNode* a, HuffmanTreeNode* b) { // Defining priority on // the basis of frequency return a->freq > b->freq; } }; */ bool Compare ()( HuffmanTreeNode * a , HuffmanTreeNode * b ) { // Defining priority on // the basis of frequency return a -> freq > b -> freq ; } // Function to generate Huffman // Encoding Tree HuffmanTreeNode * generateTree ( priority_queue < HuffmanTreeNode * , vector < HuffmanTreeNode *> , Compare > pq ) { // We keep on looping till // only one node remains in // the Priority Queue while ( pq . size () != 1 ) { // Node which has least // frequency HuffmanTreeNode * left = pq . top (); // Remove node from // Priority Queue pq . pop (); // Node which has least // frequency HuffmanTreeNode * right = pq . top (); // Remove node from // Priority Queue pq . pop (); // A new node is formed // with frequency left->freq // + right->freq // We take data as '$' // because we are only // concerned with the // frequency HuffmanTreeNode * node = new HuffmanTreeNode ( '$' , left -> freq + right -> freq ); node -> left = left ; node -> right = right ; // Push back node // created to the // Priority Queue pq . push ( node ); } return pq . top (); } // Function to print the // huffman code for each // character. // It uses arr to store the codes void printCodes ( HuffmanTreeNode * root , int arr [], int top ) { // Assign 0 to the left node // and recur if ( root -> left ) { arr [ top ] = 0 ; printCodes ( root -> left , arr , top + 1 ); } // Assign 1 to the right // node and recur if ( root -> right ) { arr [ top ] = 1 ; printCodes ( root -> right , arr , top + 1 ); } // If this is a leaf node, // then we print root->data // We also print the code // for this character from arr if ( ! root -> left && ! root -> right ) { cout << root -> data << \" \" ; for ( int i = 0 ; i < top ; i ++ ) { cout << arr [ i ]; } cout << endl ; } } void HuffmanCodes ( char data [], int freq [], int size ) { // Declaring priority queue // using custom comparator priority_queue < HuffmanTreeNode * , vector < HuffmanTreeNode *> , Compare > pq ; // Populating the priority // queue for ( int i = 0 ; i < size ; i ++ ) { HuffmanTreeNode * newNode = new HuffmanTreeNode ( data [ i ], freq [ i ]); pq . push ( newNode ); } // Generate Huffman Encoding // Tree and get the root node HuffmanTreeNode * root = generateTree ( pq ); // Print Huffman Codes int arr [ MAX_SIZE ], top = 0 ; printCodes ( root , arr , top ); } // Driver Code int main () { char data [] = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' }; int freq [] = { 5 , 9 , 12 , 13 , 16 , 45 }; int size = sizeof ( data ) / sizeof ( data [ 0 ]); HuffmanCodes ( data , freq , size ); return 0 ; }","title":"Huffman Encoding"},{"location":"DataStructures/advanced/","text":"Basic Data Structures BST Graphs Tries During delete operation we delete the key in bottom up manner using recursion. The following are possible conditions when deleting key from trie, 1. Key may not be there in trie. Delete operation should not modify trie. 2. Key present as unique key (no part of key contains another key (prefix), nor the key itself is prefix of another key in trie). Delete all the nodes. 3. Key is prefix key of another long key in trie. Unmark the leaf node. 4. Key present in trie, having atleast one other key as prefix key. Delete nodes from end of key until first leaf node of longest prefix key. e.g. app, apple. delete(apple) should not delete app #include <iostream> using namespace std ; // Define the character size #define CHAR_SIZE 128 // A class to store a Trie node class Trie { public : bool isLeaf ; Trie * character [ CHAR_SIZE ]; // Constructor Trie () { this -> isLeaf = false ; for ( int i = 0 ; i < CHAR_SIZE ; i ++ ) { this -> character [ i ] = nullptr ; } } void insert ( string ); bool deletion ( Trie *& , string ); bool search ( string ); bool haveChildren ( Trie const * ); }; // Iterative function to insert a key into a Trie void Trie::insert ( string key ) { // start from the root node Trie * curr = this ; for ( int i = 0 ; i < key . length (); i ++ ) { // create a new node if the path doesn't exist if ( curr -> character [ key [ i ]] == nullptr ) { curr -> character [ key [ i ]] = new Trie (); } // go to the next node curr = curr -> character [ key [ i ]]; } // mark the current node as a leaf curr -> isLeaf = true ; } // Iterative function to search a key in a Trie. It returns true // if the key is found in the Trie; otherwise, it returns false bool Trie::search ( string key ) { // return false if Trie is empty if ( this == nullptr ) { return false ; } Trie * curr = this ; for ( int i = 0 ; i < key . length (); i ++ ) { // go to the next node curr = curr -> character [ key [ i ]]; // if the string is invalid (reached end of a path in the Trie) if ( curr == nullptr ) { return false ; } } // return true if the current node is a leaf and the // end of the string is reached return curr -> isLeaf ; } // Returns true if a given node has any children bool Trie::haveChildren ( Trie const * curr ) { for ( int i = 0 ; i < CHAR_SIZE ; i ++ ) { if ( curr -> character [ i ]) { return true ; // child found } } return false ; } // Recursive function to delete a key in the Trie bool Trie::deletion ( Trie *& curr , string key ) { // return if Trie is empty if ( curr == nullptr ) { return false ; } // if the end of the key is not reached if ( key . length ()) { // recur for the node corresponding to the next character in the key // and if it returns true, delete the current node (if it is non-leaf) if ( curr != nullptr && curr -> character [ key [ 0 ]] != nullptr && deletion ( curr -> character [ key [ 0 ]], key . substr ( 1 )) && curr -> isLeaf == false ) { if ( ! haveChildren ( curr )) { delete curr ; curr = nullptr ; return true ; } else { return false ; } } } // if the end of the key is reached if ( key . length () == 0 && curr -> isLeaf ) { // if the current node is a leaf node and doesn't have any children if ( ! haveChildren ( curr )) { // delete the current node delete curr ; curr = nullptr ; // delete the non-leaf parent nodes return true ; } // if the current node is a leaf node and has children else { // mark the current node as a non-leaf node (DON'T DELETE IT) curr -> isLeaf = false ; // don't delete its parent nodes return false ; } } return false ; } Min Heap/ Max Heap Disjoint set Fenwick Trees Array len = 10^5 Queries = 10^5 1. replace arr[i] 2. Find sum from l..r Finding right most set bit of x: x = a 1 b where a is any random number and b is all 0s x = 0101 1 0000 -x = a' 1 b where a' can be ignored and b is all 0s -x is 2's complement i.e. 1's complement i.e. 101001111 +1 -x = 1010 1 1111 x & -x = 0000 1 0000 Fenwick tree ( BIT[i] ) stores such that, at any index i we can store sum of some numbers (j+1...i) of the given array. This can also be called a partial sum tree. Here j is obtained by making last set bit of i as 0 ie. i-(i&-1) . Always use 1 based indexing void update ( int x , int delta ) //add \"delta\" at index \"x\" { //while updating we keep adding delta to numbers obtained by adding x&-x for (; x <= n ; x += x &- x ) BIT [ x ] += delta ; } int sum ( int x ) //returns the sum of first x elements in given array a[] { //while getting sum, we keep adding BIT[i] where i is obtained by subtracting x&-x int sum = 0 ; for (; x > 0 ; x -= x &- x ) sum += BIT [ x ]; return sum ; } Inversion count problem can be solved using BIT. While traversing input array, update(+1) count of arr[i] by 1. So BIT(x) will give count of numbers till x. We want to find already present count of numbers greater than current i.e. BIT(max) - BIT(arr[i]) vector < int > input = {}; vector < int > bit ( input . size () + 1 ); int count = 0 ; for ( int i = 0 ; i < input . size (); i ++ ) { //first check numbers greater than input[i] till i count += sum ( max ) - sum ( input [ i ]); //add input[i] update ( input [ i ], 1 ); }","title":"Advanced"},{"location":"DataStructures/advanced/#basic-data-structures","text":"","title":"Basic Data Structures"},{"location":"DataStructures/advanced/#bst","text":"","title":"BST"},{"location":"DataStructures/advanced/#graphs","text":"","title":"Graphs"},{"location":"DataStructures/advanced/#tries","text":"During delete operation we delete the key in bottom up manner using recursion. The following are possible conditions when deleting key from trie, 1. Key may not be there in trie. Delete operation should not modify trie. 2. Key present as unique key (no part of key contains another key (prefix), nor the key itself is prefix of another key in trie). Delete all the nodes. 3. Key is prefix key of another long key in trie. Unmark the leaf node. 4. Key present in trie, having atleast one other key as prefix key. Delete nodes from end of key until first leaf node of longest prefix key. e.g. app, apple. delete(apple) should not delete app #include <iostream> using namespace std ; // Define the character size #define CHAR_SIZE 128 // A class to store a Trie node class Trie { public : bool isLeaf ; Trie * character [ CHAR_SIZE ]; // Constructor Trie () { this -> isLeaf = false ; for ( int i = 0 ; i < CHAR_SIZE ; i ++ ) { this -> character [ i ] = nullptr ; } } void insert ( string ); bool deletion ( Trie *& , string ); bool search ( string ); bool haveChildren ( Trie const * ); }; // Iterative function to insert a key into a Trie void Trie::insert ( string key ) { // start from the root node Trie * curr = this ; for ( int i = 0 ; i < key . length (); i ++ ) { // create a new node if the path doesn't exist if ( curr -> character [ key [ i ]] == nullptr ) { curr -> character [ key [ i ]] = new Trie (); } // go to the next node curr = curr -> character [ key [ i ]]; } // mark the current node as a leaf curr -> isLeaf = true ; } // Iterative function to search a key in a Trie. It returns true // if the key is found in the Trie; otherwise, it returns false bool Trie::search ( string key ) { // return false if Trie is empty if ( this == nullptr ) { return false ; } Trie * curr = this ; for ( int i = 0 ; i < key . length (); i ++ ) { // go to the next node curr = curr -> character [ key [ i ]]; // if the string is invalid (reached end of a path in the Trie) if ( curr == nullptr ) { return false ; } } // return true if the current node is a leaf and the // end of the string is reached return curr -> isLeaf ; } // Returns true if a given node has any children bool Trie::haveChildren ( Trie const * curr ) { for ( int i = 0 ; i < CHAR_SIZE ; i ++ ) { if ( curr -> character [ i ]) { return true ; // child found } } return false ; } // Recursive function to delete a key in the Trie bool Trie::deletion ( Trie *& curr , string key ) { // return if Trie is empty if ( curr == nullptr ) { return false ; } // if the end of the key is not reached if ( key . length ()) { // recur for the node corresponding to the next character in the key // and if it returns true, delete the current node (if it is non-leaf) if ( curr != nullptr && curr -> character [ key [ 0 ]] != nullptr && deletion ( curr -> character [ key [ 0 ]], key . substr ( 1 )) && curr -> isLeaf == false ) { if ( ! haveChildren ( curr )) { delete curr ; curr = nullptr ; return true ; } else { return false ; } } } // if the end of the key is reached if ( key . length () == 0 && curr -> isLeaf ) { // if the current node is a leaf node and doesn't have any children if ( ! haveChildren ( curr )) { // delete the current node delete curr ; curr = nullptr ; // delete the non-leaf parent nodes return true ; } // if the current node is a leaf node and has children else { // mark the current node as a non-leaf node (DON'T DELETE IT) curr -> isLeaf = false ; // don't delete its parent nodes return false ; } } return false ; }","title":"Tries"},{"location":"DataStructures/advanced/#min-heap-max-heap","text":"","title":"Min Heap/ Max Heap"},{"location":"DataStructures/advanced/#disjoint-set","text":"","title":"Disjoint set"},{"location":"DataStructures/advanced/#fenwick-trees","text":"Array len = 10^5 Queries = 10^5 1. replace arr[i] 2. Find sum from l..r Finding right most set bit of x: x = a 1 b where a is any random number and b is all 0s x = 0101 1 0000 -x = a' 1 b where a' can be ignored and b is all 0s -x is 2's complement i.e. 1's complement i.e. 101001111 +1 -x = 1010 1 1111 x & -x = 0000 1 0000 Fenwick tree ( BIT[i] ) stores such that, at any index i we can store sum of some numbers (j+1...i) of the given array. This can also be called a partial sum tree. Here j is obtained by making last set bit of i as 0 ie. i-(i&-1) . Always use 1 based indexing void update ( int x , int delta ) //add \"delta\" at index \"x\" { //while updating we keep adding delta to numbers obtained by adding x&-x for (; x <= n ; x += x &- x ) BIT [ x ] += delta ; } int sum ( int x ) //returns the sum of first x elements in given array a[] { //while getting sum, we keep adding BIT[i] where i is obtained by subtracting x&-x int sum = 0 ; for (; x > 0 ; x -= x &- x ) sum += BIT [ x ]; return sum ; } Inversion count problem can be solved using BIT. While traversing input array, update(+1) count of arr[i] by 1. So BIT(x) will give count of numbers till x. We want to find already present count of numbers greater than current i.e. BIT(max) - BIT(arr[i]) vector < int > input = {}; vector < int > bit ( input . size () + 1 ); int count = 0 ; for ( int i = 0 ; i < input . size (); i ++ ) { //first check numbers greater than input[i] till i count += sum ( max ) - sum ( input [ i ]); //add input[i] update ( input [ i ], 1 ); }","title":"Fenwick Trees"},{"location":"DataStructures/basic/","text":"Basic Data Structures array fixed-size sequence containers hold a specific number of elements ordered in a strict linear sequence (contiguous) Zero-sized arrays are valid, but they should not be dereferenced vector sequence containers representing arrays that can change in size contiguous storage locations unlike arrays, their size can change dynamically, with their storage being handled automatically by the container. vector containers may allocate some extra storage to accommodate for possible growth, and thus the container may have an actual capacity greater than the storage strictly needed to contain its elements set store unique elements following a specific order set uses Red Black tree (balance binary search tree) unordered_set uses hash table multiset can have repeated elements unordered_multiset can have repeated elements which is implemented as hash table stack designed to operate in a LIFO context queue designed to operate in a FIFO context Elements are pushed into the \"back\" of the specific container and popped from its \"front\" priority_queue: designed such that its first element is always the greatest of the elements it contains, according to some strict weak ordering criterion (heap) priority_queue: elements can be inserted at any moment, and only the max heap element can be retrieved list sequence containers that allow constant time insert and erase operations anywhere within the sequence, and iteration in both directions. implemented as doubly-linked lists forward_list are implemented as singly-linked lists list and forward_list both lack direct access to the elements by their position map map: store elements formed by a combination of a key value and a mapped value, following a specific order. map: Implemented as balanced binary search tree (Red Black Tree) multimap: multiple elements can have equivalent keys unordered_map Implemented as hashtable unordered_multimap allows different elements to have equivalent keys","title":"Basic"},{"location":"DataStructures/basic/#basic-data-structures","text":"","title":"Basic Data Structures"},{"location":"DataStructures/basic/#array","text":"fixed-size sequence containers hold a specific number of elements ordered in a strict linear sequence (contiguous) Zero-sized arrays are valid, but they should not be dereferenced","title":"array"},{"location":"DataStructures/basic/#vector","text":"sequence containers representing arrays that can change in size contiguous storage locations unlike arrays, their size can change dynamically, with their storage being handled automatically by the container. vector containers may allocate some extra storage to accommodate for possible growth, and thus the container may have an actual capacity greater than the storage strictly needed to contain its elements","title":"vector"},{"location":"DataStructures/basic/#set","text":"store unique elements following a specific order set uses Red Black tree (balance binary search tree) unordered_set uses hash table multiset can have repeated elements unordered_multiset can have repeated elements which is implemented as hash table","title":"set"},{"location":"DataStructures/basic/#stack","text":"designed to operate in a LIFO context","title":"stack"},{"location":"DataStructures/basic/#queue","text":"designed to operate in a FIFO context Elements are pushed into the \"back\" of the specific container and popped from its \"front\" priority_queue: designed such that its first element is always the greatest of the elements it contains, according to some strict weak ordering criterion (heap) priority_queue: elements can be inserted at any moment, and only the max heap element can be retrieved","title":"queue"},{"location":"DataStructures/basic/#list","text":"sequence containers that allow constant time insert and erase operations anywhere within the sequence, and iteration in both directions. implemented as doubly-linked lists forward_list are implemented as singly-linked lists list and forward_list both lack direct access to the elements by their position","title":"list"},{"location":"DataStructures/basic/#map","text":"map: store elements formed by a combination of a key value and a mapped value, following a specific order. map: Implemented as balanced binary search tree (Red Black Tree) multimap: multiple elements can have equivalent keys unordered_map Implemented as hashtable unordered_multimap allows different elements to have equivalent keys","title":"map"},{"location":"DataStructures/vadvanced/","text":"Basic Data Structures AVL Tree Red Black Tree B+ Tree Treap Fenwick Tree Fib Heap Interval Trees (Augmenting DS) van Emde Boas Treee","title":"Very Advanced"},{"location":"DataStructures/vadvanced/#basic-data-structures","text":"","title":"Basic Data Structures"},{"location":"DataStructures/vadvanced/#avl-tree","text":"","title":"AVL Tree"},{"location":"DataStructures/vadvanced/#red-black-tree","text":"","title":"Red Black Tree"},{"location":"DataStructures/vadvanced/#b-tree","text":"","title":"B+ Tree"},{"location":"DataStructures/vadvanced/#treap","text":"","title":"Treap"},{"location":"DataStructures/vadvanced/#fenwick-tree","text":"","title":"Fenwick Tree"},{"location":"DataStructures/vadvanced/#fib-heap","text":"","title":"Fib Heap"},{"location":"DataStructures/vadvanced/#interval-trees-augmenting-ds","text":"","title":"Interval Trees (Augmenting DS)"},{"location":"DataStructures/vadvanced/#van-emde-boas-treee","text":"","title":"van Emde Boas Treee"},{"location":"EmbeddedSystems/LinuxDeviceDrivers/","text":"Driver Basic Code structure https://tldp.org/LDP/lkmpg/2.4/html/book1.htm Following command displays information about the drivers modinfo hello_world_module.ko MODULE_LICENSE ( \"GPL\" ); MODULE_AUTHOR ( \"Author\" ); MODULE_DESCRIPTION ( \"A sample driver\" ); MODULE_VERSION ( \"2:1.0\" ); Kernel modules require a different set of header files than user programs require. And keep in mind, Module code should not invoke user space Libraries or API\u2019s or System calls. insmod installs kernel module (.ko) and rmmod removes kernel module. //Called first on insmod static int __init hello_world_init ( void ) /* Constructor */ { return 0 ; } module_init ( hello_world_init ); //Called on rmmod void __exit hello_world_exit ( void ) { } module_exit ( hello_world_exit ); Logging: Log levels: KERN_EMERG, KERN_ALERT, KERN_CRIT, KERN_ERR, KERN_WARNING, KERN_NOTICE, KERN_INFO, KERN_DEBUG printk(KERN_INFO \"Welcome To EmbeTronicX\"); Sample Linux driver #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> /* ** Module Init function */ static int __init hello_world_init ( void ) { printk ( KERN_INFO \"This is the Simple Module \\n \" ); printk ( KERN_INFO \"Kernel Module Inserted Successfully... \\n \" ); return 0 ; } /* ** Module Exit function */ static void __exit hello_world_exit ( void ) { printk ( KERN_INFO \"Kernel Module Removed Successfully... \\n \" ); } module_init ( hello_world_init ); module_exit ( hello_world_exit ); MODULE_LICENSE ( \"GPL\" ); MODULE_AUTHOR ( \"Author Name\" ); MODULE_DESCRIPTION ( \"A simple hello world driver\" ); MODULE_VERSION ( \"2:1.0\" ); Sample makefile obj - m += hello_world . o ifdef ARCH #You can update your Beaglebone path here. KDIR = / home / username / BBG / tmp / lib / modules / 5.10.65 / build else KDIR = / lib / modules / $ ( shell uname - r ) / build endif all : make - C $ ( KDIR ) M = $ ( shell pwd ) modules clean : make - C $ ( KDIR ) M = $ ( shell pwd ) clean sudo make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- Passing Arguments Permissions : S_IWUSR S_IRUSR S_IXUSR S_IRGRP S_IWGRP S_IXGRP In this S_I is a common header. R = read ,W =write ,X= Execute. USR =user ,GRP =Group Using OR \u2018|\u2019 (or operation) we can set multiple permissions at a time. module_param(name, type, perm); Takes three parameters: the name of the variable, its type, and a permissions mask to be used for an accompanying sysfs entry. module_param() macro creates the sub-directory under /sys/module. For example, module_param(valueETX, int, S_IWUSR|S_IRUSR); This will create a sysfs entry. (/sys/module/hello_world_module/parameters/valueETX) module_param(valueETX, int, S_IWUSR|S_IRUSR); This will create a sysfs entry. (/sys/module/hello_world_module/parameters/valueETX) Supported types are bool, invbool, charp, int, long, short, uint, ulong, ushort module_param_array() This macro is used to send the array as an argument to the Linux device driver. Array parameters, where the values are supplied as a comma-separated list, are also supported by the module loader. To declare an array parameter, use: module_param_array(name,type,num,perm); module_param_cb() This macro is used to register the callback. Whenever the argument (parameter) got changed, this callback function will be called. By using this module_param_cb() macro, we can get a notification on change of file for given argument. If you want to get a notification whenever the value got to change, we need to register our handler function to its file operation structure first. struct kernel_param_ops { int ( set)(const char val, const struct kernel_param kp); int ( get)(char buffer, const struct kernel_param kp); void ( free)(void arg); }; Major number and minor number User space -> Device file -> Major number, Minor number -> Driver -> Hardware Initially, the Application will open the device file. This device file is created by the device driver). Then this device file will find the corresponding device driver using major and minor numbers. Then that Device driver will talk to the Hardware device. In linux, everything is a file even a device. To create a device file, we need to know about major number and minor number Major number -> Driver (Can be same for multiple devices) Minor number -> individual physical device (hw device, present at different memory locations) Allocation : Static With registration, you tell the kernel what device numbers you want (the start major/minor number and count) and it either gives them to you or not (depending on availability). int register_chrdev_region(dev_t first, unsigned int count, char *name); dev_t dev = MKDEV(235, 0); register_chrdev_region(dev, 1, \"Embetronicx_Dev\"); void unregister_chrdev_region(dev_t first, unsigned int count); Dynamic With allocation, you tell the kernel how many device numbers you need (the starting minor number and count) and it will find a starting major number for you, if one is available, of course. dev_t dev = 0; alloc_chrdev_region(&dev, 0, 1, \"Embetronicx_Dev\") Dynamic is better since it avoids conflicts and you don't need to maintain static allocation. dev_t is a 32-bit quantity with 12 bits set aside for the major number and 20 for the minor number. MKDEV(int major, int minor); Summary Calls init on insmod, exit on rmmod For passing arguments, file is created in /sys/module to accept parameters. Dynamic modification of files for parameters accepted using module_param and module_param_array won't have any effect on kernel module. We need to get some notification whenever there is a change. For that we use module_param_cb which accepts pointer to kernel_param_ops object. User space -> Device file -> Major number, Minor number -> Driver -> Hardware We need to allocate major number for driver and minor number (count for devices) We can allocate the major and minor numbers in two ways. Initially, the Application will open the device file. This device file is created by the device driver). Then this device file will find the corresponding device driver using major and minor numbers. Then that Device driver will talk to the Hardware device. In linux, everything is a file even a device. To create a device file, we need to know about major number and minor number Major number -> Driver (Can be same for multiple devices) Minor number -> individual physical device (hw device, present at different memory locations) Allocation : Static With registration, you tell the kernel what device numbers you want (the start major/minor number and count) and it either gives them to you or not (depending on availability). int register_chrdev_region(dev_t first, unsigned int count, char *name); dev_t dev = MKDEV(235, 0); register_chrdev_region(dev, 1, \"Embetronicx_Dev\"); void unregister_chrdev_region(dev_t first, unsigned int count); Dynamic With allocation, you tell the kernel how many device numbers you need (the starting minor number and count) and it will find a starting major number for you, if one is available, of course. dev_t dev = 0; alloc_chrdev_region(&dev, 0, 1, \"Embetronicx_Dev\") Dynamic is better since it avoids conflicts and you don't need to maintain static allocation. dev_t is a 32-bit quantity with 12 bits set aside for the major number and 20 for the minor number. MKDEV(int major, int minor); cat /proc/devices lists all major numbers assigned and drivers. (Name is inappropriate as it lists drivers and not devices) Each device on the system has corresponding device file in /dev/ e.g. /dev/ttyS0 But all files from /dev/ don't necessarily correspond to hardware devices e.g. /dev/null Device file creation: Manual mknod -m sudo mknod -m 666 /dev/etx_device c 246 0 device type = c/b character / block Automatic Include the header file linux/device.h and linux/kdev_t.h Create the struct Class Following will create a file in /sys/class struct class * class_create (struct module owner, const char name); void class_destroy (struct class * cls); Now create a device: Create Device with the class which is created by the above step struct device device_create (struct class, struct device parent, dev_t dev, void * drvdata, const char fmt, ...); dev_t dev = 0 ; static struct class * dev_class ; static int __init hello_world_init ( void ) { alloc_chrdev_region ( & dev , 0 , 1 , \"etx_Dev\" ); dev_class = class_create ( THIS_MODULE , \"etx_class\" ); device_create ( dev_class , NULL , dev , NULL , \"etx_device\" ); } If you want to perform any file operation on device file created, we need to register fops using cdev. When we create device file in /dev/, kernel maintains inode pointer for that file. inode pointer can point to char/block/pipe. In this case, we need to point to char device. so we need to set i_cdev. This is set by cdev_init(&etx_cdev,&fops); cdev_add(&etx_cdev,dev,1); So now any device file created using this driver(major number) will use these fops. inode: https://github.com/torvalds/linux/blob/master/include/linux/fs.h cdev: https://github.com/torvalds/linux/blob/master/include/linux/cdev.h There are many ways to Communicate between the Userspace and Kernel Space, they are: IOCTL Procfs Sysfs Configfs Debugfs Sysctl UDP Sockets Netlink Sockets https://stackoverflow.com/questions/7137209/difference-between-softirqs-and-tasklets?rq=1 IOCTL Steps involved in IOCTL There are some steps involved to use IOCTL. Create IOCTL command in driver define \"ioctl name\" __IOX(\"magic number\",\"command number\",\"type\") _IO, _IOW, _IOR, _IORW are helper macros to create a unique ioctl identifier and add the required R/W needed features magic number could be major number, or any unique number specific to driver command number is specific to individual command for given driver. e.g. tty driver has major number to uniquely identify tty driver. Now we need to uniquely identify each ioctl command for tty driver e.g. set_baud_rate, set_encoding, etc. So we will assign unique command numbers for each command. type could be int, char, int , char , etc. We need unqiue number created from _IOX in both userspace and kernel space. Write IOCTL function in the driver int ioctl(struct inode inode,struct file file,unsigned int cmd,unsigned long arg) Create IOCTL command in a Userspace application define WR_VALUE _IOW('a','a',int32_t*) define RD_VALUE _IOR('a','b',int32_t*) Use the IOCTL system call in a Userspace long ioctl( \"file descriptor\",\"ioctl command\",\"Arguments\"); PROCFS This is another way to communicate to kernel space drivers. We create file in /proc and register fops for that file in driver. Whenever we write anything to /proc/ file, fops functions registered would be called. procfs resides in memory. [optional]Create procfs directory struct proc_dir_entry proc_mkdir(const char name, struct proc_dir_entry *parent) Create procfs entry <5.10 struct proc_dir_entry proc_create ( const char name, umode_t mode, struct proc_dir_entry parent, const struct file_operations proc_fops ) 5.10 struct proc_dir_entry proc_create(const char name, umode_t mode, struct proc_dir_entry parent, const struct proc_ops proc_ops); if parent pointer is null, then directly create in /proc/ Note that You need to pass file_operations/ proc_ops pointer to create proc entry. static struct proc_ops proc_fops = { .proc_open = open_proc, .proc_read = read_proc, .proc_write = write_proc, .proc_release = release_proc }; Waitqueues are used to suspend execution of somethreads and wake them on some condition or signal. Initialize wq: wait_queue_head_t wq; init_waitqueue_head (&wq); Suspend wait_event wait_event_timeout wait_event_cmd wait_event_interruptible wait_event_interruptible_timeout wait_event_killable Wake up: wake_up wake_up_all wake_up_interruptible wake_up_sync and wake_up_interruptible_sync Create a thread and from that new thread You can suspend yourself till some condition returns true. //example thread function static int wait_function ( void * unused ) { while ( 1 ) { pr_info ( \"Waiting For Event... \\n \" ); wait_event_interruptible ( wait_queue_etx , wait_queue_flag != 0 ); if ( wait_queue_flag == 2 ) { pr_info ( \"Event Came From Exit Function \\n \" ); return 0 ; } pr_info ( \"Event Came From Read Function - %d \\n \" , ++ read_count ); wait_queue_flag = 0 ; } do_exit ( 0 ); return 0 ; } //fops read which causes above thread to wake up static ssize_t etx_read ( struct file * filp , char __user * buf , size_t len , loff_t * off ) { pr_info ( \"Read Function \\n \" ); wait_queue_flag = 1 ; wake_up_interruptible ( & wait_queue_etx ); return 0 ; } SYSFS This is similar to procfs but developed after procfs as procfs had become very complex due to its use for dumping data. Implementation wise instead of using proc_ops, we are using kobject with show,store. Here kobject binds sysfs and kernel. struct kobject { char k_name; char name[KOBJ_NAME_LEN]; struct kref kref; struct list_head entry; struct kobject parent; struct kset kset; struct kobj_type ktype; struct dentry *dentry; }; Create directory in sysfs struct kobject * kobject_create_and_add ( const char * name, struct kobject * parent); Create sysfs file int sysfs_create_file ( struct kobject * kobj, const struct attribute * attr); struct kobj_attribute { struct attribute attr; ssize_t ( show)(struct kobject kobj, struct kobj_attribute attr, char buf); ssize_t ( store)(struct kobject kobj, struct kobj_attribute attr, const char buf, size_t count); }; Macro : Pass show and store pointer to __ATTR(name, permission, show_ptr, store_ptr); Interrupts There are 2 types of kernel contexts If related to userspace process -> process context If related to other interrupts (not syscalls) -> interrupt context Code executing from interrupt context cannot do the following: Go to sleep or relinquish the processor Acquire a mutex Perform time-consuming tasks Access user space virtual memory Consider isr as top half (time critical) + bottom half (long task). So disable interrupts while performing top half and re-enable interrupts so that we don't miss any other interrupts. There are 4 bottom half mechanisms are available in Linux: Workqueue Threaded IRQs Softirq Tasklets Important points to remember while writing interrupts: Interrupt handlers can not enter sleep, so to avoid calls to some functions which has sleep. When the interrupt handler has part of the code to enter the critical section, use spinlocks lock, rather than mutexes. Because if it couldn\u2019t take mutex it will go to sleep until it takes the mute. Interrupt handlers can not exchange data with the userspace. The interrupt handlers must be executed as soon as possible. To ensure this, it is best to split the implementation into two parts, the top half and the bottom half. The top half of the handler will get the job done as soon as possible and then work late on the bottom half, which can be done with softirq or tasklet or workqueue. Interrupt handlers can not be called repeatedly. When a handler is already executing, its corresponding IRQ must be disabled until the handler is done. Interrupt handlers can be interrupted by higher authority handlers. If you want to avoid being interrupted by a highly qualified handler, you can mark the interrupt handler as a fast handler. However, if too many are marked as fast handlers, the performance of the system will be degraded, because the interrupt latency will be longer. Register IRQ NO and irq_handler, so that on that interrupt isr irq_handler is called. if (request_irq(IRQ_NO, irq_handler, IRQF_SHARED, \"etx_device\", (void *)(irq_handler))) { printk(KERN_INFO \"my_device: cannot register IRQ \"); goto irq; } Spinlocks Difference between mutex, spin_lock_try Notes; 1. You can not sleep or give processor in irq 2. There are only 2 types of interrupts 1. Preemptible 2. Non-preemptible https://www.kernel.org/doc/htmldocs/kernel-locking/cheatsheet.html User context - User context -> even mutex is fine here, spin_lock Bottom half - Bottom half -> spin_lock as no other bottom half(pre-emptible type irq) will run on that cpu User context - Bottom Half -> Need to disable soft interrupts Bottom Half - Hard IRQ -> Need to disable all interrupts Hard IRQ - Hard IRQ -> Need to disable all interrupts If you want to check if function is running in interrupt context call in_ interrupt( ) returns non-zero if in interrupt context (hw/sw) 0 Timers : This timer callback function will be executed from the interrupt context. line 426 (no sleep or giving up processor) Repeated timer implementation: __init__ { /* setup your timer to call my_timer_callback */ timer_setup(&etx_timer, timer_callback, 0); /* setup timer interval to based on TIMEOUT Macro */ mod_timer(&etx_timer, jiffies + msecs_to_jiffies(TIMEOUT)); } //Timer Callback function. This will be called when timer expires void timer_callback(struct timer_list * data) { /* do your timer stuff here */ pr_info(\"Timer Callback function Called [%d]\\n\",count++); /* Re-enable timer. Because this function will be called only first time. If we re-enable this will work like periodic timer. */ mod_timer(&etx_timer, jiffies + msecs_to_jiffies(TIMEOUT)); } HZ -> Number of times jiffies is incremented in 1 second i.e. number of ticks in 1 second High resolution timer //Timer Callback function. This will be called when timer expires enum hrtimer_restart timer_callback ( struct hrtimer * timer ) { /* do your timer stuff here */ pr_info ( \"Timer Callback function Called [%d] \\n \" , count ++ ); hrtimer_forward_now ( timer , ktime_set ( TIMEOUT_SEC , TIMEOUT_NSEC )); return HRTIMER_RESTART ; } __init { ktime = ktime_set ( TIMEOUT_SEC , TIMEOUT_NSEC ); hrtimer_init ( & etx_hr_timer , CLOCK_MONOTONIC , HRTIMER_MODE_REL ); etx_hr_timer . function = & timer_callback ; hrtimer_start ( & etx_hr_timer , ktime , HRTIMER_MODE_REL ); } #define TIMEOUT_NSEC ( 1000000000L ) //1 second in nano seconds #define TIMEOUT_SEC ( 4 ) //4 seconds Completion DECLARE_COMPLETION ( data_read_done ); /* ** Waitqueue thread */ static int wait_function ( void * unused ) { while ( 1 ) { pr_info ( \"Waiting For Event... \\n \" ); wait_for_completion ( & data_read_done ); if ( completion_flag == 2 ) { pr_info ( \"Event Came From Exit Function \\n \" ); return 0 ; } pr_info ( \"Event Came From Read Function - %d \\n \" , ++ read_count ); completion_flag = 0 ; } do_exit ( 0 ); return 0 ; } static ssize_t etx_read ( struct file * filp , char __user * buf , size_t len , loff_t * off ) { pr_info ( \"Read Function \\n \" ); completion_flag = 1 ; if ( ! completion_done ( & data_read_done )) { //to see if completion has any waiters. 0-> if waiters present complete ( & data_read_done ); } return 0 ; } __init { //Create the kernel thread with name 'mythread' wait_thread = kthread_create ( wait_function , NULL , \"WaitThread\" ); if ( wait_thread ) { pr_info ( \"Thread Created successfully \\n \" ); wake_up_process ( wait_thread ); } } __exit (){ completion_flag = 2 ; if ( ! completion_done ( & data_read_done )) { complete ( & data_read_done ); } } EXPORT_SYMBOL file1: EXPORT_SYMBOL(foo) define foo file2: extern foo Make sure you insmod file1.ko first. Atomic Variables: Generally we need locks to access shared variables/data. But we can skip locks with atomic variables. Types: variables on int variables on bits Operations: atomic_read : int atomic_read(atomic_t v); atomic_set : void atomic_set(atomic_t v, int i); atomic_add : void atomic_add(int i, atomic_t v); atomic_sub : void atomic_sub(int i, atomic_t v); atomic_inc : void atomic_inc (atomic_t v); atomic_dec : void atomic_dec (atomic_t v); atomic_sub_and_test : void atomic_sub_and_test(int i, atomic_t v); atomic_dec_and_test : void atomic_dec_and_test(atomic_t v); void atomic_inc_and_test(atomic_t v); void atomic_add_negative(int i, atomic_t v); void atomic_add_return(int i, atomic_t *v); void set_bit(int nr, void addr) Atomically set the nr-th bit starting from addr void clear_bit(int nr, void addr) Atomically clear the nr-th bit starting from addr void change_bit(int nr, void addr) Atomically flip the value of the nr-th bit starting from addr int test_and_set_bit(int nr, void addr) Atomically set the nr-th bit starting from addr and return the previous value int test_and_clear_bit(int nr, void addr) Atomically clear the nr-th bit starting from addr and return the previous value int test_and_change_bit(int nr, void addr) Atomically flip the nr-th bit starting from addr and return the previous value int test_bit(int nr, void addr) Atomically return the value of the nr-th bit starting from addr int find_first_zero_bit(unsigned long addr, unsigned int size) Atomically returns the bit-number of the first zero bit, not the number of the byte containing a bit int find_first_bit(unsigned long *addr, unsigned int size) Atomically returns the bit-number of the first set bit, not the number of the byte containing a bit When read operations >>>> write operations but write operations should be fast, use seqlock","title":"LinuxDeviceDrivers"},{"location":"EmbeddedSystems/LinuxDeviceDrivers/#driver-basic-code-structure","text":"https://tldp.org/LDP/lkmpg/2.4/html/book1.htm Following command displays information about the drivers modinfo hello_world_module.ko MODULE_LICENSE ( \"GPL\" ); MODULE_AUTHOR ( \"Author\" ); MODULE_DESCRIPTION ( \"A sample driver\" ); MODULE_VERSION ( \"2:1.0\" ); Kernel modules require a different set of header files than user programs require. And keep in mind, Module code should not invoke user space Libraries or API\u2019s or System calls. insmod installs kernel module (.ko) and rmmod removes kernel module. //Called first on insmod static int __init hello_world_init ( void ) /* Constructor */ { return 0 ; } module_init ( hello_world_init ); //Called on rmmod void __exit hello_world_exit ( void ) { } module_exit ( hello_world_exit ); Logging: Log levels: KERN_EMERG, KERN_ALERT, KERN_CRIT, KERN_ERR, KERN_WARNING, KERN_NOTICE, KERN_INFO, KERN_DEBUG printk(KERN_INFO \"Welcome To EmbeTronicX\"); Sample Linux driver #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> /* ** Module Init function */ static int __init hello_world_init ( void ) { printk ( KERN_INFO \"This is the Simple Module \\n \" ); printk ( KERN_INFO \"Kernel Module Inserted Successfully... \\n \" ); return 0 ; } /* ** Module Exit function */ static void __exit hello_world_exit ( void ) { printk ( KERN_INFO \"Kernel Module Removed Successfully... \\n \" ); } module_init ( hello_world_init ); module_exit ( hello_world_exit ); MODULE_LICENSE ( \"GPL\" ); MODULE_AUTHOR ( \"Author Name\" ); MODULE_DESCRIPTION ( \"A simple hello world driver\" ); MODULE_VERSION ( \"2:1.0\" ); Sample makefile obj - m += hello_world . o ifdef ARCH #You can update your Beaglebone path here. KDIR = / home / username / BBG / tmp / lib / modules / 5.10.65 / build else KDIR = / lib / modules / $ ( shell uname - r ) / build endif all : make - C $ ( KDIR ) M = $ ( shell pwd ) modules clean : make - C $ ( KDIR ) M = $ ( shell pwd ) clean sudo make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-","title":"Driver Basic Code structure"},{"location":"EmbeddedSystems/LinuxDeviceDrivers/#passing-arguments","text":"Permissions : S_IWUSR S_IRUSR S_IXUSR S_IRGRP S_IWGRP S_IXGRP In this S_I is a common header. R = read ,W =write ,X= Execute. USR =user ,GRP =Group Using OR \u2018|\u2019 (or operation) we can set multiple permissions at a time. module_param(name, type, perm); Takes three parameters: the name of the variable, its type, and a permissions mask to be used for an accompanying sysfs entry. module_param() macro creates the sub-directory under /sys/module. For example, module_param(valueETX, int, S_IWUSR|S_IRUSR); This will create a sysfs entry. (/sys/module/hello_world_module/parameters/valueETX) module_param(valueETX, int, S_IWUSR|S_IRUSR); This will create a sysfs entry. (/sys/module/hello_world_module/parameters/valueETX) Supported types are bool, invbool, charp, int, long, short, uint, ulong, ushort module_param_array() This macro is used to send the array as an argument to the Linux device driver. Array parameters, where the values are supplied as a comma-separated list, are also supported by the module loader. To declare an array parameter, use: module_param_array(name,type,num,perm); module_param_cb() This macro is used to register the callback. Whenever the argument (parameter) got changed, this callback function will be called. By using this module_param_cb() macro, we can get a notification on change of file for given argument. If you want to get a notification whenever the value got to change, we need to register our handler function to its file operation structure first. struct kernel_param_ops { int ( set)(const char val, const struct kernel_param kp); int ( get)(char buffer, const struct kernel_param kp); void ( free)(void arg); };","title":"Passing Arguments"},{"location":"EmbeddedSystems/LinuxDeviceDrivers/#major-number-and-minor-number","text":"User space -> Device file -> Major number, Minor number -> Driver -> Hardware Initially, the Application will open the device file. This device file is created by the device driver). Then this device file will find the corresponding device driver using major and minor numbers. Then that Device driver will talk to the Hardware device. In linux, everything is a file even a device. To create a device file, we need to know about major number and minor number Major number -> Driver (Can be same for multiple devices) Minor number -> individual physical device (hw device, present at different memory locations) Allocation : Static With registration, you tell the kernel what device numbers you want (the start major/minor number and count) and it either gives them to you or not (depending on availability). int register_chrdev_region(dev_t first, unsigned int count, char *name); dev_t dev = MKDEV(235, 0); register_chrdev_region(dev, 1, \"Embetronicx_Dev\"); void unregister_chrdev_region(dev_t first, unsigned int count); Dynamic With allocation, you tell the kernel how many device numbers you need (the starting minor number and count) and it will find a starting major number for you, if one is available, of course. dev_t dev = 0; alloc_chrdev_region(&dev, 0, 1, \"Embetronicx_Dev\") Dynamic is better since it avoids conflicts and you don't need to maintain static allocation. dev_t is a 32-bit quantity with 12 bits set aside for the major number and 20 for the minor number. MKDEV(int major, int minor);","title":"Major number and minor number"},{"location":"EmbeddedSystems/LinuxDeviceDrivers/#summary","text":"Calls init on insmod, exit on rmmod For passing arguments, file is created in /sys/module to accept parameters. Dynamic modification of files for parameters accepted using module_param and module_param_array won't have any effect on kernel module. We need to get some notification whenever there is a change. For that we use module_param_cb which accepts pointer to kernel_param_ops object. User space -> Device file -> Major number, Minor number -> Driver -> Hardware We need to allocate major number for driver and minor number (count for devices) We can allocate the major and minor numbers in two ways. Initially, the Application will open the device file. This device file is created by the device driver). Then this device file will find the corresponding device driver using major and minor numbers. Then that Device driver will talk to the Hardware device. In linux, everything is a file even a device. To create a device file, we need to know about major number and minor number Major number -> Driver (Can be same for multiple devices) Minor number -> individual physical device (hw device, present at different memory locations) Allocation : Static With registration, you tell the kernel what device numbers you want (the start major/minor number and count) and it either gives them to you or not (depending on availability). int register_chrdev_region(dev_t first, unsigned int count, char *name); dev_t dev = MKDEV(235, 0); register_chrdev_region(dev, 1, \"Embetronicx_Dev\"); void unregister_chrdev_region(dev_t first, unsigned int count); Dynamic With allocation, you tell the kernel how many device numbers you need (the starting minor number and count) and it will find a starting major number for you, if one is available, of course. dev_t dev = 0; alloc_chrdev_region(&dev, 0, 1, \"Embetronicx_Dev\") Dynamic is better since it avoids conflicts and you don't need to maintain static allocation. dev_t is a 32-bit quantity with 12 bits set aside for the major number and 20 for the minor number. MKDEV(int major, int minor); cat /proc/devices lists all major numbers assigned and drivers. (Name is inappropriate as it lists drivers and not devices) Each device on the system has corresponding device file in /dev/ e.g. /dev/ttyS0 But all files from /dev/ don't necessarily correspond to hardware devices e.g. /dev/null Device file creation: Manual mknod -m sudo mknod -m 666 /dev/etx_device c 246 0 device type = c/b character / block Automatic Include the header file linux/device.h and linux/kdev_t.h Create the struct Class Following will create a file in /sys/class struct class * class_create (struct module owner, const char name); void class_destroy (struct class * cls); Now create a device: Create Device with the class which is created by the above step struct device device_create (struct class, struct device parent, dev_t dev, void * drvdata, const char fmt, ...); dev_t dev = 0 ; static struct class * dev_class ; static int __init hello_world_init ( void ) { alloc_chrdev_region ( & dev , 0 , 1 , \"etx_Dev\" ); dev_class = class_create ( THIS_MODULE , \"etx_class\" ); device_create ( dev_class , NULL , dev , NULL , \"etx_device\" ); } If you want to perform any file operation on device file created, we need to register fops using cdev. When we create device file in /dev/, kernel maintains inode pointer for that file. inode pointer can point to char/block/pipe. In this case, we need to point to char device. so we need to set i_cdev. This is set by cdev_init(&etx_cdev,&fops); cdev_add(&etx_cdev,dev,1); So now any device file created using this driver(major number) will use these fops. inode: https://github.com/torvalds/linux/blob/master/include/linux/fs.h cdev: https://github.com/torvalds/linux/blob/master/include/linux/cdev.h There are many ways to Communicate between the Userspace and Kernel Space, they are: IOCTL Procfs Sysfs Configfs Debugfs Sysctl UDP Sockets Netlink Sockets https://stackoverflow.com/questions/7137209/difference-between-softirqs-and-tasklets?rq=1","title":"Summary"},{"location":"EmbeddedSystems/LinuxDeviceDrivers/#ioctl","text":"Steps involved in IOCTL There are some steps involved to use IOCTL. Create IOCTL command in driver","title":"IOCTL"},{"location":"EmbeddedSystems/LinuxDeviceDrivers/#define-ioctl-name-__ioxmagic-numbercommand-numbertype","text":"_IO, _IOW, _IOR, _IORW are helper macros to create a unique ioctl identifier and add the required R/W needed features magic number could be major number, or any unique number specific to driver command number is specific to individual command for given driver. e.g. tty driver has major number to uniquely identify tty driver. Now we need to uniquely identify each ioctl command for tty driver e.g. set_baud_rate, set_encoding, etc. So we will assign unique command numbers for each command. type could be int, char, int , char , etc. We need unqiue number created from _IOX in both userspace and kernel space. Write IOCTL function in the driver int ioctl(struct inode inode,struct file file,unsigned int cmd,unsigned long arg) Create IOCTL command in a Userspace application","title":"define \"ioctl name\" __IOX(\"magic number\",\"command number\",\"type\")"},{"location":"EmbeddedSystems/LinuxDeviceDrivers/#define-wr_value-_iowaaint32_t","text":"","title":"define WR_VALUE _IOW('a','a',int32_t*)"},{"location":"EmbeddedSystems/LinuxDeviceDrivers/#define-rd_value-_iorabint32_t","text":"Use the IOCTL system call in a Userspace long ioctl( \"file descriptor\",\"ioctl command\",\"Arguments\");","title":"define RD_VALUE _IOR('a','b',int32_t*)"},{"location":"EmbeddedSystems/LinuxDeviceDrivers/#procfs","text":"This is another way to communicate to kernel space drivers. We create file in /proc and register fops for that file in driver. Whenever we write anything to /proc/ file, fops functions registered would be called. procfs resides in memory. [optional]Create procfs directory struct proc_dir_entry proc_mkdir(const char name, struct proc_dir_entry *parent) Create procfs entry <5.10 struct proc_dir_entry proc_create ( const char name, umode_t mode, struct proc_dir_entry parent, const struct file_operations proc_fops ) 5.10 struct proc_dir_entry proc_create(const char name, umode_t mode, struct proc_dir_entry parent, const struct proc_ops proc_ops); if parent pointer is null, then directly create in /proc/ Note that You need to pass file_operations/ proc_ops pointer to create proc entry. static struct proc_ops proc_fops = { .proc_open = open_proc, .proc_read = read_proc, .proc_write = write_proc, .proc_release = release_proc }; Waitqueues are used to suspend execution of somethreads and wake them on some condition or signal. Initialize wq: wait_queue_head_t wq; init_waitqueue_head (&wq); Suspend wait_event wait_event_timeout wait_event_cmd wait_event_interruptible wait_event_interruptible_timeout wait_event_killable Wake up: wake_up wake_up_all wake_up_interruptible wake_up_sync and wake_up_interruptible_sync Create a thread and from that new thread You can suspend yourself till some condition returns true. //example thread function static int wait_function ( void * unused ) { while ( 1 ) { pr_info ( \"Waiting For Event... \\n \" ); wait_event_interruptible ( wait_queue_etx , wait_queue_flag != 0 ); if ( wait_queue_flag == 2 ) { pr_info ( \"Event Came From Exit Function \\n \" ); return 0 ; } pr_info ( \"Event Came From Read Function - %d \\n \" , ++ read_count ); wait_queue_flag = 0 ; } do_exit ( 0 ); return 0 ; } //fops read which causes above thread to wake up static ssize_t etx_read ( struct file * filp , char __user * buf , size_t len , loff_t * off ) { pr_info ( \"Read Function \\n \" ); wait_queue_flag = 1 ; wake_up_interruptible ( & wait_queue_etx ); return 0 ; }","title":"PROCFS"},{"location":"EmbeddedSystems/LinuxDeviceDrivers/#sysfs","text":"This is similar to procfs but developed after procfs as procfs had become very complex due to its use for dumping data. Implementation wise instead of using proc_ops, we are using kobject with show,store. Here kobject binds sysfs and kernel. struct kobject { char k_name; char name[KOBJ_NAME_LEN]; struct kref kref; struct list_head entry; struct kobject parent; struct kset kset; struct kobj_type ktype; struct dentry *dentry; }; Create directory in sysfs struct kobject * kobject_create_and_add ( const char * name, struct kobject * parent); Create sysfs file int sysfs_create_file ( struct kobject * kobj, const struct attribute * attr); struct kobj_attribute { struct attribute attr; ssize_t ( show)(struct kobject kobj, struct kobj_attribute attr, char buf); ssize_t ( store)(struct kobject kobj, struct kobj_attribute attr, const char buf, size_t count); }; Macro : Pass show and store pointer to __ATTR(name, permission, show_ptr, store_ptr); Interrupts There are 2 types of kernel contexts If related to userspace process -> process context If related to other interrupts (not syscalls) -> interrupt context Code executing from interrupt context cannot do the following: Go to sleep or relinquish the processor Acquire a mutex Perform time-consuming tasks Access user space virtual memory Consider isr as top half (time critical) + bottom half (long task). So disable interrupts while performing top half and re-enable interrupts so that we don't miss any other interrupts. There are 4 bottom half mechanisms are available in Linux: Workqueue Threaded IRQs Softirq Tasklets Important points to remember while writing interrupts: Interrupt handlers can not enter sleep, so to avoid calls to some functions which has sleep. When the interrupt handler has part of the code to enter the critical section, use spinlocks lock, rather than mutexes. Because if it couldn\u2019t take mutex it will go to sleep until it takes the mute. Interrupt handlers can not exchange data with the userspace. The interrupt handlers must be executed as soon as possible. To ensure this, it is best to split the implementation into two parts, the top half and the bottom half. The top half of the handler will get the job done as soon as possible and then work late on the bottom half, which can be done with softirq or tasklet or workqueue. Interrupt handlers can not be called repeatedly. When a handler is already executing, its corresponding IRQ must be disabled until the handler is done. Interrupt handlers can be interrupted by higher authority handlers. If you want to avoid being interrupted by a highly qualified handler, you can mark the interrupt handler as a fast handler. However, if too many are marked as fast handlers, the performance of the system will be degraded, because the interrupt latency will be longer. Register IRQ NO and irq_handler, so that on that interrupt isr irq_handler is called. if (request_irq(IRQ_NO, irq_handler, IRQF_SHARED, \"etx_device\", (void *)(irq_handler))) { printk(KERN_INFO \"my_device: cannot register IRQ \"); goto irq; } Spinlocks Difference between mutex, spin_lock_try Notes; 1. You can not sleep or give processor in irq 2. There are only 2 types of interrupts 1. Preemptible 2. Non-preemptible https://www.kernel.org/doc/htmldocs/kernel-locking/cheatsheet.html User context - User context -> even mutex is fine here, spin_lock Bottom half - Bottom half -> spin_lock as no other bottom half(pre-emptible type irq) will run on that cpu User context - Bottom Half -> Need to disable soft interrupts Bottom Half - Hard IRQ -> Need to disable all interrupts Hard IRQ - Hard IRQ -> Need to disable all interrupts If you want to check if function is running in interrupt context call in_ interrupt( ) returns non-zero if in interrupt context (hw/sw) 0 Timers : This timer callback function will be executed from the interrupt context. line 426 (no sleep or giving up processor) Repeated timer implementation: __init__ { /* setup your timer to call my_timer_callback */ timer_setup(&etx_timer, timer_callback, 0); /* setup timer interval to based on TIMEOUT Macro */ mod_timer(&etx_timer, jiffies + msecs_to_jiffies(TIMEOUT)); } //Timer Callback function. This will be called when timer expires void timer_callback(struct timer_list * data) { /* do your timer stuff here */ pr_info(\"Timer Callback function Called [%d]\\n\",count++); /* Re-enable timer. Because this function will be called only first time. If we re-enable this will work like periodic timer. */ mod_timer(&etx_timer, jiffies + msecs_to_jiffies(TIMEOUT)); } HZ -> Number of times jiffies is incremented in 1 second i.e. number of ticks in 1 second High resolution timer //Timer Callback function. This will be called when timer expires enum hrtimer_restart timer_callback ( struct hrtimer * timer ) { /* do your timer stuff here */ pr_info ( \"Timer Callback function Called [%d] \\n \" , count ++ ); hrtimer_forward_now ( timer , ktime_set ( TIMEOUT_SEC , TIMEOUT_NSEC )); return HRTIMER_RESTART ; } __init { ktime = ktime_set ( TIMEOUT_SEC , TIMEOUT_NSEC ); hrtimer_init ( & etx_hr_timer , CLOCK_MONOTONIC , HRTIMER_MODE_REL ); etx_hr_timer . function = & timer_callback ; hrtimer_start ( & etx_hr_timer , ktime , HRTIMER_MODE_REL ); } #define TIMEOUT_NSEC ( 1000000000L ) //1 second in nano seconds #define TIMEOUT_SEC ( 4 ) //4 seconds Completion DECLARE_COMPLETION ( data_read_done ); /* ** Waitqueue thread */ static int wait_function ( void * unused ) { while ( 1 ) { pr_info ( \"Waiting For Event... \\n \" ); wait_for_completion ( & data_read_done ); if ( completion_flag == 2 ) { pr_info ( \"Event Came From Exit Function \\n \" ); return 0 ; } pr_info ( \"Event Came From Read Function - %d \\n \" , ++ read_count ); completion_flag = 0 ; } do_exit ( 0 ); return 0 ; } static ssize_t etx_read ( struct file * filp , char __user * buf , size_t len , loff_t * off ) { pr_info ( \"Read Function \\n \" ); completion_flag = 1 ; if ( ! completion_done ( & data_read_done )) { //to see if completion has any waiters. 0-> if waiters present complete ( & data_read_done ); } return 0 ; } __init { //Create the kernel thread with name 'mythread' wait_thread = kthread_create ( wait_function , NULL , \"WaitThread\" ); if ( wait_thread ) { pr_info ( \"Thread Created successfully \\n \" ); wake_up_process ( wait_thread ); } } __exit (){ completion_flag = 2 ; if ( ! completion_done ( & data_read_done )) { complete ( & data_read_done ); } } EXPORT_SYMBOL file1: EXPORT_SYMBOL(foo) define foo file2: extern foo Make sure you insmod file1.ko first. Atomic Variables: Generally we need locks to access shared variables/data. But we can skip locks with atomic variables. Types: variables on int variables on bits Operations: atomic_read : int atomic_read(atomic_t v); atomic_set : void atomic_set(atomic_t v, int i); atomic_add : void atomic_add(int i, atomic_t v); atomic_sub : void atomic_sub(int i, atomic_t v); atomic_inc : void atomic_inc (atomic_t v); atomic_dec : void atomic_dec (atomic_t v); atomic_sub_and_test : void atomic_sub_and_test(int i, atomic_t v); atomic_dec_and_test : void atomic_dec_and_test(atomic_t v); void atomic_inc_and_test(atomic_t v); void atomic_add_negative(int i, atomic_t v); void atomic_add_return(int i, atomic_t *v); void set_bit(int nr, void addr) Atomically set the nr-th bit starting from addr void clear_bit(int nr, void addr) Atomically clear the nr-th bit starting from addr void change_bit(int nr, void addr) Atomically flip the value of the nr-th bit starting from addr int test_and_set_bit(int nr, void addr) Atomically set the nr-th bit starting from addr and return the previous value int test_and_clear_bit(int nr, void addr) Atomically clear the nr-th bit starting from addr and return the previous value int test_and_change_bit(int nr, void addr) Atomically flip the nr-th bit starting from addr and return the previous value int test_bit(int nr, void addr) Atomically return the value of the nr-th bit starting from addr int find_first_zero_bit(unsigned long addr, unsigned int size) Atomically returns the bit-number of the first zero bit, not the number of the byte containing a bit int find_first_bit(unsigned long *addr, unsigned int size) Atomically returns the bit-number of the first set bit, not the number of the byte containing a bit When read operations >>>> write operations but write operations should be fast, use seqlock","title":"SYSFS"},{"location":"EmbeddedSystems/basiccmds/","text":"mmap sa_handler futex ( fast user space mutexes ) This is nothing but semaphore.","title":"Basiccmds"},{"location":"EmbeddedSystems/basiccmds/#mmap","text":"","title":"mmap"},{"location":"EmbeddedSystems/basiccmds/#sa_handler","text":"","title":"sa_handler"},{"location":"EmbeddedSystems/basiccmds/#futex-fast-user-space-mutexes","text":"This is nothing but semaphore.","title":"futex ( fast user space mutexes )"},{"location":"EmbeddedSystems/basiccodes/","text":"Thread creation //posix thread creation void * threadFunc ( void * arg ) { int tid = ( int ) arg ; //cast it back to int char * ret ; printf ( \"threadFunc entered with argument %d, stackspace for this starts from %p \\n \" , tid , & tid ); strcpy ( ret , \"This is a test\" ); //returned in ret pthread_exit ( ret ); //Implicitly called with default arguments if not written } init main ( int argc , char * argv []) { int nthreads = 2 ; if ( argc > 1 ) { nthreads = atoi ( argv [ 1 ]); } pthread_t * threads = malloc ( nthreads * sizeof ( nthreads )); int i = 0 ; for ( i = 0 ; i < nthreads ; i ++ ) { int rc = pthread_create ( & thid , NULL , thread , ( void * ) i ); //casting to void*, threadfunc will cast it back to int if ( rc ) { exit ( -1 ); //error } } void * ret ; //Wait for all previously created threads to finish and then join for ( i = 0 ; i < nthreads ; i ++ ) { int rc = pthread_join ( thid , & ret ); //&ret is passed to get status, null can also be passed if ( rc ) { exit ( -1 ); } } } pthread mutex pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER ; /* Alternate pthread_mutex initialization pthread_mutex_t lock; pthread_mutex_init ( &lock, NULL); */ int crit_var = 162 ; void * threadFunc ( void * arg ) { int tid = ( int ) arg ; //cast it back to int pthread_mutex_lock ( & lock ); crit_var ++ ; //perform operation on critical section pthread_mutex_unlock ( & lock ); } How are processes started in linux? Processes are started by processes. Userspace programs call fork, exec. 1st process is started by kernel. - Often configured as an argument to the kernel before kernel boots - Often called as init process Code snippet from linux -3.14 / init / main . c file :- if ( ! try_to_run_init_process ( \"/etc/preinit\" ) || ! try_to_run_init_process ( \"/sbin/init\" ) || ! try_to_run_init_process ( \"/etc/init\" ) || ! try_to_run_init_process ( \"/bin/init\" ) || ! try_to_run_init_process ( \"/bin/sh\" )) { return 0 ; } fork - New process has different pid - New process has only 1 thread. So be careful with locks in multithreaded process. Consider P1 has 2 threads. thread 2 has lock. thread 1 forks. P2 created will have only 1 thread and you will never get that lock as you had taken lock before but did not release. If you run exec in child process immediately after fork, then you would never need that lock and you will be fine. Return value from fork: - >0 : Running in parent process as parent process has received pid of child process - =0 : Running in child process, as child process has nothing to receive - <0 : error condition int main ( int argc , char * argv []) { printf ( \"Parent process pid=%d \\n \" , getpid ()); pid_t pid = fork (); if ( pid > 0 ) { //parent printf ( \"Parent process pid after fork =%d \\n \" , getpid ()); } else if ( pid == 0 ) { //child printf ( \"Child process pid after fork =%d \\n \" , getpid ()); //Everything is copied from parent process, address space, fd, etc. //Discard everything copied from parent and running new ls -l from child process using exec char * args [] = { \"ls\" , \"-l\" , null }; execv ( \"/bin/ls\" , args ); } else { //error } } The difference between execl and execv is the argument passing. execl require a list of arguments while execv require a vector of arguments. A list of arguments is useful if you know all the arguments at compile time. In your case the arguments will be entered by the user and you have to construct a vector of arguments at run time, so you should use one of the execv* functions. The functions with suffix p use the PATH environment variable to find the program (e.g. \"ls\"), without this you have to specify the full path (either absolute or relative to the current directory, e.g. \"/bin/ls\"). Using PATH is what shells normally do, so this seems to be the correct choice for you. The functions with suffix e allow to specify the environment for the process. Semaphores P() decrements (down()) V() increments (up()) Binary semaphore: sem = 1; sem.down(); //critical section sem.up() Signalling using sempahore In following example, T1 is kept in blocked state since it tries to down sem but initial value of sem is 0. Now we want T1 to run only after T2 finishes. So we do sem.up() when T2 ends. This causes T1 to be ready. So T2 has signalled T1. sem = 0 ; T1 T2 ThreadJoin () { ThreadFinish () { sem . down (); sem . up (); } } Handling interrupts in c void signal_callback_handler ( int signum ) { exit ( 1 ); } int main () { struct sigaction sa ; sa . sa_flags = 0 ; //sigemptyset : Initializes a signal set sa.sa_mask to the empty set. All recognized signals are excluded. sigemptyset ( & sa . sa_mask ); sa . sa_handler = signal_callback_handler ; //sigaction : Examines and changes the action associated with a specific signal. sigaction ( SIGINT , & sa , NULL ); // use sa sigaction for SIGNINT while ( 1 ) {}; } File handling using high level API High level APIs have f at the beginning i.e. fopen, fclose, fread, etc and returns FILE (user level buffering) User space buffering can get block of data from kernel and return bytes quickly. Simple caching. Low level APIs are like open, read, close, write, etc. and return fds instead of FILE . (no buffering at user level) //character oriented (block oriented in comments) void main () { FILE * input = fopen ( \"input.txt\" , r ); FILE * output = fopen ( \"output.txt\" , w ); int c ; //char buffer[1024]; c = fgetc ( input ); //size_t length = fread(buffer, 1024, sizeof(char), input); while ( c != EOF ) { // length > 0 fputc ( output , c ); // fwrite(buffer,length, sizeof(char), output); c = fgetc ( input ); // length = fread(buffer, 1024, sizeof(char), input); } fclose ( input ); fclose ( output ); } Why buffering in kernel Kernel buffers read and writes -Disks are block oriented and we need to provide byte oriented implementation -> hence buffering -Caching: -Process is blocked while waiting for data, so let other process run Important notes Don't fork from process which has multiple threads Child process always has just a single thread Other threads vanish pthread is actually implemented using the clone() system call -> creates task_struct. So we can infer that there is a kernel thread (or a light-weight process) backing up a pthread in the user space. The kernel is aware of the pthread and can schedule it like a process. current->mm //contains user space memory map, this is null in kernel thread as it does not have virtual memory address space 32 bit vs 64 bit 64bit compiled binary has 64bit pointers. Long size is 8bytes 32bit compiled binary has 32bit pointers. Long size is 4bytes. 32bit and 6bit os can run on 64bit processor But only 32bit os can run on 32bit processor as max width of registers supported by processor is 32bits. When we say 32bit os, we mean that virtual address space is just 4gb. i.e. per process only 4GB is supported. But total ram can be more than 4gb. When we say 64bit os, we mean huge virtual address space. Reentrant Reentrant means that you can run reentrant function multiple times parallely and still get same output for same input. signal action handler to catch signal due to crashes Create sigaction object act, call sigaction to inform kernel that on catching SIGSEGV, use act sigaction int sigaction( int sig, const struct sigaction action_to_be_set, // used to set action object for sig struct sigaction old_action ); //can be used to check current action object struct sigaction { void ( sa_handler)(int); sigset_t sa_mask; int sa_flags; void ( sa_sigaction)(int, siginfo_t ,void ); }; sa_flags: SA_SIGINFO: If this flag is not set and the signal is caught, the signal-catching function identified by sa_handler is entered. If this flag is set and the signal is caught, the signal-catching function identified by sa_sigaction is entered. void handler ( int signo , siginfo_t * info , void * context ) { struct sigaction oldact ; if ( sigaction ( SIGSEGV , NULL , & oldact ) == -1 || ( oldact . sa_flags & SA_UNSUPPORTED ) || ! ( oldact . sa_flags & SA_EXPOSE_TAGBITS )) { _exit ( EXIT_FAILURE ); } _exit ( EXIT_SUCCESS ); } int main ( void ) { struct sigaction act = { 0 }; act . sa_flags = SA_SIGINFO | SA_UNSUPPORTED | SA_EXPOSE_TAGBITS ; act . sa_sigaction = & handler ; if ( sigaction ( SIGSEGV , & act , NULL ) == -1 ) { perror ( \"sigaction\" ); exit ( EXIT_FAILURE ); } raise ( SIGSEGV ); } Client Server Client 1. socket // Create socket 2. connect // Connect to server 3. read / write // Communication 4. close ```c Client // Create a socket struct addrinfo *server = lookup_host(host_name, port_name); int sock_fd = socket(server\u2010>ai_family, server\u2010>ai_socktype, server\u2010>ai_protocol); connect(sock_fd, server\u2010>ai_addr, server\u2010>ai_addrlen); Server 1. socket // Create socket 2. bind // Bind socket to an address 3. listen // Listen for connection i.e. open port for accepting communication //while loop 4. accept // 5. read / write // Communication 6. close // Close connection socket //while loop end 7. close // Close server socket ```c Server struct addrinfo *server = setup_address(port_name); int server_socket = socket(server\u2010>ai_family, server\u2010>ai_socktype, server\u2010>ai_protocol); // Bind socket to specific port bind(server_socket, server\u2010>ai_addr, server\u2010>ai_addrlen); // Start listening for new client connections listen(server_socket, MAX_QUEUE); while (1) { // Accept a new client connection, obtaining a new socket int conn_socket = accept(server_socket, NULL, NULL); serve_client(conn_socket); close(conn_socket); } close(server_socket); Above implementation does not support parallel connection as we are in same thread, process. To support concurrency, we can 1. Fork on each connection, so new process for each connection, so we get protection between connections -> heavy weight. So this should not be done 2. pthread_create on each connection, so new thread for each connection -> possibility of lots of threads in 1 process i.e. unbounded threads, no protection Solution: Use thread pools Zombie process Processes on completion can be in terminated state but not freed. Such processes are called zombie processes. Terminated state is required because Consider 2 process P1 and P2, P1 is parent of P2. P2 is scheduled and gets completed. If we just directly free P2 then P1 i.e. parent process won't know about return value of P2 as P1 is yet to be scheduled. Once we schedule P1 and P1 knows about the return value then we can free that memory. To know about return value of child processes, scheduled and completed child process is kept in terminated/zombie state until parent process reads return value. How are timers implemented ? How are locks implemented ? Expensive way since user to kernel context switch : In kernel lock: disable interrupts and check values, if already taken then keep current thread on wait queue for that lock. Go to sleep. We are using futex to either sleep a thread or wake up a thread. But acquire, release is what is callled multiple times which we do not want to keep expensive. So we use atomic instruction with global guard variable to keep acquire and release functions locked but now based on values of individual lock we need to decide whether process should be brought to ready or made to sleep. So no kernel call if unlocked. Scheduling: There are multiple schedulers, we can decide schedulers for each thread/process. Generally sched_normal refers to CFS. If we have selected different Operating systems Watch last 5 minutes of all lectures and first 10 minutes of next levture","title":"Basiccodes"},{"location":"EmbeddedSystems/basiccodes/#thread-creation","text":"//posix thread creation void * threadFunc ( void * arg ) { int tid = ( int ) arg ; //cast it back to int char * ret ; printf ( \"threadFunc entered with argument %d, stackspace for this starts from %p \\n \" , tid , & tid ); strcpy ( ret , \"This is a test\" ); //returned in ret pthread_exit ( ret ); //Implicitly called with default arguments if not written } init main ( int argc , char * argv []) { int nthreads = 2 ; if ( argc > 1 ) { nthreads = atoi ( argv [ 1 ]); } pthread_t * threads = malloc ( nthreads * sizeof ( nthreads )); int i = 0 ; for ( i = 0 ; i < nthreads ; i ++ ) { int rc = pthread_create ( & thid , NULL , thread , ( void * ) i ); //casting to void*, threadfunc will cast it back to int if ( rc ) { exit ( -1 ); //error } } void * ret ; //Wait for all previously created threads to finish and then join for ( i = 0 ; i < nthreads ; i ++ ) { int rc = pthread_join ( thid , & ret ); //&ret is passed to get status, null can also be passed if ( rc ) { exit ( -1 ); } } }","title":"Thread creation"},{"location":"EmbeddedSystems/basiccodes/#pthread-mutex","text":"pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER ; /* Alternate pthread_mutex initialization pthread_mutex_t lock; pthread_mutex_init ( &lock, NULL); */ int crit_var = 162 ; void * threadFunc ( void * arg ) { int tid = ( int ) arg ; //cast it back to int pthread_mutex_lock ( & lock ); crit_var ++ ; //perform operation on critical section pthread_mutex_unlock ( & lock ); }","title":"pthread mutex"},{"location":"EmbeddedSystems/basiccodes/#how-are-processes-started-in-linux","text":"Processes are started by processes. Userspace programs call fork, exec. 1st process is started by kernel. - Often configured as an argument to the kernel before kernel boots - Often called as init process Code snippet from linux -3.14 / init / main . c file :- if ( ! try_to_run_init_process ( \"/etc/preinit\" ) || ! try_to_run_init_process ( \"/sbin/init\" ) || ! try_to_run_init_process ( \"/etc/init\" ) || ! try_to_run_init_process ( \"/bin/init\" ) || ! try_to_run_init_process ( \"/bin/sh\" )) { return 0 ; } fork - New process has different pid - New process has only 1 thread. So be careful with locks in multithreaded process. Consider P1 has 2 threads. thread 2 has lock. thread 1 forks. P2 created will have only 1 thread and you will never get that lock as you had taken lock before but did not release. If you run exec in child process immediately after fork, then you would never need that lock and you will be fine. Return value from fork: - >0 : Running in parent process as parent process has received pid of child process - =0 : Running in child process, as child process has nothing to receive - <0 : error condition int main ( int argc , char * argv []) { printf ( \"Parent process pid=%d \\n \" , getpid ()); pid_t pid = fork (); if ( pid > 0 ) { //parent printf ( \"Parent process pid after fork =%d \\n \" , getpid ()); } else if ( pid == 0 ) { //child printf ( \"Child process pid after fork =%d \\n \" , getpid ()); //Everything is copied from parent process, address space, fd, etc. //Discard everything copied from parent and running new ls -l from child process using exec char * args [] = { \"ls\" , \"-l\" , null }; execv ( \"/bin/ls\" , args ); } else { //error } } The difference between execl and execv is the argument passing. execl require a list of arguments while execv require a vector of arguments. A list of arguments is useful if you know all the arguments at compile time. In your case the arguments will be entered by the user and you have to construct a vector of arguments at run time, so you should use one of the execv* functions. The functions with suffix p use the PATH environment variable to find the program (e.g. \"ls\"), without this you have to specify the full path (either absolute or relative to the current directory, e.g. \"/bin/ls\"). Using PATH is what shells normally do, so this seems to be the correct choice for you. The functions with suffix e allow to specify the environment for the process.","title":"How are processes started in linux?"},{"location":"EmbeddedSystems/basiccodes/#semaphores","text":"P() decrements (down()) V() increments (up())","title":"Semaphores"},{"location":"EmbeddedSystems/basiccodes/#binary-semaphore","text":"sem = 1; sem.down(); //critical section sem.up()","title":"Binary semaphore:"},{"location":"EmbeddedSystems/basiccodes/#signalling-using-sempahore","text":"In following example, T1 is kept in blocked state since it tries to down sem but initial value of sem is 0. Now we want T1 to run only after T2 finishes. So we do sem.up() when T2 ends. This causes T1 to be ready. So T2 has signalled T1. sem = 0 ; T1 T2 ThreadJoin () { ThreadFinish () { sem . down (); sem . up (); } }","title":"Signalling using sempahore"},{"location":"EmbeddedSystems/basiccodes/#handling-interrupts-in-c","text":"void signal_callback_handler ( int signum ) { exit ( 1 ); } int main () { struct sigaction sa ; sa . sa_flags = 0 ; //sigemptyset : Initializes a signal set sa.sa_mask to the empty set. All recognized signals are excluded. sigemptyset ( & sa . sa_mask ); sa . sa_handler = signal_callback_handler ; //sigaction : Examines and changes the action associated with a specific signal. sigaction ( SIGINT , & sa , NULL ); // use sa sigaction for SIGNINT while ( 1 ) {}; }","title":"Handling interrupts in c"},{"location":"EmbeddedSystems/basiccodes/#file-handling-using-high-level-api","text":"High level APIs have f at the beginning i.e. fopen, fclose, fread, etc and returns FILE (user level buffering) User space buffering can get block of data from kernel and return bytes quickly. Simple caching. Low level APIs are like open, read, close, write, etc. and return fds instead of FILE . (no buffering at user level) //character oriented (block oriented in comments) void main () { FILE * input = fopen ( \"input.txt\" , r ); FILE * output = fopen ( \"output.txt\" , w ); int c ; //char buffer[1024]; c = fgetc ( input ); //size_t length = fread(buffer, 1024, sizeof(char), input); while ( c != EOF ) { // length > 0 fputc ( output , c ); // fwrite(buffer,length, sizeof(char), output); c = fgetc ( input ); // length = fread(buffer, 1024, sizeof(char), input); } fclose ( input ); fclose ( output ); }","title":"File handling using high level API"},{"location":"EmbeddedSystems/basiccodes/#why-buffering-in-kernel","text":"Kernel buffers read and writes -Disks are block oriented and we need to provide byte oriented implementation -> hence buffering -Caching: -Process is blocked while waiting for data, so let other process run","title":"Why buffering in kernel"},{"location":"EmbeddedSystems/basiccodes/#important-notes","text":"Don't fork from process which has multiple threads Child process always has just a single thread Other threads vanish pthread is actually implemented using the clone() system call -> creates task_struct. So we can infer that there is a kernel thread (or a light-weight process) backing up a pthread in the user space. The kernel is aware of the pthread and can schedule it like a process. current->mm //contains user space memory map, this is null in kernel thread as it does not have virtual memory address space","title":"Important notes"},{"location":"EmbeddedSystems/basiccodes/#32-bit-vs-64-bit","text":"64bit compiled binary has 64bit pointers. Long size is 8bytes 32bit compiled binary has 32bit pointers. Long size is 4bytes. 32bit and 6bit os can run on 64bit processor But only 32bit os can run on 32bit processor as max width of registers supported by processor is 32bits. When we say 32bit os, we mean that virtual address space is just 4gb. i.e. per process only 4GB is supported. But total ram can be more than 4gb. When we say 64bit os, we mean huge virtual address space.","title":"32 bit vs 64 bit"},{"location":"EmbeddedSystems/basiccodes/#reentrant","text":"Reentrant means that you can run reentrant function multiple times parallely and still get same output for same input.","title":"Reentrant"},{"location":"EmbeddedSystems/basiccodes/#signal-action-handler-to-catch-signal-due-to-crashes","text":"Create sigaction object act, call sigaction to inform kernel that on catching SIGSEGV, use act sigaction int sigaction( int sig, const struct sigaction action_to_be_set, // used to set action object for sig struct sigaction old_action ); //can be used to check current action object struct sigaction { void ( sa_handler)(int); sigset_t sa_mask; int sa_flags; void ( sa_sigaction)(int, siginfo_t ,void ); }; sa_flags: SA_SIGINFO: If this flag is not set and the signal is caught, the signal-catching function identified by sa_handler is entered. If this flag is set and the signal is caught, the signal-catching function identified by sa_sigaction is entered. void handler ( int signo , siginfo_t * info , void * context ) { struct sigaction oldact ; if ( sigaction ( SIGSEGV , NULL , & oldact ) == -1 || ( oldact . sa_flags & SA_UNSUPPORTED ) || ! ( oldact . sa_flags & SA_EXPOSE_TAGBITS )) { _exit ( EXIT_FAILURE ); } _exit ( EXIT_SUCCESS ); } int main ( void ) { struct sigaction act = { 0 }; act . sa_flags = SA_SIGINFO | SA_UNSUPPORTED | SA_EXPOSE_TAGBITS ; act . sa_sigaction = & handler ; if ( sigaction ( SIGSEGV , & act , NULL ) == -1 ) { perror ( \"sigaction\" ); exit ( EXIT_FAILURE ); } raise ( SIGSEGV ); }","title":"signal action handler to catch signal due to crashes"},{"location":"EmbeddedSystems/basiccodes/#client-server","text":"Client 1. socket // Create socket 2. connect // Connect to server 3. read / write // Communication 4. close ```c Client // Create a socket struct addrinfo *server = lookup_host(host_name, port_name); int sock_fd = socket(server\u2010>ai_family, server\u2010>ai_socktype, server\u2010>ai_protocol); connect(sock_fd, server\u2010>ai_addr, server\u2010>ai_addrlen); Server 1. socket // Create socket 2. bind // Bind socket to an address 3. listen // Listen for connection i.e. open port for accepting communication //while loop 4. accept // 5. read / write // Communication 6. close // Close connection socket //while loop end 7. close // Close server socket ```c Server struct addrinfo *server = setup_address(port_name); int server_socket = socket(server\u2010>ai_family, server\u2010>ai_socktype, server\u2010>ai_protocol); // Bind socket to specific port bind(server_socket, server\u2010>ai_addr, server\u2010>ai_addrlen); // Start listening for new client connections listen(server_socket, MAX_QUEUE); while (1) { // Accept a new client connection, obtaining a new socket int conn_socket = accept(server_socket, NULL, NULL); serve_client(conn_socket); close(conn_socket); } close(server_socket); Above implementation does not support parallel connection as we are in same thread, process. To support concurrency, we can 1. Fork on each connection, so new process for each connection, so we get protection between connections -> heavy weight. So this should not be done 2. pthread_create on each connection, so new thread for each connection -> possibility of lots of threads in 1 process i.e. unbounded threads, no protection Solution: Use thread pools","title":"Client Server"},{"location":"EmbeddedSystems/basiccodes/#zombie-process","text":"Processes on completion can be in terminated state but not freed. Such processes are called zombie processes. Terminated state is required because Consider 2 process P1 and P2, P1 is parent of P2. P2 is scheduled and gets completed. If we just directly free P2 then P1 i.e. parent process won't know about return value of P2 as P1 is yet to be scheduled. Once we schedule P1 and P1 knows about the return value then we can free that memory. To know about return value of child processes, scheduled and completed child process is kept in terminated/zombie state until parent process reads return value.","title":"Zombie process"},{"location":"EmbeddedSystems/basiccodes/#how-are-timers-implemented","text":"","title":"How are timers implemented ?"},{"location":"EmbeddedSystems/basiccodes/#how-are-locks-implemented","text":"Expensive way since user to kernel context switch : In kernel lock: disable interrupts and check values, if already taken then keep current thread on wait queue for that lock. Go to sleep. We are using futex to either sleep a thread or wake up a thread. But acquire, release is what is callled multiple times which we do not want to keep expensive. So we use atomic instruction with global guard variable to keep acquire and release functions locked but now based on values of individual lock we need to decide whether process should be brought to ready or made to sleep. So no kernel call if unlocked. Scheduling: There are multiple schedulers, we can decide schedulers for each thread/process. Generally sched_normal refers to CFS. If we have selected different","title":"How are locks implemented ?"},{"location":"EmbeddedSystems/basiccodes/#operating-systems","text":"Watch last 5 minutes of all lectures and first 10 minutes of next levture","title":"Operating systems"},{"location":"EmbeddedSystems/coa/","text":"Addressing Modes: Cache mapping policies: Direct mapping Fully Associative Set Associative (k-ways) Cache replacement policies: LRU FIFO Random","title":"Coa"},{"location":"EmbeddedSystems/iomux/","text":"IO Multiplexing Server Client /* * flight-time-server.c: record and provide time of a * flight from the airport * */ #include <stdio.h> #include <string.h> #include <stdlib.h> #include <sys/types.h> #include <sys/socket.h> #include <netinet/in.h> #include <arpa/inet.h> #include <netdb.h> #include <poll.h> #include <errno.h> #include <syslog.h> #include <unistd.h> #include <stdbool.h> #include <ctype.h> #include <stdint.h> #include <time.h> #define FLIGHT_NUM_SIZE 15 #define SERVER_PORT \"4358\" #define STORE_FLIGHT 1 #define FLIGHT_TIME_STORED 2 #define FLIGHT_TIME 3 #define FLIGHT_TIME_RESULT 4 #define FLIGHT_NOT_FOUND 5 #define ERROR_IN_INPUT 9 #define BACKLOG 10 #define NUM_FDS 5 void error ( char * msg ); struct message { int32_t message_id ; char flight_no [ FLIGHT_NUM_SIZE + 1 ]; char departure [ 1 + 1 ]; // 'D': departure, 'A': arrival char date [ 10 + 1 ]; // dd/mm/yyyy char time [ 5 + 1 ]; // hh:mm }; struct tnode { char * flight_no ; bool departure ; // true: departure, false: arrival time_t flight_time ; struct tnode * left ; struct tnode * right ; }; struct message recv_message , send_message ; struct tnode * add_to_tree ( struct tnode * p , char * flight_no , bool departure , time_t flight_time ); struct tnode * find_flight_rec ( struct tnode * p , char * flight_no ); void print_tree ( struct tnode * p ); void trim ( char * dest , char * src ); void error ( char * msg ); int main ( int argc , char ** argv ) { const char * const ident = \"flight-time-server\" ; openlog ( ident , LOG_CONS | LOG_PID | LOG_PERROR , LOG_USER ); syslog ( LOG_USER | LOG_INFO , \"%s\" , \"Hello world!\" ); struct addrinfo hints ; memset ( & hints , 0 , sizeof ( struct addrinfo )); hints . ai_family = AF_UNSPEC ; /* allow IPv4 or IPv6 */ hints . ai_socktype = SOCK_STREAM ; /* Stream socket */ hints . ai_flags = AI_PASSIVE ; /* for wildcard IP address */ struct addrinfo * result ; int s ; if (( s = getaddrinfo ( NULL , SERVER_PORT , & hints , & result )) != 0 ) { fprintf ( stderr , \"getaddrinfo: %s \\n \" , gai_strerror ( s )); exit ( EXIT_FAILURE ); } /* Scan through the list of address structures returned by getaddrinfo. Stop when the the socket and bind calls are successful. */ int listener , optval = 1 ; socklen_t length ; struct addrinfo * rptr ; for ( rptr = result ; rptr != NULL ; rptr = rptr -> ai_next ) { listener = socket ( rptr -> ai_family , rptr -> ai_socktype , rptr -> ai_protocol ); if ( listener == -1 ) continue ; if ( setsockopt ( listener , SOL_SOCKET , SO_REUSEADDR , & optval , sizeof ( int )) == -1 ) error ( \"setsockopt\" ); if ( bind ( listener , rptr -> ai_addr , rptr -> ai_addrlen ) == 0 ) // Success break ; if ( close ( listener ) == -1 ) error ( \"close\" ); } if ( rptr == NULL ) { // Not successful with any address fprintf ( stderr , \"Not able to bind \\n \" ); exit ( EXIT_FAILURE ); } freeaddrinfo ( result ); // Mark socket for accepting incoming connections using accept if ( listen ( listener , BACKLOG ) == -1 ) error ( \"listen\" ); nfds_t nfds = 0 ; struct pollfd * pollfds ; int maxfds = 0 , numfds = 0 ; if (( pollfds = malloc ( NUM_FDS * sizeof ( struct pollfd ))) == NULL ) error ( \"malloc\" ); maxfds = NUM_FDS ; pollfds -> fd = listener ; pollfds -> events = POLLIN ; pollfds -> revents = 0 ; numfds = 1 ; socklen_t addrlen ; struct sockaddr_storage client_saddr ; char str [ INET6_ADDRSTRLEN ]; struct sockaddr_in * ptr ; struct sockaddr_in6 * ptr1 ; struct tnode * root = NULL ; while ( 1 ) { // monitor readfds for readiness for reading nfds = numfds ; if ( poll ( pollfds , nfds , -1 ) == -1 ) error ( \"poll\" ); // Some sockets are ready. Examine readfds for ( int fd = 0 ; fd < ( nfds + 1 ); fd ++ ) { if (( pollfds + fd ) -> fd <= 0 ) // file desc == 0 is not expected, as these are socket fds and not stdin continue ; if ((( pollfds + fd ) -> revents & POLLIN ) == POLLIN ) { // fd is ready for reading if (( pollfds + fd ) -> fd == listener ) { // request for new connection addrlen = sizeof ( struct sockaddr_storage ); int fd_new ; if (( fd_new = accept ( listener , ( struct sockaddr * ) & client_saddr , & addrlen )) == -1 ) error ( \"accept\" ); // add fd_new to pollfds if ( numfds == maxfds ) { // create space if (( pollfds = realloc ( pollfds , ( maxfds + NUM_FDS ) * sizeof ( struct pollfd ))) == NULL ) error ( \"malloc\" ); maxfds += NUM_FDS ; } numfds ++ ; ( pollfds + numfds - 1 ) -> fd = fd_new ; ( pollfds + numfds - 1 ) -> events = POLLIN ; ( pollfds + numfds - 1 ) -> revents = 0 ; // print IP address of the new client if ( client_saddr . ss_family == AF_INET ) { ptr = ( struct sockaddr_in * ) & client_saddr ; inet_ntop ( AF_INET , & ( ptr -> sin_addr ), str , sizeof ( str )); } else if ( client_saddr . ss_family == AF_INET6 ) { ptr1 = ( struct sockaddr_in6 * ) & client_saddr ; inet_ntop ( AF_INET6 , & ( ptr1 -> sin6_addr ), str , sizeof ( str )); } else { ptr = NULL ; fprintf ( stderr , \"Address family is neither AF_INET nor AF_INET6 \\n \" ); } if ( ptr ) syslog ( LOG_USER | LOG_INFO , \"%s %s\" , \"Connection from client\" , str ); } else // data from an existing connection, receive it { memset ( & recv_message , '\\0' , sizeof ( struct message )); ssize_t numbytes = recv (( pollfds + fd ) -> fd , & recv_message , sizeof ( struct message ), 0 ); if ( numbytes == -1 ) error ( \"recv\" ); else if ( numbytes == 0 ) { // connection closed by client fprintf ( stderr , \"Socket %d closed by client \\n \" , ( pollfds + fd ) -> fd ); if ( close (( pollfds + fd ) -> fd ) == -1 ) error ( \"close\" ); ( pollfds + fd ) -> fd *= -1 ; // make it negative so that it is ignored in future } else { // data from client bool valid ; char temp_buf [ FLIGHT_NUM_SIZE + 1 ]; switch ( ntohl ( recv_message . message_id )) { case STORE_FLIGHT : valid = true ; // validate flight number if ( recv_message . flight_no [ FLIGHT_NUM_SIZE ]) recv_message . flight_no [ FLIGHT_NUM_SIZE ] = '\\0' ; if ( strlen ( recv_message . flight_no ) < 3 ) valid = false ; trim ( temp_buf , recv_message . flight_no ); strcpy ( recv_message . flight_no , temp_buf ); bool departure ; if ( toupper ( recv_message . departure [ 0 ]) == 'D' ) departure = true ; else if ( toupper ( recv_message . departure [ 0 ]) == 'A' ) departure = false ; else valid = false ; char delim [] = \"/\" ; char * mday , * month , * year , * saveptr ; mday = month = year = NULL ; mday = strtok_r ( recv_message . date , delim , & saveptr ); if ( mday ) month = strtok_r ( NULL , delim , & saveptr ); else valid = false ; if ( month ) year = strtok_r ( NULL , delim , & saveptr ); else valid = false ; if ( ! year ) valid = false ; char * hrs , * min ; // get time if ( recv_message . time [ 5 ]) recv_message . time [ 5 ] = '\\0' ; delim [ 0 ] = ':' ; hrs = min = NULL ; hrs = strtok_r ( recv_message . time , delim , & saveptr ); if ( hrs ) min = strtok_r ( NULL , delim , & saveptr ); if ( ! hrs || ! min ) valid = false ; time_t ts ; if ( valid ) { struct tm tm ; tm . tm_sec = 0 ; sscanf ( min , \"%d\" , & tm . tm_min ); sscanf ( hrs , \"%d\" , & tm . tm_hour ); sscanf ( mday , \"%d\" , & tm . tm_mday ); sscanf ( month , \"%d\" , & tm . tm_mon ); ( tm . tm_mon ) -- ; sscanf ( year , \"%d\" , & tm . tm_year ); tm . tm_year -= 1900 ; tm . tm_isdst = -1 ; if (( ts = mktime ( & tm )) == ( time_t ) -1 ) valid = false ; time_t now ; if (( now = time ( NULL )) == ( time_t ) -1 ) error ( \"time\" ); if ( ts < now ) valid = false ; } if ( ! valid ) { // send error message to client send_message . message_id = htonl ( ERROR_IN_INPUT ); size_t msg_len = sizeof ( long ); if ( send (( pollfds + fd ) -> fd , & send_message , msg_len , 0 ) == -1 ) error ( \"send\" ); } else { // add flight data to tree root = add_to_tree ( root , recv_message . flight_no , departure , ts ); // send confirmation to client send_message . message_id = htonl ( FLIGHT_TIME_STORED ); strcpy ( send_message . flight_no , recv_message . flight_no ); strcpy ( send_message . departure , ( departure ) ? \"D\" : \"A\" ); struct tm * tms ; if (( tms = localtime ( & ts )) == NULL ) perror ( \"localtime\" ); sprintf ( send_message . date , \"%02d/%02d/%d\" , tms -> tm_mday , tms -> tm_mon + 1 , tms -> tm_year + 1900 ); sprintf ( send_message . time , \"%02d:%02d\" , tms -> tm_hour , tms -> tm_min ); size_t msg_len = sizeof ( struct message ); if ( send (( pollfds + fd ) -> fd , & send_message , msg_len , 0 ) == -1 ) error ( \"send\" ); } break ; case FLIGHT_TIME : valid = true ; // validate flight number if ( recv_message . flight_no [ FLIGHT_NUM_SIZE ]) recv_message . flight_no [ FLIGHT_NUM_SIZE ] = '\\0' ; if ( strlen ( recv_message . flight_no ) < 3 ) valid = false ; if ( ! valid ) { // send error message to client send_message . message_id = htonl ( ERROR_IN_INPUT ); size_t msg_len = sizeof ( long ); if ( send (( pollfds + fd ) -> fd , & send_message , msg_len , 0 ) == -1 ) error ( \"send\" ); break ; } char temp_buf [ FLIGHT_NUM_SIZE + 1 ]; trim ( temp_buf , recv_message . flight_no ); strcpy ( recv_message . flight_no , temp_buf ); struct tnode * ptr ; ptr = find_flight_rec ( root , recv_message . flight_no ); if ( ! ptr ) { memset ( & send_message , '\\0' , sizeof ( struct message )); send_message . message_id = htonl ( FLIGHT_NOT_FOUND ); strcpy ( send_message . flight_no , recv_message . flight_no ); size_t msg_len = sizeof ( struct message ); if ( send (( pollfds + fd ) -> fd , & send_message , msg_len , 0 ) == -1 ) error ( \"send\" ); break ; } send_message . message_id = htonl ( FLIGHT_TIME_RESULT ); strcpy ( send_message . flight_no , recv_message . flight_no ); strcpy ( send_message . departure , ( ptr -> departure ) ? \"D\" : \"A\" ); struct tm * tms ; if (( tms = localtime ( & ( ptr -> flight_time ))) == NULL ) perror ( \"localtime\" ); sprintf ( send_message . date , \"%02d/%02d/%d\" , tms -> tm_mday , tms -> tm_mon + 1 , tms -> tm_year + 1900 ); sprintf ( send_message . time , \"%02d:%02d\" , tms -> tm_hour , tms -> tm_min ); size_t msg_len = sizeof ( struct message ); if ( send (( pollfds + fd ) -> fd , & send_message , msg_len , 0 ) == -1 ) error ( \"send\" ); break ; } } } } // if (fd == ... } // for } // while (1) exit ( EXIT_SUCCESS ); } // main // record the flight departure / arrival time struct tnode * add_to_tree ( struct tnode * p , char * flight_no , bool departure , time_t flight_time ) { int res ; if ( p == NULL ) { // new entry if (( p = ( struct tnode * ) malloc ( sizeof ( struct tnode ))) == NULL ) error ( \"malloc\" ); p -> flight_no = strdup ( flight_no ); p -> departure = departure ; p -> flight_time = flight_time ; p -> left = p -> right = NULL ; } else if (( res = strcmp ( flight_no , p -> flight_no )) == 0 ) { // entry exists p -> departure = departure ; p -> flight_time = flight_time ; } else if ( res < 0 ) // less than flight_no for this node, put in left subtree p -> left = add_to_tree ( p -> left , flight_no , departure , flight_time ); else // greater than flight_no for this node, put in right subtree p -> right = add_to_tree ( p -> right , flight_no , departure , flight_time ); return p ; } // find node for the flight for which departure or arrival time is queried struct tnode * find_flight_rec ( struct tnode * p , char * flight_no ) { int res ; if ( ! p ) return p ; res = strcmp ( flight_no , p -> flight_no ); if ( ! res ) return p ; if ( res < 0 ) return find_flight_rec ( p -> left , flight_no ); else return find_flight_rec ( p -> right , flight_no ); } // print_tree: print the tree (in-order traversal) void print_tree ( struct tnode * p ) { if ( p != NULL ) { print_tree ( p -> left ); printf ( \"%s: %d %s \\n\\n \" , p -> flight_no , ( int ) p -> departure , ctime ( & ( p -> flight_time ))); print_tree ( p -> right ); } } void error ( char * msg ) { perror ( msg ); exit ( 1 ); } // trim: leading and trailing whitespace of string void trim ( char * dest , char * src ) { if ( ! src || ! dest ) return ; int len = strlen ( src ); if ( ! len ) { * dest = '\\0' ; return ; } char * ptr = src + len - 1 ; // remove trailing whitespace while ( ptr > src ) { if ( ! isspace ( * ptr )) break ; ptr -- ; } ptr ++ ; char * q ; // remove leading whitespace for ( q = src ; ( q < ptr && isspace ( * q )); q ++ ) ; while ( q < ptr ) * dest ++ = * q ++ ; * dest = '\\0' ; } /* * flight-time-client.c : get flight time from the server * */ #include <sys/types.h> #include <sys/socket.h> #include <netinet/in.h> #include <arpa/inet.h> #include <netdb.h> #include <stdio.h> #include <string.h> #include <stdlib.h> #include <errno.h> #include <unistd.h> #include <ctype.h> #include <stdint.h> #include <time.h> #define FLIGHT_NUM_SIZE 15 #define SERVER_PORT \"4358\" #define STORE_FLIGHT 1 #define FLIGHT_TIME_STORED 2 #define FLIGHT_TIME 3 #define FLIGHT_TIME_RESULT 4 #define FLIGHT_NOT_FOUND 5 #define ERROR_IN_INPUT 9 #define QUIT 0 void error ( char * msg ); struct message { int32_t message_id ; char flight_no [ FLIGHT_NUM_SIZE + 1 ]; char departure [ 1 + 1 ]; // 'D': departure, 'A': arrival char date [ 10 + 1 ]; // dd/mm/yyyy char time [ 5 + 1 ]; // hh:mm }; struct message message ; int get_input ( void ); void error ( char * msg ); int main ( int argc , char ** argv ) { if ( argc != 2 ) { fprintf ( stderr , \"Usage: client hostname \\n \" ); exit ( EXIT_FAILURE ); } struct addrinfo hints ; memset ( & hints , 0 , sizeof ( struct addrinfo )); hints . ai_family = AF_UNSPEC ; hints . ai_socktype = SOCK_STREAM ; struct addrinfo * result ; int s ; if (( s = getaddrinfo ( argv [ 1 ], SERVER_PORT , & hints , & result )) != 0 ) { fprintf ( stderr , \"getaddrinfo: %s \\n \" , gai_strerror ( s )); exit ( EXIT_FAILURE ); } /* Scan through the list of address structures returned by getaddrinfo. Stop when the the socket and connect calls are successful. */ int sock_fd ; socklen_t length ; struct addrinfo * rptr ; for ( rptr = result ; rptr != NULL ; rptr = rptr -> ai_next ) { sock_fd = socket ( rptr -> ai_family , rptr -> ai_socktype , rptr -> ai_protocol ); if ( sock_fd == -1 ) continue ; if ( connect ( sock_fd , rptr -> ai_addr , rptr -> ai_addrlen ) == -1 ) { if ( close ( sock_fd ) == -1 ) error ( \"close\" ); continue ; } break ; } if ( rptr == NULL ) { // Not successful with any address fprintf ( stderr , \"Not able to connect \\n \" ); exit ( EXIT_FAILURE ); } freeaddrinfo ( result ); int option ; while ( 1 ) { option = get_input (); if ( option == QUIT ) break ; // send request to server if ( send ( sock_fd , & message , sizeof ( struct message ), MSG_NOSIGNAL ) == -1 ) error ( \"send\" ); // receive response from server if ( recv ( sock_fd , & message , sizeof ( struct message ), 0 ) == -1 ) error ( \"recv\" ); // process server response switch ( ntohl ( message . message_id )) { case FLIGHT_TIME_STORED : case FLIGHT_TIME_RESULT : printf ( \" \\n Response: \\n\\n \" ); printf ( \" \\t %s: %s %s %s \\n\\n \" , message . flight_no , message . departure , message . date , message . time ); break ; case FLIGHT_NOT_FOUND : printf ( \" \\n Flight not found \\n\\n \" ); break ; case ERROR_IN_INPUT : printf ( \" \\n Error in input \\n\\n \" ); break ; default : printf ( \" \\n Unrecongnized message from server \\n\\n \" ); } } exit ( EXIT_SUCCESS ); } char inbuf [ 512 ]; int get_input ( void ) { int option ; while ( 1 ) { printf ( \"Flight Info \\n\\n \" ); printf ( \" \\t Flight time query \\t 1 \\n \" ); printf ( \" \\t Store flight time \\t 2 \\n \" ); printf ( \" \\t Quit \\t\\t 0 \\n\\n \" ); printf ( \"Your option: \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); sscanf ( inbuf , \"%d\" , & option ); int len ; switch ( option ) { case 1 : message . message_id = htonl ( FLIGHT_TIME ); printf ( \"Flight no: \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); len = strlen ( inbuf ); if ( inbuf [ len - 1 ] == '\\n' ) inbuf [ len - 1 ] = '\\0' ; strcpy ( message . flight_no , inbuf ); break ; case 2 : message . message_id = htonl ( STORE_FLIGHT ); printf ( \"Flight no: \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); len = strlen ( inbuf ); if ( inbuf [ len - 1 ] == '\\n' ) inbuf [ len - 1 ] = '\\0' ; strcpy ( message . flight_no , inbuf ); while ( 1 ) { printf ( \"A/D: \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); message . departure [ 0 ] = toupper ( inbuf [ 0 ]); message . departure [ 1 ] = '\\0' ; if (( message . departure [ 0 ] == 'A' ) || ( message . departure [ 0 ] == 'D' )) break ; printf ( \"Error in input, valid values are A and D \\n \" ); } printf ( \"date (dd/mm/yyyy): \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); strncpy ( message . date , inbuf , 10 ); message . date [ 10 ] = '\\0' ; printf ( \"time (hh:mm): \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); strncpy ( message . time , inbuf , 5 ); message . time [ 5 ] = '\\0' ; break ; case 0 : break ; default : printf ( \"Illegal option, try again \\n\\n \" ); continue ; } return option ; } } void error ( char * msg ) { perror ( msg ); exit ( 1 ); }","title":"IO Multiplexing"},{"location":"EmbeddedSystems/iomux/#io-multiplexing","text":"Server Client /* * flight-time-server.c: record and provide time of a * flight from the airport * */ #include <stdio.h> #include <string.h> #include <stdlib.h> #include <sys/types.h> #include <sys/socket.h> #include <netinet/in.h> #include <arpa/inet.h> #include <netdb.h> #include <poll.h> #include <errno.h> #include <syslog.h> #include <unistd.h> #include <stdbool.h> #include <ctype.h> #include <stdint.h> #include <time.h> #define FLIGHT_NUM_SIZE 15 #define SERVER_PORT \"4358\" #define STORE_FLIGHT 1 #define FLIGHT_TIME_STORED 2 #define FLIGHT_TIME 3 #define FLIGHT_TIME_RESULT 4 #define FLIGHT_NOT_FOUND 5 #define ERROR_IN_INPUT 9 #define BACKLOG 10 #define NUM_FDS 5 void error ( char * msg ); struct message { int32_t message_id ; char flight_no [ FLIGHT_NUM_SIZE + 1 ]; char departure [ 1 + 1 ]; // 'D': departure, 'A': arrival char date [ 10 + 1 ]; // dd/mm/yyyy char time [ 5 + 1 ]; // hh:mm }; struct tnode { char * flight_no ; bool departure ; // true: departure, false: arrival time_t flight_time ; struct tnode * left ; struct tnode * right ; }; struct message recv_message , send_message ; struct tnode * add_to_tree ( struct tnode * p , char * flight_no , bool departure , time_t flight_time ); struct tnode * find_flight_rec ( struct tnode * p , char * flight_no ); void print_tree ( struct tnode * p ); void trim ( char * dest , char * src ); void error ( char * msg ); int main ( int argc , char ** argv ) { const char * const ident = \"flight-time-server\" ; openlog ( ident , LOG_CONS | LOG_PID | LOG_PERROR , LOG_USER ); syslog ( LOG_USER | LOG_INFO , \"%s\" , \"Hello world!\" ); struct addrinfo hints ; memset ( & hints , 0 , sizeof ( struct addrinfo )); hints . ai_family = AF_UNSPEC ; /* allow IPv4 or IPv6 */ hints . ai_socktype = SOCK_STREAM ; /* Stream socket */ hints . ai_flags = AI_PASSIVE ; /* for wildcard IP address */ struct addrinfo * result ; int s ; if (( s = getaddrinfo ( NULL , SERVER_PORT , & hints , & result )) != 0 ) { fprintf ( stderr , \"getaddrinfo: %s \\n \" , gai_strerror ( s )); exit ( EXIT_FAILURE ); } /* Scan through the list of address structures returned by getaddrinfo. Stop when the the socket and bind calls are successful. */ int listener , optval = 1 ; socklen_t length ; struct addrinfo * rptr ; for ( rptr = result ; rptr != NULL ; rptr = rptr -> ai_next ) { listener = socket ( rptr -> ai_family , rptr -> ai_socktype , rptr -> ai_protocol ); if ( listener == -1 ) continue ; if ( setsockopt ( listener , SOL_SOCKET , SO_REUSEADDR , & optval , sizeof ( int )) == -1 ) error ( \"setsockopt\" ); if ( bind ( listener , rptr -> ai_addr , rptr -> ai_addrlen ) == 0 ) // Success break ; if ( close ( listener ) == -1 ) error ( \"close\" ); } if ( rptr == NULL ) { // Not successful with any address fprintf ( stderr , \"Not able to bind \\n \" ); exit ( EXIT_FAILURE ); } freeaddrinfo ( result ); // Mark socket for accepting incoming connections using accept if ( listen ( listener , BACKLOG ) == -1 ) error ( \"listen\" ); nfds_t nfds = 0 ; struct pollfd * pollfds ; int maxfds = 0 , numfds = 0 ; if (( pollfds = malloc ( NUM_FDS * sizeof ( struct pollfd ))) == NULL ) error ( \"malloc\" ); maxfds = NUM_FDS ; pollfds -> fd = listener ; pollfds -> events = POLLIN ; pollfds -> revents = 0 ; numfds = 1 ; socklen_t addrlen ; struct sockaddr_storage client_saddr ; char str [ INET6_ADDRSTRLEN ]; struct sockaddr_in * ptr ; struct sockaddr_in6 * ptr1 ; struct tnode * root = NULL ; while ( 1 ) { // monitor readfds for readiness for reading nfds = numfds ; if ( poll ( pollfds , nfds , -1 ) == -1 ) error ( \"poll\" ); // Some sockets are ready. Examine readfds for ( int fd = 0 ; fd < ( nfds + 1 ); fd ++ ) { if (( pollfds + fd ) -> fd <= 0 ) // file desc == 0 is not expected, as these are socket fds and not stdin continue ; if ((( pollfds + fd ) -> revents & POLLIN ) == POLLIN ) { // fd is ready for reading if (( pollfds + fd ) -> fd == listener ) { // request for new connection addrlen = sizeof ( struct sockaddr_storage ); int fd_new ; if (( fd_new = accept ( listener , ( struct sockaddr * ) & client_saddr , & addrlen )) == -1 ) error ( \"accept\" ); // add fd_new to pollfds if ( numfds == maxfds ) { // create space if (( pollfds = realloc ( pollfds , ( maxfds + NUM_FDS ) * sizeof ( struct pollfd ))) == NULL ) error ( \"malloc\" ); maxfds += NUM_FDS ; } numfds ++ ; ( pollfds + numfds - 1 ) -> fd = fd_new ; ( pollfds + numfds - 1 ) -> events = POLLIN ; ( pollfds + numfds - 1 ) -> revents = 0 ; // print IP address of the new client if ( client_saddr . ss_family == AF_INET ) { ptr = ( struct sockaddr_in * ) & client_saddr ; inet_ntop ( AF_INET , & ( ptr -> sin_addr ), str , sizeof ( str )); } else if ( client_saddr . ss_family == AF_INET6 ) { ptr1 = ( struct sockaddr_in6 * ) & client_saddr ; inet_ntop ( AF_INET6 , & ( ptr1 -> sin6_addr ), str , sizeof ( str )); } else { ptr = NULL ; fprintf ( stderr , \"Address family is neither AF_INET nor AF_INET6 \\n \" ); } if ( ptr ) syslog ( LOG_USER | LOG_INFO , \"%s %s\" , \"Connection from client\" , str ); } else // data from an existing connection, receive it { memset ( & recv_message , '\\0' , sizeof ( struct message )); ssize_t numbytes = recv (( pollfds + fd ) -> fd , & recv_message , sizeof ( struct message ), 0 ); if ( numbytes == -1 ) error ( \"recv\" ); else if ( numbytes == 0 ) { // connection closed by client fprintf ( stderr , \"Socket %d closed by client \\n \" , ( pollfds + fd ) -> fd ); if ( close (( pollfds + fd ) -> fd ) == -1 ) error ( \"close\" ); ( pollfds + fd ) -> fd *= -1 ; // make it negative so that it is ignored in future } else { // data from client bool valid ; char temp_buf [ FLIGHT_NUM_SIZE + 1 ]; switch ( ntohl ( recv_message . message_id )) { case STORE_FLIGHT : valid = true ; // validate flight number if ( recv_message . flight_no [ FLIGHT_NUM_SIZE ]) recv_message . flight_no [ FLIGHT_NUM_SIZE ] = '\\0' ; if ( strlen ( recv_message . flight_no ) < 3 ) valid = false ; trim ( temp_buf , recv_message . flight_no ); strcpy ( recv_message . flight_no , temp_buf ); bool departure ; if ( toupper ( recv_message . departure [ 0 ]) == 'D' ) departure = true ; else if ( toupper ( recv_message . departure [ 0 ]) == 'A' ) departure = false ; else valid = false ; char delim [] = \"/\" ; char * mday , * month , * year , * saveptr ; mday = month = year = NULL ; mday = strtok_r ( recv_message . date , delim , & saveptr ); if ( mday ) month = strtok_r ( NULL , delim , & saveptr ); else valid = false ; if ( month ) year = strtok_r ( NULL , delim , & saveptr ); else valid = false ; if ( ! year ) valid = false ; char * hrs , * min ; // get time if ( recv_message . time [ 5 ]) recv_message . time [ 5 ] = '\\0' ; delim [ 0 ] = ':' ; hrs = min = NULL ; hrs = strtok_r ( recv_message . time , delim , & saveptr ); if ( hrs ) min = strtok_r ( NULL , delim , & saveptr ); if ( ! hrs || ! min ) valid = false ; time_t ts ; if ( valid ) { struct tm tm ; tm . tm_sec = 0 ; sscanf ( min , \"%d\" , & tm . tm_min ); sscanf ( hrs , \"%d\" , & tm . tm_hour ); sscanf ( mday , \"%d\" , & tm . tm_mday ); sscanf ( month , \"%d\" , & tm . tm_mon ); ( tm . tm_mon ) -- ; sscanf ( year , \"%d\" , & tm . tm_year ); tm . tm_year -= 1900 ; tm . tm_isdst = -1 ; if (( ts = mktime ( & tm )) == ( time_t ) -1 ) valid = false ; time_t now ; if (( now = time ( NULL )) == ( time_t ) -1 ) error ( \"time\" ); if ( ts < now ) valid = false ; } if ( ! valid ) { // send error message to client send_message . message_id = htonl ( ERROR_IN_INPUT ); size_t msg_len = sizeof ( long ); if ( send (( pollfds + fd ) -> fd , & send_message , msg_len , 0 ) == -1 ) error ( \"send\" ); } else { // add flight data to tree root = add_to_tree ( root , recv_message . flight_no , departure , ts ); // send confirmation to client send_message . message_id = htonl ( FLIGHT_TIME_STORED ); strcpy ( send_message . flight_no , recv_message . flight_no ); strcpy ( send_message . departure , ( departure ) ? \"D\" : \"A\" ); struct tm * tms ; if (( tms = localtime ( & ts )) == NULL ) perror ( \"localtime\" ); sprintf ( send_message . date , \"%02d/%02d/%d\" , tms -> tm_mday , tms -> tm_mon + 1 , tms -> tm_year + 1900 ); sprintf ( send_message . time , \"%02d:%02d\" , tms -> tm_hour , tms -> tm_min ); size_t msg_len = sizeof ( struct message ); if ( send (( pollfds + fd ) -> fd , & send_message , msg_len , 0 ) == -1 ) error ( \"send\" ); } break ; case FLIGHT_TIME : valid = true ; // validate flight number if ( recv_message . flight_no [ FLIGHT_NUM_SIZE ]) recv_message . flight_no [ FLIGHT_NUM_SIZE ] = '\\0' ; if ( strlen ( recv_message . flight_no ) < 3 ) valid = false ; if ( ! valid ) { // send error message to client send_message . message_id = htonl ( ERROR_IN_INPUT ); size_t msg_len = sizeof ( long ); if ( send (( pollfds + fd ) -> fd , & send_message , msg_len , 0 ) == -1 ) error ( \"send\" ); break ; } char temp_buf [ FLIGHT_NUM_SIZE + 1 ]; trim ( temp_buf , recv_message . flight_no ); strcpy ( recv_message . flight_no , temp_buf ); struct tnode * ptr ; ptr = find_flight_rec ( root , recv_message . flight_no ); if ( ! ptr ) { memset ( & send_message , '\\0' , sizeof ( struct message )); send_message . message_id = htonl ( FLIGHT_NOT_FOUND ); strcpy ( send_message . flight_no , recv_message . flight_no ); size_t msg_len = sizeof ( struct message ); if ( send (( pollfds + fd ) -> fd , & send_message , msg_len , 0 ) == -1 ) error ( \"send\" ); break ; } send_message . message_id = htonl ( FLIGHT_TIME_RESULT ); strcpy ( send_message . flight_no , recv_message . flight_no ); strcpy ( send_message . departure , ( ptr -> departure ) ? \"D\" : \"A\" ); struct tm * tms ; if (( tms = localtime ( & ( ptr -> flight_time ))) == NULL ) perror ( \"localtime\" ); sprintf ( send_message . date , \"%02d/%02d/%d\" , tms -> tm_mday , tms -> tm_mon + 1 , tms -> tm_year + 1900 ); sprintf ( send_message . time , \"%02d:%02d\" , tms -> tm_hour , tms -> tm_min ); size_t msg_len = sizeof ( struct message ); if ( send (( pollfds + fd ) -> fd , & send_message , msg_len , 0 ) == -1 ) error ( \"send\" ); break ; } } } } // if (fd == ... } // for } // while (1) exit ( EXIT_SUCCESS ); } // main // record the flight departure / arrival time struct tnode * add_to_tree ( struct tnode * p , char * flight_no , bool departure , time_t flight_time ) { int res ; if ( p == NULL ) { // new entry if (( p = ( struct tnode * ) malloc ( sizeof ( struct tnode ))) == NULL ) error ( \"malloc\" ); p -> flight_no = strdup ( flight_no ); p -> departure = departure ; p -> flight_time = flight_time ; p -> left = p -> right = NULL ; } else if (( res = strcmp ( flight_no , p -> flight_no )) == 0 ) { // entry exists p -> departure = departure ; p -> flight_time = flight_time ; } else if ( res < 0 ) // less than flight_no for this node, put in left subtree p -> left = add_to_tree ( p -> left , flight_no , departure , flight_time ); else // greater than flight_no for this node, put in right subtree p -> right = add_to_tree ( p -> right , flight_no , departure , flight_time ); return p ; } // find node for the flight for which departure or arrival time is queried struct tnode * find_flight_rec ( struct tnode * p , char * flight_no ) { int res ; if ( ! p ) return p ; res = strcmp ( flight_no , p -> flight_no ); if ( ! res ) return p ; if ( res < 0 ) return find_flight_rec ( p -> left , flight_no ); else return find_flight_rec ( p -> right , flight_no ); } // print_tree: print the tree (in-order traversal) void print_tree ( struct tnode * p ) { if ( p != NULL ) { print_tree ( p -> left ); printf ( \"%s: %d %s \\n\\n \" , p -> flight_no , ( int ) p -> departure , ctime ( & ( p -> flight_time ))); print_tree ( p -> right ); } } void error ( char * msg ) { perror ( msg ); exit ( 1 ); } // trim: leading and trailing whitespace of string void trim ( char * dest , char * src ) { if ( ! src || ! dest ) return ; int len = strlen ( src ); if ( ! len ) { * dest = '\\0' ; return ; } char * ptr = src + len - 1 ; // remove trailing whitespace while ( ptr > src ) { if ( ! isspace ( * ptr )) break ; ptr -- ; } ptr ++ ; char * q ; // remove leading whitespace for ( q = src ; ( q < ptr && isspace ( * q )); q ++ ) ; while ( q < ptr ) * dest ++ = * q ++ ; * dest = '\\0' ; } /* * flight-time-client.c : get flight time from the server * */ #include <sys/types.h> #include <sys/socket.h> #include <netinet/in.h> #include <arpa/inet.h> #include <netdb.h> #include <stdio.h> #include <string.h> #include <stdlib.h> #include <errno.h> #include <unistd.h> #include <ctype.h> #include <stdint.h> #include <time.h> #define FLIGHT_NUM_SIZE 15 #define SERVER_PORT \"4358\" #define STORE_FLIGHT 1 #define FLIGHT_TIME_STORED 2 #define FLIGHT_TIME 3 #define FLIGHT_TIME_RESULT 4 #define FLIGHT_NOT_FOUND 5 #define ERROR_IN_INPUT 9 #define QUIT 0 void error ( char * msg ); struct message { int32_t message_id ; char flight_no [ FLIGHT_NUM_SIZE + 1 ]; char departure [ 1 + 1 ]; // 'D': departure, 'A': arrival char date [ 10 + 1 ]; // dd/mm/yyyy char time [ 5 + 1 ]; // hh:mm }; struct message message ; int get_input ( void ); void error ( char * msg ); int main ( int argc , char ** argv ) { if ( argc != 2 ) { fprintf ( stderr , \"Usage: client hostname \\n \" ); exit ( EXIT_FAILURE ); } struct addrinfo hints ; memset ( & hints , 0 , sizeof ( struct addrinfo )); hints . ai_family = AF_UNSPEC ; hints . ai_socktype = SOCK_STREAM ; struct addrinfo * result ; int s ; if (( s = getaddrinfo ( argv [ 1 ], SERVER_PORT , & hints , & result )) != 0 ) { fprintf ( stderr , \"getaddrinfo: %s \\n \" , gai_strerror ( s )); exit ( EXIT_FAILURE ); } /* Scan through the list of address structures returned by getaddrinfo. Stop when the the socket and connect calls are successful. */ int sock_fd ; socklen_t length ; struct addrinfo * rptr ; for ( rptr = result ; rptr != NULL ; rptr = rptr -> ai_next ) { sock_fd = socket ( rptr -> ai_family , rptr -> ai_socktype , rptr -> ai_protocol ); if ( sock_fd == -1 ) continue ; if ( connect ( sock_fd , rptr -> ai_addr , rptr -> ai_addrlen ) == -1 ) { if ( close ( sock_fd ) == -1 ) error ( \"close\" ); continue ; } break ; } if ( rptr == NULL ) { // Not successful with any address fprintf ( stderr , \"Not able to connect \\n \" ); exit ( EXIT_FAILURE ); } freeaddrinfo ( result ); int option ; while ( 1 ) { option = get_input (); if ( option == QUIT ) break ; // send request to server if ( send ( sock_fd , & message , sizeof ( struct message ), MSG_NOSIGNAL ) == -1 ) error ( \"send\" ); // receive response from server if ( recv ( sock_fd , & message , sizeof ( struct message ), 0 ) == -1 ) error ( \"recv\" ); // process server response switch ( ntohl ( message . message_id )) { case FLIGHT_TIME_STORED : case FLIGHT_TIME_RESULT : printf ( \" \\n Response: \\n\\n \" ); printf ( \" \\t %s: %s %s %s \\n\\n \" , message . flight_no , message . departure , message . date , message . time ); break ; case FLIGHT_NOT_FOUND : printf ( \" \\n Flight not found \\n\\n \" ); break ; case ERROR_IN_INPUT : printf ( \" \\n Error in input \\n\\n \" ); break ; default : printf ( \" \\n Unrecongnized message from server \\n\\n \" ); } } exit ( EXIT_SUCCESS ); } char inbuf [ 512 ]; int get_input ( void ) { int option ; while ( 1 ) { printf ( \"Flight Info \\n\\n \" ); printf ( \" \\t Flight time query \\t 1 \\n \" ); printf ( \" \\t Store flight time \\t 2 \\n \" ); printf ( \" \\t Quit \\t\\t 0 \\n\\n \" ); printf ( \"Your option: \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); sscanf ( inbuf , \"%d\" , & option ); int len ; switch ( option ) { case 1 : message . message_id = htonl ( FLIGHT_TIME ); printf ( \"Flight no: \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); len = strlen ( inbuf ); if ( inbuf [ len - 1 ] == '\\n' ) inbuf [ len - 1 ] = '\\0' ; strcpy ( message . flight_no , inbuf ); break ; case 2 : message . message_id = htonl ( STORE_FLIGHT ); printf ( \"Flight no: \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); len = strlen ( inbuf ); if ( inbuf [ len - 1 ] == '\\n' ) inbuf [ len - 1 ] = '\\0' ; strcpy ( message . flight_no , inbuf ); while ( 1 ) { printf ( \"A/D: \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); message . departure [ 0 ] = toupper ( inbuf [ 0 ]); message . departure [ 1 ] = '\\0' ; if (( message . departure [ 0 ] == 'A' ) || ( message . departure [ 0 ] == 'D' )) break ; printf ( \"Error in input, valid values are A and D \\n \" ); } printf ( \"date (dd/mm/yyyy): \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); strncpy ( message . date , inbuf , 10 ); message . date [ 10 ] = '\\0' ; printf ( \"time (hh:mm): \" ); if ( fgets ( inbuf , sizeof ( inbuf ), stdin ) == NULL ) error ( \"fgets\" ); strncpy ( message . time , inbuf , 5 ); message . time [ 5 ] = '\\0' ; break ; case 0 : break ; default : printf ( \"Illegal option, try again \\n\\n \" ); continue ; } return option ; } } void error ( char * msg ) { perror ( msg ); exit ( 1 ); }","title":"IO Multiplexing"},{"location":"EmbeddedSystems/os/","text":"Questions: Where does the kernel scheduler run ? Since kernel process scheduling is done as a part of timer interrupt, do interrupt handlers have there own thread and stack ? signaction handlers set from user space application are run in userspace or kernel space This is nothing but a signal handling. signal can be sent from user space to kernel, kernel to user space, user space to userspace https://embetronicx.com/tutorials/linux/device-drivers/sending-signal-from-linux-device-driver-to-user-space/ How does device write at particular address ? How is that address decided ? How is address of isr decided for different peripheral devices ? Where is DMA controller ? inside each io device or common for bus ? How is bus shared between dma and process ? How is ram with less than 1GB mapped with linux kernel ? Top 1GB is mapped for kernel in virtual space. So whenever processor asks for kernel memory, MMU will translate and do paging if required. https://stackoverflow.com/a/4607342 x86 CISC Arm RISC","title":"Os"},{"location":"EmbeddedSystems/os/#questions","text":"Where does the kernel scheduler run ? Since kernel process scheduling is done as a part of timer interrupt, do interrupt handlers have there own thread and stack ? signaction handlers set from user space application are run in userspace or kernel space This is nothing but a signal handling. signal can be sent from user space to kernel, kernel to user space, user space to userspace https://embetronicx.com/tutorials/linux/device-drivers/sending-signal-from-linux-device-driver-to-user-space/ How does device write at particular address ? How is that address decided ? How is address of isr decided for different peripheral devices ? Where is DMA controller ? inside each io device or common for bus ? How is bus shared between dma and process ? How is ram with less than 1GB mapped with linux kernel ? Top 1GB is mapped for kernel in virtual space. So whenever processor asks for kernel memory, MMU will translate and do paging if required. https://stackoverflow.com/a/4607342 x86 CISC Arm RISC","title":"Questions:"},{"location":"OOP/oop_resources/","text":"Source Making: Design Patterns Bharat Acharya: Microprocessor Kernel-User communication EmbedTronix: Linux Device Driver System Design: Designing data Intesive Applications","title":"Resources"},{"location":"OOP/oop_resources/#source-making-design-patterns","text":"","title":"Source Making: Design Patterns"},{"location":"OOP/oop_resources/#bharat-acharya-microprocessor","text":"","title":"Bharat Acharya: Microprocessor"},{"location":"OOP/oop_resources/#kernel-user-communication","text":"","title":"Kernel-User communication"},{"location":"OOP/oop_resources/#embedtronix-linux-device-driver","text":"","title":"EmbedTronix: Linux Device Driver"},{"location":"OOP/oop_resources/#system-design-designing-data-intesive-applications","text":"","title":"System Design: Designing data Intesive Applications"},{"location":"SystemDesign/system_design_resources/","text":"HiredInTech","title":"Resources"},{"location":"SystemDesign/system_design_resources/#hiredintech","text":"","title":"HiredInTech"},{"location":"Techniques/mustknow_difficult/","text":"Must Know Techniques Generate prime numbers till n Reference: GFG Article // Time Complexity: O(n*log(log(n))) // C++ program to print all primes smaller than or equal to n using Sieve of Eratosthenes void SieveOfEratosthenes ( int n ) { //Create a boolean array \"prime[0..n]\" and initialize all entries it as true. //A value in prime[i] will finally be false if i is Not a prime, else true. bool prime [ n + 1 ]; memset ( prime , true , sizeof ( prime )); for ( int p = 2 ; p * p <= n ; p ++ ) { // If prime[p] is not changed, then it is a prime if ( prime [ p ] == true ) { //Update all multiples of p greater than or equal to the square of it //numbers which are multiple of p and are less than p^2 are already been marked. for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } // Print all prime numbers for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ]) cout << p << \" \" ; } Follow up question: Shortest path to reach one prime to other by changing single digit at a time /* find out all 4 digit prime numbers till 9999 using above technique, compare each prime number with all next prime number and form a connection if only 1 digit changes Run BFS traversal to find min path from x to y */ class graph { int V ; list < int >* l ; public : graph ( int V ) { this -> V = V ; l = new list < int > [ V ]; } void addedge ( int V1 , int V2 ) { //Adjacency List l [ V1 ]. push_back ( V2 ); l [ V2 ]. push_back ( V1 ); } int bfs ( int in1 , int in2 ); }; // in1 and in2 are two vertices of graph which are // actually indexes in pset[](prime numbers till 9999) int graph::bfs ( int in1 , int in2 ) { int visited [ V ]; memset ( visited , 0 , sizeof ( visited )); queue < int > que ; visited [ in1 ] = 1 ; que . push ( in1 ); list < int >:: iterator i ; while ( ! que . empty ()) { int p = que . front (); que . pop (); for ( i = l [ p ]. begin (); i != l [ p ]. end (); i ++ ) { if ( ! visited [ * i ]) { visited [ * i ] = visited [ p ] + 1 ; que . push ( * i ); } if ( * i == in2 ) { return visited [ * i ] - 1 ; } } } } // Returns true if num1 and num2 differ // by single digit. bool compare ( int num1 , int num2 ) { // To compare the digits string s1 = to_string ( num1 ); string s2 = to_string ( num2 ); int c = 0 ; if ( s1 [ 0 ] != s2 [ 0 ]) c ++ ; if ( s1 [ 1 ] != s2 [ 1 ]) c ++ ; if ( s1 [ 2 ] != s2 [ 2 ]) c ++ ; if ( s1 [ 3 ] != s2 [ 3 ]) c ++ ; // If the numbers differ only by a single // digit return true else false return ( c == 1 ); } int shortestPath ( int num1 , int num2 ) { // Generate all 4 digit vector < int > pset ; SieveOfEratosthenes ( pset ); // Create a graph where node numbers are indexes // in pset[] and there is an edge between two // nodes only if they differ by single digit. graph g ( pset . size ()); for ( int i = 0 ; i < pset . size (); i ++ ) for ( int j = i + 1 ; j < pset . size (); j ++ ) if ( compare ( pset [ i ], pset [ j ])) g . addedge ( i , j ); // Since graph nodes represent indexes of numbers // in pset[], we find indexes of num1 and num2. int in1 , in2 ; for ( int j = 0 ; j < pset . size (); j ++ ) if ( pset [ j ] == num1 ) in1 = j ; for ( int j = 0 ; j < pset . size (); j ++ ) if ( pset [ j ] == num2 ) in2 = j ; return g . bfs ( in1 , in2 ); } Euclidean algorithms GCD of two numbers is the largest number that divides both of them. A simple way to find GCD is to factorize both numbers and multiply common prime factors. Basic Euclidean Algorithm for GCD The algorithm is based on the below facts. If we subtract a smaller number from a larger (we reduce a larger number), GCD doesn\u2019t change. So if we keep subtracting repeatedly the larger of two, we end up with GCD. Now instead of subtraction, if we divide the smaller number, the algorithm stops when we find remainder 0. Below is a recursive function to evaluate gcd using Euclid\u2019s algorithm. //Time complexity: O(Log max(a, b)) // Function to return gcd of a and b int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ); } The extended Euclidean algorithm updates results of gcd(a, b) using the results calculated by recursive call gcd(b%a, a). Let values of x and y calculated by the recursive call be x1 and y1. x and y are updated using the below expressions. x = y1 - \u230a b / a \u230b * x1 y = x1 // Function for extended Euclidean Algorithm int gcdExtended ( int a , int b , int * x , int * y ) { // Base Case if ( a == 0 ) { * x = 0 ; * y = 1 ; return b ; } int x1 , y1 ; // To store results of recursive call int gcd = gcdExtended ( b % a , a , & x1 , & y1 ); // Update x and y using results of recursive call * x = y1 - ( b / a ) * x1 ; * y = x1 ; return gcd ; } int main () { int x , y , a = 35 , b = 15 ; int g = gcdExtended ( a , b , & x , & y ); cout << \"GCD(\" << a << \", \" << b << \") = \" << g << endl ; return 0 ; } How does Extended Algorithm Work? As seen above, x and y are results for inputs a and b, a.x + b.y = gcd ----(1) And x1 and y1 are results for inputs b%a and a (b%a).x1 + a.y1 = gcd When we put b%a = (b - (\u230ab/a\u230b).a) in above, we get following. Note that \u230ab/a\u230b is floor(b/a) (b - (\u230ab/a\u230b).a).x1 + a.y1 = gcd Above equation can also be written as below b.x1 + a.(y1 - (\u230ab/a\u230b).x1) = gcd ---(2) After comparing coefficients of 'a' and 'b' in (1) and (2), we get following x = y1 - \u230ab/a\u230b * x1 y = x1 How is Extended Algorithm Useful? The extended Euclidean algorithm is particularly useful when a and b are coprime (or gcd is 1). Since x is the modular multiplicative inverse of \u201ca modulo b\u201d, and y is the modular multiplicative inverse of \u201cb modulo a\u201d. In particular, the computation of the modular multiplicative inverse is an essential step in RSA public-key encryption method.","title":"Difficult"},{"location":"Techniques/mustknow_difficult/#must-know-techniques","text":"","title":"Must Know Techniques"},{"location":"Techniques/mustknow_difficult/#generate-prime-numbers-till-n","text":"Reference: GFG Article // Time Complexity: O(n*log(log(n))) // C++ program to print all primes smaller than or equal to n using Sieve of Eratosthenes void SieveOfEratosthenes ( int n ) { //Create a boolean array \"prime[0..n]\" and initialize all entries it as true. //A value in prime[i] will finally be false if i is Not a prime, else true. bool prime [ n + 1 ]; memset ( prime , true , sizeof ( prime )); for ( int p = 2 ; p * p <= n ; p ++ ) { // If prime[p] is not changed, then it is a prime if ( prime [ p ] == true ) { //Update all multiples of p greater than or equal to the square of it //numbers which are multiple of p and are less than p^2 are already been marked. for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } // Print all prime numbers for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ]) cout << p << \" \" ; } Follow up question: Shortest path to reach one prime to other by changing single digit at a time /* find out all 4 digit prime numbers till 9999 using above technique, compare each prime number with all next prime number and form a connection if only 1 digit changes Run BFS traversal to find min path from x to y */ class graph { int V ; list < int >* l ; public : graph ( int V ) { this -> V = V ; l = new list < int > [ V ]; } void addedge ( int V1 , int V2 ) { //Adjacency List l [ V1 ]. push_back ( V2 ); l [ V2 ]. push_back ( V1 ); } int bfs ( int in1 , int in2 ); }; // in1 and in2 are two vertices of graph which are // actually indexes in pset[](prime numbers till 9999) int graph::bfs ( int in1 , int in2 ) { int visited [ V ]; memset ( visited , 0 , sizeof ( visited )); queue < int > que ; visited [ in1 ] = 1 ; que . push ( in1 ); list < int >:: iterator i ; while ( ! que . empty ()) { int p = que . front (); que . pop (); for ( i = l [ p ]. begin (); i != l [ p ]. end (); i ++ ) { if ( ! visited [ * i ]) { visited [ * i ] = visited [ p ] + 1 ; que . push ( * i ); } if ( * i == in2 ) { return visited [ * i ] - 1 ; } } } } // Returns true if num1 and num2 differ // by single digit. bool compare ( int num1 , int num2 ) { // To compare the digits string s1 = to_string ( num1 ); string s2 = to_string ( num2 ); int c = 0 ; if ( s1 [ 0 ] != s2 [ 0 ]) c ++ ; if ( s1 [ 1 ] != s2 [ 1 ]) c ++ ; if ( s1 [ 2 ] != s2 [ 2 ]) c ++ ; if ( s1 [ 3 ] != s2 [ 3 ]) c ++ ; // If the numbers differ only by a single // digit return true else false return ( c == 1 ); } int shortestPath ( int num1 , int num2 ) { // Generate all 4 digit vector < int > pset ; SieveOfEratosthenes ( pset ); // Create a graph where node numbers are indexes // in pset[] and there is an edge between two // nodes only if they differ by single digit. graph g ( pset . size ()); for ( int i = 0 ; i < pset . size (); i ++ ) for ( int j = i + 1 ; j < pset . size (); j ++ ) if ( compare ( pset [ i ], pset [ j ])) g . addedge ( i , j ); // Since graph nodes represent indexes of numbers // in pset[], we find indexes of num1 and num2. int in1 , in2 ; for ( int j = 0 ; j < pset . size (); j ++ ) if ( pset [ j ] == num1 ) in1 = j ; for ( int j = 0 ; j < pset . size (); j ++ ) if ( pset [ j ] == num2 ) in2 = j ; return g . bfs ( in1 , in2 ); }","title":"Generate prime numbers till n"},{"location":"Techniques/mustknow_difficult/#euclidean-algorithms","text":"GCD of two numbers is the largest number that divides both of them. A simple way to find GCD is to factorize both numbers and multiply common prime factors. Basic Euclidean Algorithm for GCD The algorithm is based on the below facts. If we subtract a smaller number from a larger (we reduce a larger number), GCD doesn\u2019t change. So if we keep subtracting repeatedly the larger of two, we end up with GCD. Now instead of subtraction, if we divide the smaller number, the algorithm stops when we find remainder 0. Below is a recursive function to evaluate gcd using Euclid\u2019s algorithm. //Time complexity: O(Log max(a, b)) // Function to return gcd of a and b int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ); } The extended Euclidean algorithm updates results of gcd(a, b) using the results calculated by recursive call gcd(b%a, a). Let values of x and y calculated by the recursive call be x1 and y1. x and y are updated using the below expressions. x = y1 - \u230a b / a \u230b * x1 y = x1 // Function for extended Euclidean Algorithm int gcdExtended ( int a , int b , int * x , int * y ) { // Base Case if ( a == 0 ) { * x = 0 ; * y = 1 ; return b ; } int x1 , y1 ; // To store results of recursive call int gcd = gcdExtended ( b % a , a , & x1 , & y1 ); // Update x and y using results of recursive call * x = y1 - ( b / a ) * x1 ; * y = x1 ; return gcd ; } int main () { int x , y , a = 35 , b = 15 ; int g = gcdExtended ( a , b , & x , & y ); cout << \"GCD(\" << a << \", \" << b << \") = \" << g << endl ; return 0 ; } How does Extended Algorithm Work? As seen above, x and y are results for inputs a and b, a.x + b.y = gcd ----(1) And x1 and y1 are results for inputs b%a and a (b%a).x1 + a.y1 = gcd When we put b%a = (b - (\u230ab/a\u230b).a) in above, we get following. Note that \u230ab/a\u230b is floor(b/a) (b - (\u230ab/a\u230b).a).x1 + a.y1 = gcd Above equation can also be written as below b.x1 + a.(y1 - (\u230ab/a\u230b).x1) = gcd ---(2) After comparing coefficients of 'a' and 'b' in (1) and (2), we get following x = y1 - \u230ab/a\u230b * x1 y = x1 How is Extended Algorithm Useful? The extended Euclidean algorithm is particularly useful when a and b are coprime (or gcd is 1). Since x is the modular multiplicative inverse of \u201ca modulo b\u201d, and y is the modular multiplicative inverse of \u201cb modulo a\u201d. In particular, the computation of the modular multiplicative inverse is an essential step in RSA public-key encryption method.","title":"Euclidean algorithms"},{"location":"docs/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"docs/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"docs/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"docs/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"}]}